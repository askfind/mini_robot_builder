## Миниробот для нанесения рисунка аэрографом на
поверхности плитки

Год 2002.

Владелец строительного магазина обратился ко мне с просьбой:

- Мы планируем открыть цех по производству плиток из гипса с рисунками. Нам нужен автомат для нанесения рисунка.
Сможешь ли сделать?
- Вы хоть покажите как сейчас вручную рисуете картинки.
- Хорошо приходи вечером. Покажем.

Собрались я, Сергей и однокласник Олег. Они залили гипс водой. Достали аэрограф, подключив сжатый воздух с краской.
Худодники они, как мягче сказать, любители. На поверхности плитки получился "совремнный авангард". Ясное дело, что такой рисунок никогда и никому не продать.

- Вот видишь! Не можем мы красиво рисунок положить на поверхность плитки. Сможешь нам робота сделать.

Я ответил: "Шанс есть. У меня остался старый матричный принтер для большой широкой бумаги. Можно использовать механизм позиционирования и сделать макет управления шаговыми двигателями.
Подключим компьютер и постараемся управлять аэрографом".


Мне выдали рубли для покупки микроконтроллеров AVR Atmel Corporation 8-bit. У меня был опыт написания программ на ассемблере Intel 8035.

В проекте "Миниробот для нанесения рисунка аэрографом" впервые использовал язык программирования Си, а также применил для технологию для программного обеспечения на основе "Автоматного программирования", "SWITCH-технологии".


##  Проектная документация (фрагмент)

### Введение

С появлением новых пребований покупателей к разнообразию дизайна облицовочной,
гипсовой плитки возникла необходимость автоматизации процесса нанесения рисунков на
поверхность. В процессе изготовления плитки необходимо грунтовать поверхность лаком,
затем краскораспылителем нанести тонкий фоновый слой. Аэрографом наносится
выбранный из каталога рисуннок.

В настоящем проекте предложено решение на основе микроконтроллеров серии AVR,
которые обеспечивают управление исполнительными механизмами и цикл нанесения
рисунка на поверхность плитки.
Эту задачу целесообразно решать с использованием технологии автоматов. Для ее
алгоритмизации и программирования оказалось удобным применить SWITCH-технологию


Настоящая работа призвана автоматизировать этап нанесения рисунка на поверхность
плитки, уменьшить брак при произвостве и увеличить производительность производства.
1. Постановка задачи
Целью настоящего проекта является изготовление макета миниробота для нанесения
рисунка аэрографом на поверхности облицовочной плитки.

Миниробот состоит из следующих частей:

 - Исполнительный механизм для перемещения аэрографа шаговыми двигателями;
 - Модули управления шаговыми двигателями по осям X, Y, Z;
 - Устройство управления подачей краски для аэрографа;
 - Модуль управления, который формирует задания для остальных модулей (шаговые
двигатели, индикации, пульт управления оператором). Модуль управления
подключается к персональному компьютеру через интерфейс RS-232C.

Миниробот состоит из связанных автоматов с явным выделением состояний. Создается схема связи и граф переходов автоматов.

Алгоритмы автоматов реализованы на языках программирования ASM, C
микроконтроллера AVR. На ассемблеры реализованы функции, которые критичны к времени
выполнения. Язык программирования С позволяет ускорить проектирование, отладку
программных модулей автоматов.

Для макетирования и отладки программы использовался набор AVR Starter Kit
STK500.

```C
Приложение 2 'Программный код UART0_A1x.c'
/*********************************************
* Programm:
UART0_A1x.c
*
*
*
* Note: For projekt MINIROBIT BUILDING *
*
*
* Name: Module Code adapted from Atmel AVR *ЧП Васильев В.И., эл. почта: vvasiyev@gmail.com,
сайт: www.robot-ivan.narod.ru
*
Application for Amega161
*
*
Interrupt mode driver for UART0. *
*
*
* Edit data: 28.08.2002
*
* Last data: 1.10.2002
*
* Version:
0.02
*
**********************************************/
#include "iom161.h"
#include "uart0_A1x.h"
#include "uart0_A1x_decl.h"
#include "stdio.h"
#include "ctype.h"
/* Debug test UART0 for module */
// #define TEST_UART0
/*---------------------*/
/* Start Rx/Tx UART0 */
void Enb_UART0(void)
// Enable Rx/Tx
{
UCSR0B = UCSR0B | (1<<TXEN0); // TXEN0 = 1
UCSR0B = UCSR0B | (1<<RXEN0); // RXEN0 = 1
UCSR0B = UCSR0B | (1<<RXCIE0); // RXCIE0= 1
}
/*-------------------*/
/* Start Rx UART0 */
void Enb_Rx_UART0(void)
// Enable Rx
{
UCSR0B = UCSR0B | (1<<RXEN0); // RXEN0 = 1
UCSR0B = UCSR0B | (1<<RXCIE0); // RXCIE0= 1
}
/*-------------------*/
/* Start Tx UART0 */
void Enb_Tx_UART0(void)
// Enable Tx
{
UCSR0B = UCSR0B | (1<<TXEN0); // TXEN0 = 1
}
/*--------------------*/
/* Stop Rx/Tx UART0 */
void Dis_UART0(void)
// Disable Rx/Tx
{
UCSR0B = UCSR0B & ~(1<<TXEN0); // TXEN0 = 0
UCSR0B = UCSR0B & ~(1<<RXEN0); // RXEN0 = 0
UCSR0B = UCSR0B & ~(1<<RXCIE0); // RXCIE0 = 0
}ЧП Васильев В.И., эл. почта: vvasiyev@gmail.com,
сайт: www.robot-ivan.narod.ru
/*------------------*/
/* Stop Rx UART0 */
void Dis_Rx_UART0(void)
// Disable Rx
{
UCSR0B = UCSR0B & ~(1<<RXEN0); // RXEN0 = 0
UCSR0B = UCSR0B & ~(1<<RXCIE0); // RXCIE0 = 0
}
/*--------------------*/
/* Stop Tx UART0 */
void Dis_Tx_UART0(void)
// Disable Tx
{
UCSR0B = UCSR0B & ~(1<<TXEN0); // TXEN0 = 0
}
```
