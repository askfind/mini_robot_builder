        MODULE uart0_A1x

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__cpu", "3"
        RTMODEL "__cpu_name", "AT90Mega161"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "false"
        RTMODEL "__memory_model", "2"
        RTMODEL "__rt_version", "2.30"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG NEAR_I:DATA:NOROOT(0)
        RSEG NEAR_ID:CODE:NOROOT(0)
        RSEG NEAR_Z:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?need_segment_init
        EXTERN ?PROLOGUE3_L09
        EXTERN ?UL_DIVMOD_L03
        EXTERN ?EPILOGUE_B3_L09
        EXTERN ?S_MUL_L02
        EXTERN ?PROLOGUE4_L09
        EXTERN ?EPILOGUE_B4_L09
        EXTERN printf
        FUNCTION printf,0202H
        EXTERN CheckParity7
        FUNCTION CheckParity7,0202H
        EXTERN CheckParity8
        FUNCTION CheckParity8,0202H

        PUBWEAK `?<Segment init: NEAR_I>`
        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBLIC Break_UART0
        FUNCTION Break_UART0,0203H
        PUBLIC CTS_CLR_UART0
        FUNCTION CTS_CLR_UART0,0203H
        PUBLIC CTS_OFF_CONTR_UART0
        FUNCTION CTS_OFF_CONTR_UART0,0203H
        PUBLIC CTS_ON_CONTR_UART0
        FUNCTION CTS_ON_CONTR_UART0,0203H
        PUBLIC CTS_SET_UART0
        FUNCTION CTS_SET_UART0,0203H
        PUBLIC ControlStream_OFF_UART0
        FUNCTION ControlStream_OFF_UART0,0203H
        PUBLIC ControlStream_ON_UART0
        FUNCTION ControlStream_ON_UART0,0203H
        PUBLIC CopySetsEEPROM_UART0
        FUNCTION CopySetsEEPROM_UART0,0203H
        PUBLIC CopySetsROM_UART0
        FUNCTION CopySetsROM_UART0,0203H
        PUBLIC DSR_CLR_UART0
        FUNCTION DSR_CLR_UART0,0203H
        PUBLIC DSR_OFF_CONTR_UART0
        FUNCTION DSR_OFF_CONTR_UART0,0203H
        PUBLIC DSR_ON_CONTR_UART0
        FUNCTION DSR_ON_CONTR_UART0,0203H
        PUBLIC DSR_SET_UART0
        FUNCTION DSR_SET_UART0,0203H
        PUBLIC DTR_CLR_UART0
        FUNCTION DTR_CLR_UART0,0203H
        PUBLIC DTR_OFF_CONTR_UART0
        FUNCTION DTR_OFF_CONTR_UART0,0203H
        PUBLIC DTR_ON_CONTR_UART0
        FUNCTION DTR_ON_CONTR_UART0,0203H
        PUBLIC DTR_SET_UART0
        FUNCTION DTR_SET_UART0,0203H
        PUBLIC DataInReceiveBuffer
        FUNCTION DataInReceiveBuffer,0203H
        PUBLIC Dis_Rx_UART0
        FUNCTION Dis_Rx_UART0,0203H
        PUBLIC Dis_Tx_UART0
        FUNCTION Dis_Tx_UART0,0203H
        PUBLIC Dis_UART0
        FUNCTION Dis_UART0,0203H
        PUBLIC Disable_Err_Count_UART0
        FUNCTION Disable_Err_Count_UART0,0203H
        PUBLIC Echo_OFF_UART0
        FUNCTION Echo_OFF_UART0,0203H
        PUBLIC Echo_ON_UART0
        FUNCTION Echo_ON_UART0,0203H
        PUBLIC Enable_Err_Count_UART0
        FUNCTION Enable_Err_Count_UART0,021203H
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Enb_Rx_UART0
        FUNCTION Enb_Rx_UART0,0203H
        PUBLIC Enb_Tx_UART0
        FUNCTION Enb_Tx_UART0,0203H
        PUBLIC Enb_UART0
        FUNCTION Enb_UART0,0203H
        PUBLIC IncErrArr_UART0
        FUNCTION IncErrArr_UART0,0203H
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Init_2S_UART0
        FUNCTION Init_2S_UART0,021203H
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Init_B_UART0
        FUNCTION Init_B_UART0,021203H
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Init_CHR9_UART0
        FUNCTION Init_CHR9_UART0,0203H
        PUBLIC Init_MPCM_UART0
        FUNCTION Init_MPCM_UART0,021203H
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Init_P_UART0
        FUNCTION Init_P_UART0,021203H
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Init_S_UART0
        FUNCTION Init_S_UART0,021203H
        LOCFRAME CSTACK, 9, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC RTS_CLR_UART0
        FUNCTION RTS_CLR_UART0,0203H
        PUBLIC RTS_OFF_CONTR_UART0
        FUNCTION RTS_OFF_CONTR_UART0,0203H
        PUBLIC RTS_ON_CONTR_UART0
        FUNCTION RTS_ON_CONTR_UART0,0203H
        PUBLIC RTS_SET_UART0
        FUNCTION RTS_SET_UART0,0203H
        PUBLIC Read_Tx_Rx_Err_UART0
        FUNCTION Read_Tx_Rx_Err_UART0,021203H
        LOCFRAME CSTACK, 10, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC ReceiveByte_UART0
        FUNCTION ReceiveByte_UART0,0203H
        PUBLIC Reset_UART0
        FUNCTION Reset_UART0,021203H
        LOCFRAME CSTACK, 5, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC S16e
        PUBLIC S18e
        PUBLIC S21e
        PUBLIC S22e
        PUBLIC S23e
        PUBLIC S39e
        PUBLIC S3e
        PUBLIC S4e
        PUBLIC S51e
        PUBLIC S5e
        PUBLIC TransmitByte_UART0
        FUNCTION TransmitByte_UART0,0203H
        FUNCTION UART0_RX,021233H
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCTION UART0_UDRE,021233H
        LOCFRAME CSTACK, 16, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC XON_XOFF_OFF_CONTR_Rx_UART0
        FUNCTION XON_XOFF_OFF_CONTR_Rx_UART0,0203H
        PUBLIC XON_XOFF_OFF_CONTR_Tx_UART0
        FUNCTION XON_XOFF_OFF_CONTR_Tx_UART0,0203H
        PUBLIC XON_XOFF_ON_CONTR_Rx_UART0
        FUNCTION XON_XOFF_ON_CONTR_Rx_UART0,0203H
        PUBLIC XON_XOFF_ON_CONTR_Tx_UART0
        FUNCTION XON_XOFF_ON_CONTR_Tx_UART0,0203H
        PUBWEAK _A_DDRC
        PUBWEAK _A_DDRD
        PUBWEAK _A_PIND
        PUBWEAK _A_PORTC
        PUBWEAK _A_PORTD
        PUBWEAK _A_UBRR0
        PUBWEAK _A_UCSR0A
        PUBWEAK _A_UCSR0B
        PUBWEAK _A_UDR0
        PUBLIC fBit_CTS0
        PUBLIC fBit_DSR0
        PUBLIC fBit_DTR0
        PUBLIC fBit_RTS0
        PUBLIC fCheckParity_UART0
        PUBLIC fContrStream_UART0
        PUBLIC fCount_XOFF_Rx_UART0
        PUBLIC fCount_XOFF_Tx_UART0
        PUBLIC fEnb_CTS0
        PUBLIC fEnb_DSR0
        PUBLIC fEnb_DTR0
        PUBLIC fEnb_Echo_UART0
        PUBLIC fEnb_Err_UART0
        PUBLIC fEnb_RTS0
        PUBLIC fEnb_XON_XOFF_Rx_UART0
        PUBLIC fEnb_XON_XOFF_Tx_UART0
        PUBLIC fModeCHR90
        PUBLIC fModeMPCM0
        PUBLIC fModeU2X0
        PUBLIC fSizeBit_UART0
        PUBLIC fSpeedBaud_UART0
        PUBLIC fSym_XOFF
        PUBLIC fSym_XON
;     1 /*********************************************
;     2 * Programm:       UART0_A1x.c                *
;     3 *                                            *
;     4 *  Note:  For projekt MINIROBIT BUILDING     *
;     5 *                                            *
;     6 * Name:  Module Code adapted from Atmel AVR  *
;     7 *        Application for Amega161            *
;     8 *        Interrupt mode driver for UART0.    *
;     9 *                                            *
;    10 * Edit data:     28.08.2002                  *
;    11 * Last data:     1.10.2002                  *
;    12 * Version:       0.02                        *
;    13 **********************************************/
;    14 
;    15 #include "iom161.h"

        ASEGN ABSOLUTE:DATA:NOROOT,029H
; union <unnamed> volatile __io _A_UBRR0;
_A_UBRR0:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,02aH
; union <unnamed> volatile __io _A_UCSR0B;
_A_UCSR0B:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,02bH
; union <unnamed> volatile __io _A_UCSR0A;
_A_UCSR0A:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,02cH
; union <unnamed> volatile __io _A_UDR0;
_A_UDR0:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,030H
; union <unnamed> volatile __io _A_PIND;
_A_PIND:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,031H
; union <unnamed> volatile __io _A_DDRD;
_A_DDRD:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,032H
; union <unnamed> volatile __io _A_PORTD;
_A_PORTD:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,034H
; union <unnamed> volatile __io _A_DDRC;
_A_DDRC:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,035H
; union <unnamed> volatile __io _A_PORTC;
_A_PORTC:
	DS 1
;    16 #include "uart0_A1x.h"
;    17 #include "uart0_A1x_decl.h"

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned int const __flash fSpeedBaud_UART0;
fSpeedBaud_UART0:
	DW 9600

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fModeU2X0;
fModeU2X0:
	DB 0

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fModeCHR90;
fModeCHR90:
	DB 0

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fCheckParity_UART0;
fCheckParity_UART0:
	DB 0

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fSizeBit_UART0;
fSizeBit_UART0:
	DB 1

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fContrStream_UART0;
fContrStream_UART0:
	DB 0

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fEnb_DTR0;
fEnb_DTR0:
	DB 1

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fBit_DTR0;
fBit_DTR0:
	DB 1

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fEnb_DSR0;
fEnb_DSR0:
	DB 1

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fBit_DSR0;
fBit_DSR0:
	DB 1

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fEnb_RTS0;
fEnb_RTS0:
	DB 1

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fBit_RTS0;
fBit_RTS0:
	DB 1

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fEnb_CTS0;
fEnb_CTS0:
	DB 1

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fBit_CTS0;
fBit_CTS0:
	DB 1

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fSym_XON;
fSym_XON:
	DB 17

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fSym_XOFF;
fSym_XOFF:
	DB 19

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fEnb_XON_XOFF_Tx_UART0;
fEnb_XON_XOFF_Tx_UART0:
	DB 1

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fCount_XOFF_Tx_UART0;
fCount_XOFF_Tx_UART0:
	DB 0

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fEnb_XON_XOFF_Rx_UART0;
fEnb_XON_XOFF_Rx_UART0:
	DB 1

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fCount_XOFF_Rx_UART0;
fCount_XOFF_Rx_UART0:
	DB 0

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fEnb_Echo_UART0;
fEnb_Echo_UART0:
	DB 1

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fModeMPCM0;
fModeMPCM0:
	DB 0

        RSEG NEAR_F:CODE:NOROOT(0)
; unsigned char const __flash fEnb_Err_UART0;
fEnb_Err_UART0:
	DB 0

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near A1x_y;
A1x_y:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned int volatile __near SpeedBaud_UART0;
SpeedBaud_UART0:
	DS 2

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near ModeU2X0;
ModeU2X0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near ModeCHR90;
ModeCHR90:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near CheckParity_UART0;
CheckParity_UART0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near SizeBit_UART0;
SizeBit_UART0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near ContrStream_UART0;
ContrStream_UART0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Enb_DTR0;
Enb_DTR0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Bit_DTR0;
Bit_DTR0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Enb_DSR0;
Enb_DSR0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Bit_DSR0;
Bit_DSR0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Enb_RTS0;
Enb_RTS0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Bit_RTS0;
Bit_RTS0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Enb_CTS0;
Enb_CTS0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Bit_CTS0;
Bit_CTS0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Sym_XON;
Sym_XON:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Sym_XOFF;
Sym_XOFF:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Enb_XON_XOFF_Tx_UART0;
Enb_XON_XOFF_Tx_UART0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Count_XOFF_Rx_UART0;
Count_XOFF_Rx_UART0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Enb_XON_XOFF_Rx_UART0;
Enb_XON_XOFF_Rx_UART0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Count_XOFF_Tx_UART0;
Count_XOFF_Tx_UART0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Enb_Echo_UART0;
Enb_Echo_UART0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near ModeMPCM0;
ModeMPCM0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near Enb_Err_UART0;
Enb_Err_UART0:
	DS 1

        ASEGN ABSOLUTE:DATA:NOROOT,040H
	DS 1

        RSEG EEPROM_I:XDATA:NOROOT(0)
; unsigned char __eeprom S3e;
S3e:
	DB 0

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; unsigned char __near S4e;
S4e:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; unsigned char __near S5e;
S5e:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; unsigned char __near S16e;
S16e:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; unsigned char __near S18e;
S18e:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; unsigned char __near S21e;
S21e:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; unsigned char __near S22e;
S22e:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; unsigned char __near S23e;
S23e:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; unsigned char __near S39e;
S39e:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; unsigned char __near S51e;
S51e:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near RxBuf_UART0[32];
RxBuf_UART0:
	DS 32

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near RxHead_UART0;
RxHead_UART0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near RxTail_UART0;
RxTail_UART0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near TxBuf_UART0[32];
TxBuf_UART0:
	DS 32

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near TxHead_UART0;
TxHead_UART0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned char volatile __near TxTail_UART0;
TxTail_UART0:
	DS 1

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned int volatile __near Rx_Tx_Err_UART0[5];
Rx_Tx_Err_UART0:
	DS 10

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned long volatile __near Count_Rx_UART0;
Count_Rx_UART0:
	DS 4

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned long volatile __near Count_Rx_Err_UART0;
Count_Rx_Err_UART0:
	DS 4

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned long volatile __near Count_Tx_UART0;
Count_Tx_UART0:
	DS 4

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; static unsigned long volatile __near Count_Tx_Err_UART0;
Count_Tx_Err_UART0:
	DS 4
;    18 #include "stdio.h"
;    19 #include "ctype.h"
;    20 
;    21 /* Debug test UART0 for module */
;    22 // #define TEST_UART0
;    23 
;    24 
;    25 /*---------------------*/
;    26 /*  Start Rx/Tx UART0  */

        RSEG CODE:CODE:NOROOT(1)
;    27 void  Enb_UART0(void)       // Enable  Rx/Tx
;    28 {
;    29   UCSR0B = UCSR0B | (1<<TXEN0);  // TXEN0 = 1
; __nearfunc void Enb_UART0();
Enb_UART0:
	SBI	0x0A,0x03
;    30   UCSR0B = UCSR0B | (1<<RXEN0);  // RXEN0 = 1
	SBI	0x0A,0x04
;    31   UCSR0B = UCSR0B | (1<<RXCIE0); // RXCIE0= 1
	SBI	0x0A,0x07
;    32 }
	RET
;    33 /*-------------------*/
;    34 /*  Start Rx UART0  */

        RSEG CODE:CODE:NOROOT(1)
;    35 void  Enb_Rx_UART0(void)       // Enable  Rx
;    36 {
;    37   UCSR0B = UCSR0B | (1<<RXEN0);  // RXEN0 = 1
; __nearfunc void Enb_Rx_UART0();
Enb_Rx_UART0:
	SBI	0x0A,0x04
;    38   UCSR0B = UCSR0B | (1<<RXCIE0); // RXCIE0= 1
	SBI	0x0A,0x07
;    39 }
	RET
;    40 
;    41 /*-------------------*/
;    42 /*  Start Tx UART0  */

        RSEG CODE:CODE:NOROOT(1)
;    43 void  Enb_Tx_UART0(void)       // Enable  Tx
;    44 {
;    45   UCSR0B = UCSR0B | (1<<TXEN0);  // TXEN0 = 1
; __nearfunc void Enb_Tx_UART0();
Enb_Tx_UART0:
	SBI	0x0A,0x03
;    46 }
	RET
;    47 /*--------------------*/
;    48 /*  Stop Rx/Tx UART0  */

        RSEG CODE:CODE:NOROOT(1)
;    49 void  Dis_UART0(void)       // Disable  Rx/Tx
;    50 {
;    51   UCSR0B = UCSR0B & ~(1<<TXEN0);  // TXEN0 = 0
; __nearfunc void Dis_UART0();
Dis_UART0:
	CBI	0x0A,0x03
;    52   UCSR0B = UCSR0B & ~(1<<RXEN0);  // RXEN0 = 0
	CBI	0x0A,0x04
;    53   UCSR0B = UCSR0B & ~(1<<RXCIE0); // RXCIE0 = 0
	CBI	0x0A,0x07
;    54 }
	RET
;    55 
;    56 /*------------------*/
;    57 /*  Stop  Rx UART0  */

        RSEG CODE:CODE:NOROOT(1)
;    58 void  Dis_Rx_UART0(void)       // Disable  Rx
;    59 {
;    60   UCSR0B = UCSR0B & ~(1<<RXEN0);  // RXEN0 = 0
; __nearfunc void Dis_Rx_UART0();
Dis_Rx_UART0:
	CBI	0x0A,0x04
;    61   UCSR0B = UCSR0B & ~(1<<RXCIE0); // RXCIE0 = 0
	CBI	0x0A,0x07
;    62 }
	RET
;    63 
;    64 /*--------------------*/
;    65 /*  Stop   Tx UART0  */

        RSEG CODE:CODE:NOROOT(1)
;    66 void  Dis_Tx_UART0(void)       // Disable  Tx
;    67 {
;    68   UCSR0B = UCSR0B & ~(1<<TXEN0);  // TXEN0 = 0
; __nearfunc void Dis_Tx_UART0();
Dis_Tx_UART0:
	CBI	0x0A,0x03
;    69 }
	RET
;    70 
;    71 
;    72 /*--------------------------------*/
;    73 /*  Copy Sets Variable UART0 mode */

        RSEG CODE:CODE:NOROOT(1)
;    74 void  CopySetsROM_UART0(void)       // Sets is Default
;    75       {
;    76   SpeedBaud_UART0 = fSpeedBaud_UART0;
; __nearfunc void CopySetsROM_UART0();
CopySetsROM_UART0:
	LDI	R30,LOW(fSpeedBaud_UART0)
	LDI	R31,(fSpeedBaud_UART0) >> 8
	LPM	R16,Z+
	LPM	R17,Z
	SBIW	R31 : R30,1
	LDI	R30,LOW(SpeedBaud_UART0)
	LDI	R31,(SpeedBaud_UART0) >> 8
	ST	Z,R16
	STD	Z+1,R17
;    77   ModeU2X0 = fModeU2X0;
	LDI	R30,LOW(fModeU2X0)
	LDI	R31,(fModeU2X0) >> 8
	LPM	R16,Z
	STS	ModeU2X0,R16
;    78   ModeCHR90 = fModeCHR90;
	LDI	R30,LOW(fModeCHR90)
	LDI	R31,(fModeCHR90) >> 8
	LPM	R16,Z
	STS	ModeCHR90,R16
;    79   CheckParity_UART0 = fCheckParity_UART0;
	LDI	R30,LOW(fCheckParity_UART0)
	LDI	R31,(fCheckParity_UART0) >> 8
	LPM	R16,Z
	STS	CheckParity_UART0,R16
;    80   SizeBit_UART0 = fSizeBit_UART0;
	LDI	R30,LOW(fSizeBit_UART0)
	LDI	R31,(fSizeBit_UART0) >> 8
	LPM	R16,Z
	STS	SizeBit_UART0,R16
;    81   ContrStream_UART0 = fContrStream_UART0;
	LDI	R30,LOW(fContrStream_UART0)
	LDI	R31,(fContrStream_UART0) >> 8
	LPM	R16,Z
	STS	ContrStream_UART0,R16
;    82   Enb_DTR0 = fEnb_DTR0;
	LDI	R30,LOW(fEnb_DTR0)
	LDI	R31,(fEnb_DTR0) >> 8
	LPM	R16,Z
	STS	Enb_DTR0,R16
;    83   Bit_DTR0 = fBit_DTR0;
	LDI	R30,LOW(fBit_DTR0)
	LDI	R31,(fBit_DTR0) >> 8
	LPM	R16,Z
	STS	Bit_DTR0,R16
;    84   Enb_DSR0 = fEnb_DSR0;
	LDI	R30,LOW(fEnb_DSR0)
	LDI	R31,(fEnb_DSR0) >> 8
	LPM	R16,Z
	STS	Enb_DSR0,R16
;    85   Bit_DSR0 = fBit_DSR0;
	LDI	R30,LOW(fBit_DSR0)
	LDI	R31,(fBit_DSR0) >> 8
	LPM	R16,Z
	STS	Bit_DSR0,R16
;    86   Enb_RTS0 = fEnb_RTS0;
	LDI	R30,LOW(fEnb_RTS0)
	LDI	R31,(fEnb_RTS0) >> 8
	LPM	R16,Z
	STS	Enb_RTS0,R16
;    87   Bit_RTS0 = fBit_RTS0;
	LDI	R30,LOW(fBit_RTS0)
	LDI	R31,(fBit_RTS0) >> 8
	LPM	R16,Z
	STS	Bit_RTS0,R16
;    88   Enb_CTS0 = fEnb_CTS0;
	LDI	R30,LOW(fEnb_CTS0)
	LDI	R31,(fEnb_CTS0) >> 8
	LPM	R16,Z
	STS	Enb_CTS0,R16
;    89   Bit_CTS0 = fBit_CTS0;
	LDI	R30,LOW(fBit_CTS0)
	LDI	R31,(fBit_CTS0) >> 8
	LPM	R16,Z
	STS	Bit_CTS0,R16
;    90   Sym_XON = fSym_XON;
	LDI	R30,LOW(fSym_XON)
	LDI	R31,(fSym_XON) >> 8
	LPM	R16,Z
	STS	Sym_XON,R16
;    91   Sym_XOFF= fSym_XOFF;
	LDI	R30,LOW(fSym_XOFF)
	LDI	R31,(fSym_XOFF) >> 8
	LPM	R16,Z
	STS	Sym_XOFF,R16
;    92   Enb_XON_XOFF_Tx_UART0 = fEnb_XON_XOFF_Tx_UART0;
	LDI	R30,LOW(fEnb_XON_XOFF_Tx_UART0)
	LDI	R31,(fEnb_XON_XOFF_Tx_UART0) >> 8
	LPM	R16,Z
	STS	Enb_XON_XOFF_Tx_UART0,R16
;    93   Count_XOFF_Tx_UART0 = fCount_XOFF_Tx_UART0;
	LDI	R30,LOW(fCount_XOFF_Tx_UART0)
	LDI	R31,(fCount_XOFF_Tx_UART0) >> 8
	LPM	R16,Z
	STS	Count_XOFF_Tx_UART0,R16
;    94   Enb_XON_XOFF_Rx_UART0 = fEnb_XON_XOFF_Rx_UART0;
	LDI	R30,LOW(fEnb_XON_XOFF_Rx_UART0)
	LDI	R31,(fEnb_XON_XOFF_Rx_UART0) >> 8
	LPM	R16,Z
	STS	Enb_XON_XOFF_Rx_UART0,R16
;    95   Count_XOFF_Rx_UART0 = fCount_XOFF_Rx_UART0;
	LDI	R30,LOW(fCount_XOFF_Rx_UART0)
	LDI	R31,(fCount_XOFF_Rx_UART0) >> 8
	LPM	R16,Z
	STS	Count_XOFF_Rx_UART0,R16
;    96   Enb_Echo_UART0 = fEnb_Echo_UART0 ;
	LDI	R30,LOW(fEnb_Echo_UART0)
	LDI	R31,(fEnb_Echo_UART0) >> 8
	LPM	R16,Z
	STS	Enb_Echo_UART0,R16
;    97   ModeMPCM0 = fModeMPCM0;
	LDI	R30,LOW(fModeMPCM0)
	LDI	R31,(fModeMPCM0) >> 8
	LPM	R16,Z
	STS	ModeMPCM0,R16
;    98   Enb_Err_UART0 = fEnb_Err_UART0;
	LDI	R30,LOW(fEnb_Err_UART0)
	LDI	R31,(fEnb_Err_UART0) >> 8
	LPM	R16,Z
	STS	Enb_Err_UART0,R16
;    99   }
	RET
;   100 
;   101 /*--------------------------------*/
;   102 /*  Copy Sets Variable UART0 mode */

        RSEG CODE:CODE:NOROOT(1)
;   103 void  CopySetsEEPROM_UART0(void)    // Sets is Profile EEPROM
;   104       {}
; __nearfunc void CopySetsEEPROM_UART0();
CopySetsEEPROM_UART0:
	RET
;   105 
;   106 /*------------------*/
;   107 /*  Init UART0 mode */

        RSEG CODE:CODE:NOROOT(1)
;   108 void    Init_S_UART0  ( unsigned int SpeedBaund )  // speed  UART0
;   109         {
; __nearfunc void Init_S_UART0(unsigned int);
Init_S_UART0:
        FUNCALL Init_S_UART0, Dis_UART0
        LOCFRAME CSTACK, 9, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Init_S_UART0, Enb_UART0
        LOCFRAME CSTACK, 9, STACK
        LOCFRAME RSTACK, 2, STACK
	CALL	?PROLOGUE3_L09
	SBIW	R29 : R28,6
	MOVW	R25 : R24,R17 : R16
;   110     volatile char FlagErr;
;   111     volatile unsigned char cTmp;
;   112     volatile unsigned long lTmp;
;   113 
;   114     Dis_UART0();
	RCALL	Dis_UART0
;   115     FlagErr = 1; // Set Flag Error
	LDI	R16,1
	STD	Y+1,R16
;   116     cTmp = UCSR0A & 0x02; // Real bit mode U2X0 in reg UCSR0A
	IN	R16,0x0B
	ANDI	R16,0x02
	ST	Y,R16
;   117     switch (SpeedBaund)
	MOVW	R31 : R30,R25 : R24
	SUBI	R30,0
	SBCI	R31,150
	BREQ	??Init_S_UART0_0
	SUBI	R30,0
	SBCI	R31,75
	BREQ	??Init_S_UART0_0
	SUBI	R30,44
	SBCI	R31,32
	BREQ	??Init_S_UART0_0
	SUBI	R30,44
	SBCI	R31,1
	BREQ	??Init_S_UART0_0
	SUBI	R30,88
	SBCI	R31,2
	BREQ	??Init_S_UART0_0
	SUBI	R30,176
	SBCI	R31,4
	BREQ	??Init_S_UART0_0
	SUBI	R30,96
	SBCI	R31,9
	BREQ	??Init_S_UART0_0
	SUBI	R30,192
	SBCI	R31,18
	BREQ	??Init_S_UART0_0
	SUBI	R30,128
	SBCI	R31,37
	BREQ	??Init_S_UART0_1
	RJMP	??Init_S_UART0_2
;   118       {
;   119       case 300:
;   120       case 600:
;   121       case 1200:
;   122       case 2400:
;   123       case 4800:
;   124       case 9600:
;   125       case 19200:
;   126       case 38400:
;   127       case 57600:
;   128       if ( cTmp == 0)
??Init_S_UART0_1:
??Init_S_UART0_0:
	LD	R16,Y
	TST	R16
	BRNE	??Init_S_UART0_3
;   129         {   // calculate UBR for On Speed Mode
;   130          lTmp = (unsigned long)FQCK / 16 / (unsigned long)SpeedBaund - 1;
	LDI	R16,0
	LDI	R17,8
	LDI	R18,7
	LDI	R19,0
	MOVW	R21 : R20,R25 : R24
	LDI	R22,0
	LDI	R23,0
	CALL	?UL_DIVMOD_L03
	SUBI	R16,1
	SBCI	R17,0
	SBCI	R18,0
	SBCI	R19,0
	STD	Y+2,R16
	STD	Y+3,R17
	STD	Y+4,R18
	STD	Y+5,R19
;   131          UBRR0 =(unsigned char)lTmp;                  // low byte UBR
	LDD	R16,Y+2
	LDD	R17,Y+3
	LDD	R18,Y+4
	LDD	R19,Y+5
	OUT	0x09,R16
;   132          UBRH.uh0 = (unsigned char)(lTmp / 256);     // high byte UBR
	LDD	R16,Y+2
	LDD	R17,Y+3
	LDD	R18,Y+4
	LDD	R19,Y+5
	IN	R26,0x20
	ANDI	R26,0xF0
	LDI	R20,0
	LDI	R21,1
	LDI	R22,0
	LDI	R23,0
	CALL	?UL_DIVMOD_L03
	ANDI	R16,0x0F
	OR	R16,R26
	OUT	0x20,R16
	RJMP	??Init_S_UART0_4
;   133          }
;   134       else
;   135         {   // calculate UBR for Double Speed Mode
;   136          lTmp = (unsigned long)FQCK / 8 / (unsigned long)SpeedBaund - 1;
??Init_S_UART0_3:
	LDI	R16,0
	LDI	R17,16
	LDI	R18,14
	LDI	R19,0
	MOVW	R21 : R20,R25 : R24
	LDI	R22,0
	LDI	R23,0
	CALL	?UL_DIVMOD_L03
	SUBI	R16,1
	SBCI	R17,0
	SBCI	R18,0
	SBCI	R19,0
	STD	Y+2,R16
	STD	Y+3,R17
	STD	Y+4,R18
	STD	Y+5,R19
;   137          UBRR0 =(unsigned char)lTmp;                  // low byte UBR
	LDD	R16,Y+2
	LDD	R17,Y+3
	LDD	R18,Y+4
	LDD	R19,Y+5
	OUT	0x09,R16
;   138          UBRH.uh0 = (unsigned char)(lTmp / 256);     // high byte UBR
	LDD	R16,Y+2
	LDD	R17,Y+3
	LDD	R18,Y+4
	LDD	R19,Y+5
	IN	R26,0x20
	ANDI	R26,0xF0
	LDI	R20,0
	LDI	R21,1
	LDI	R22,0
	LDI	R23,0
	CALL	?UL_DIVMOD_L03
	ANDI	R16,0x0F
	OR	R16,R26
	OUT	0x20,R16
;   139          };
;   140       SpeedBaud_UART0 = SpeedBaund;
??Init_S_UART0_4:
	LDI	R30,LOW(SpeedBaud_UART0)
	LDI	R31,(SpeedBaud_UART0) >> 8
	ST	Z,R24
	STD	Z+1,R25
	RJMP	??Init_S_UART0_5
;   141       break;
;   142       default:
;   143         // if error speed store old speed
;   144         FlagErr = 0;
??Init_S_UART0_2:
	LDI	R16,0
	STD	Y+1,R16
;   145       break;
;   146       };
;   147     Enb_UART0();
??Init_S_UART0_5:
	RCALL	Enb_UART0
;   148     }
	ADIW	R29 : R28,6
	LDI	R30,3
	JMP	?EPILOGUE_B3_L09
;   149 

        RSEG CODE:CODE:NOROOT(1)
;   150 void    Init_2S_UART0 ( unsigned char ModeU2X0 )        // baud*2 UART0
;   151         {
; __nearfunc void Init_2S_UART0(unsigned char);
Init_2S_UART0:
        FUNCALL Init_2S_UART0, Dis_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Init_2S_UART0, Init_S_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Init_2S_UART0, Init_S_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Init_2S_UART0, Enb_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R24
	MOV	R24,R16
;   152         Dis_UART0();
	RCALL	Dis_UART0
;   153         if ( ModeU2X0 == 0)          // if ModeU2X0=0 then U2X0=0
	TST	R24
	BRNE	??Init_2S_UART0_0
;   154           {                          // else U2X0=1
;   155           UCSR0A = UCSR0A & ~(0x02);
	CBI	0x0B,0x01
;   156           Init_S_UART0(SpeedBaud_UART0); // UART0 is 1*SpeedBaund
	LDI	R30,LOW(SpeedBaud_UART0)
	LDI	R31,(SpeedBaud_UART0) >> 8
	LD	R16,Z
	LDD	R17,Z+1
	RCALL	Init_S_UART0
	RJMP	??Init_2S_UART0_1
;   157           }
;   158         else
;   159           {
;   160           UCSR0A = UCSR0A & ~(0x02);
??Init_2S_UART0_0:
	CBI	0x0B,0x01
;   161           Init_S_UART0(SpeedBaud_UART0);
	LDI	R30,LOW(SpeedBaud_UART0)
	LDI	R31,(SpeedBaud_UART0) >> 8
	LD	R16,Z
	LDD	R17,Z+1
	RCALL	Init_S_UART0
;   162           UCSR0A = UCSR0A | (0x02); // UART0 is 2*SpeedBaund
	SBI	0x0B,0x01
;   163           };
;   164         Enb_UART0();
??Init_2S_UART0_1:
	RCALL	Enb_UART0
;   165         }
	LD	R24,Y+
	RET

        RSEG CODE:CODE:NOROOT(1)
;   166 void    Init_P_UART0  ( unsigned char Parity ) // control parity
;   167         {
; __nearfunc void Init_P_UART0(unsigned char);
Init_P_UART0:
        FUNCALL Init_P_UART0, Dis_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Init_P_UART0, Init_CHR9_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Init_P_UART0, Init_CHR9_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Init_P_UART0, Init_CHR9_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Init_P_UART0, Init_CHR9_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Init_P_UART0, Init_CHR9_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Init_P_UART0, Enb_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R24
	MOV	R24,R16
;   168         Dis_UART0();
	RCALL	Dis_UART0
;   169         switch ( Parity )
	MOV	R16,R24
	SUBI	R16,0
	BREQ	??Init_P_UART0_0
	SUBI	R16,1
	BRCS	??Init_P_UART0_1
	SUBI	R16,4
	BRCS	??Init_P_UART0_2
	RJMP	??Init_P_UART0_1
;   170           {
;   171           case 0:
;   172           Init_CHR9_UART0(0); // Mode 8 bits
??Init_P_UART0_0:
	LDI	R16,0
	RCALL	Init_CHR9_UART0
;   173           CheckParity_UART0 = Parity;
	STS	CheckParity_UART0,R24
	RJMP	??Init_P_UART0_3
;   174           break;
;   175           case 1:
;   176           case 2:
;   177           case 3:
;   178           case 4:
;   179           CheckParity_UART0 = Parity;
??Init_P_UART0_2:
	STS	CheckParity_UART0,R24
;   180               switch ( SizeBit_UART0 )
	LDS	R16,SizeBit_UART0
	SUBI	R16,0
	BREQ	??Init_P_UART0_4
	DEC	R16
	BREQ	??Init_P_UART0_5
	RJMP	??Init_P_UART0_6
;   181                     {
;   182                     case 0:
;   183                     Init_CHR9_UART0(0); // Mode 8 bits
??Init_P_UART0_4:
	LDI	R16,0
	RCALL	Init_CHR9_UART0
;   184                     case 1:
;   185                     Init_CHR9_UART0(1); // Mode 9 bits
??Init_P_UART0_5:
	LDI	R16,1
	RCALL	Init_CHR9_UART0
	RJMP	??Init_P_UART0_3
;   186                     break;
;   187                     default:
;   188                     Init_CHR9_UART0(0); // Mode 8 bits
??Init_P_UART0_6:
	LDI	R16,0
	RCALL	Init_CHR9_UART0
	RJMP	??Init_P_UART0_3
;   189                     break;
;   190                     };
;   191           break;
;   192           default:
;   193           CheckParity_UART0 = 0;
??Init_P_UART0_1:
	LDI	R16,0
	STS	CheckParity_UART0,R16
;   194           Init_CHR9_UART0(0); // Mode 8 bits
	LDI	R16,0
	RCALL	Init_CHR9_UART0
;   195           break;
;   196           };
;   197         Enb_UART0();
??Init_P_UART0_3:
	RCALL	Enb_UART0
;   198         }
	LD	R24,Y+
	RET
;   199 

        RSEG CODE:CODE:NOROOT(1)
;   200 void    Init_B_UART0  ( unsigned char SizeBit )
;   201         {
; __nearfunc void Init_B_UART0(unsigned char);
Init_B_UART0:
        FUNCALL Init_B_UART0, Dis_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Init_B_UART0, Enb_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R24
	MOV	R24,R16
;   202         Dis_UART0();
	RCALL	Dis_UART0
;   203         switch ( SizeBit )
	MOV	R16,R24
	SUBI	R16,0
	BREQ	??Init_B_UART0_0
	DEC	R16
	BRNE	??Init_B_UART0_1
;   204           {
;   205           case 0:
;   206           case 1:
;   207           SizeBit_UART0 = SizeBit;
??Init_B_UART0_0:
	STS	SizeBit_UART0,R24
	RJMP	??Init_B_UART0_2
;   208           break;
;   209           default:
;   210           SizeBit_UART0 = 1;    // SizeBit 8 bits
??Init_B_UART0_1:
	LDI	R16,1
	STS	SizeBit_UART0,R16
;   211           break;
;   212           };
;   213         Enb_UART0();
??Init_B_UART0_2:
	RCALL	Enb_UART0
;   214         }
	LD	R24,Y+
	RET
;   215 

        RSEG CODE:CODE:NOROOT(1)
;   216 void    Init_CHR9_UART0 ( unsigned char Mode )     // Rx/Tx 8 or 9 bits
;   217         {
;   218         switch ( Mode)
; __nearfunc void Init_CHR9_UART0(unsigned char);
Init_CHR9_UART0:
	MOV	R17,R16
	SUBI	R17,0
	BREQ	??Init_CHR9_UART0_0
	DEC	R17
	BREQ	??Init_CHR9_UART0_1
	RJMP	??Init_CHR9_UART0_2
;   219           {
;   220           case 0:
;   221             UCSR0B = UCSR0B & ~(0x04); // Mode 8 bit Rx/Tx
??Init_CHR9_UART0_0:
	CBI	0x0A,0x02
;   222             UCSR0B = UCSR0B & ~(0x01); // Set 9 bit = 0
	CBI	0x0A,0x00
;   223             ModeCHR90 = Mode;
	STS	ModeCHR90,R16
	RET
;   224           break;
;   225           case 1:
;   226             UCSR0B = UCSR0B | (0x04); // Mode 9 bit Rx/Tx
??Init_CHR9_UART0_1:
	SBI	0x0A,0x02
;   227             UCSR0B = UCSR0B | (0x01);  // Set 9 bit = 1
	SBI	0x0A,0x00
;   228             ModeCHR90 = Mode;
	STS	ModeCHR90,R16
	RET
;   229           break;
;   230           default:
;   231             UCSR0B = UCSR0B & ~(0x04); // Mode 8 bit Rx/Tx
??Init_CHR9_UART0_2:
	CBI	0x0A,0x02
;   232             UCSR0B = UCSR0B & ~(0x01); // Set 9 bit = 0
	CBI	0x0A,0x00
;   233             ModeCHR90 = 0;
	LDI	R16,0
	STS	ModeCHR90,R16
;   234           break;
;   235           };
;   236         }
	RET
;   237 

        RSEG CODE:CODE:NOROOT(1)
;   238 void    Init_MPCM_UART0 ( unsigned char ModeMPCM0 )     // Mode Multi-processor Com port
;   239         {
; __nearfunc void Init_MPCM_UART0(unsigned char);
Init_MPCM_UART0:
        FUNCALL Init_MPCM_UART0, Dis_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Init_MPCM_UART0, Enb_UART0
        LOCFRAME CSTACK, 1, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R24
	MOV	R24,R16
;   240         Dis_UART0();
	RCALL	Dis_UART0
;   241         if ( ModeMPCM0 == 0)
	TST	R24
	BRNE	??Init_MPCM_UART0_0
;   242         {
;   243        UCSR0A = UCSR0A & ~(0x01); // Mode MPCM0 for Rx/Tx
	CBI	0x0B,0x00
	RJMP	??Init_MPCM_UART0_1
;   244         }
;   245         else
;   246         {
;   247        UCSR0A = UCSR0A | (0x01); // Mode MPCM0 for Rx/Tx
??Init_MPCM_UART0_0:
	SBI	0x0B,0x00
;   248         };
;   249         Enb_UART0();
??Init_MPCM_UART0_1:
	RCALL	Enb_UART0
;   250         }
	LD	R24,Y+
	RET
;   251 
;   252 /*------------------------------------------*/
;   253 /*               Reset UART                 */

        RSEG CODE:CODE:NOROOT(1)
;   254 void  Reset_UART0 ( void )   // Reset UART0 Status A1x.y0
;   255       {
; __nearfunc void Reset_UART0();
Reset_UART0:
        FUNCALL Reset_UART0, CopySetsEEPROM_UART0
        LOCFRAME CSTACK, 5, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Reset_UART0, CopySetsROM_UART0
        LOCFRAME CSTACK, 5, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Reset_UART0, Init_S_UART0
        LOCFRAME CSTACK, 5, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R25
	ST	-Y,R24
	SBIW	R29 : R28,3
;   256     volatile unsigned char cTmp;
;   257     volatile int i;
;   258     /* Sets out pins   DTR0=1, RTS0=1 */
;   259     cTmp = DDRC ^ ( 1+4 );   // Mode Pins to Out
	IN	R17,0x14
	LDI	R16,5
	EOR	R16,R17
	STD	Y+2,R16
;   260     DDRC = cTmp;
	LDD	R16,Y+2
	OUT	0x14,R16
;   261     cTmp = PORTC ^ ( 1+4 ); // Pins Out bits
	IN	R17,0x15
	LDI	R16,5
	EOR	R16,R17
	STD	Y+2,R16
;   262     PORTC = cTmp ;
	LDD	R16,Y+2
	OUT	0x15,R16
;   263     /* Programm state SYSTEM RESET */
;   264     UCSR0B=0x02;              // Disable UART0 Rx/Tx
	LDI	R16,2
	OUT	0x0A,R16
;   265     cTmp = UDR0;              // Clear ERROR Resiverd
	IN	R16,0x0C
	STD	Y+2,R16
;   266     UCSR0A=0x20;              // Erase Errors
	LDI	R16,32
	OUT	0x0B,R16
;   267     UBRH.uh0=0x00;
	IN	R16,0x20
	ANDI	R16,0xF0
	OUT	0x20,R16
;   268     UBRR0=0x0;
	LDI	R16,0
	OUT	0x09,R16
;   269     /* Erase all variables  */
;   270     /* Erase Buffer Tx */
;   271     for (i=1;i<=TX_BUFFER_SIZE_UART0;i++)
	LDI	R16,1
	LDI	R17,0
	ST	Y,R16
	STD	Y+1,R17
	RJMP	??Reset_UART0_0
;   272       {
;   273       TxBuf_UART0[i] = 0;         // Buffer Tx Erase
??Reset_UART0_1:
	LDI	R16,0
	LD	R18,Y
	LDD	R19,Y+1
	MOVW	R31 : R30,R19 : R18
	SUBI	R30,LOW((-(TxBuf_UART0) & 0xFFFF))
	SBCI	R31,(-(TxBuf_UART0) & 0xFFFF) >> 8
	ST	Z,R16
	LD	R16,Y
	LDD	R17,Y+1
	SUBI	R16,255
	SBCI	R17,255
	ST	Y,R16
	STD	Y+1,R17
??Reset_UART0_0:
	LD	R24,Y
	LDD	R25,Y+1
	CPI	R24,33
	SBCI	R25,0
	BRLT	??Reset_UART0_1
;   274       };
;   275     TxHead_UART0 = 0;             // Head Top
	LDI	R16,0
	STS	TxHead_UART0,R16
;   276     TxTail_UART0 = 0;             // Tail Top
	LDI	R16,0
	STS	TxTail_UART0,R16
;   277     /* Erase Buffer Rx */
;   278     for (i=1;i<=RX_BUFFER_SIZE_UART0;i++)
	LDI	R16,1
	LDI	R17,0
	ST	Y,R16
	STD	Y+1,R17
	RJMP	??Reset_UART0_2
;   279       {
;   280       RxBuf_UART0[i] = 0;         // Buffer Rx Erase
??Reset_UART0_3:
	LDI	R16,0
	LD	R18,Y
	LDD	R19,Y+1
	MOVW	R31 : R30,R19 : R18
	SUBI	R30,LOW((-(RxBuf_UART0) & 0xFFFF))
	SBCI	R31,(-(RxBuf_UART0) & 0xFFFF) >> 8
	ST	Z,R16
	LD	R16,Y
	LDD	R17,Y+1
	SUBI	R16,255
	SBCI	R17,255
	ST	Y,R16
	STD	Y+1,R17
??Reset_UART0_2:
	LD	R24,Y
	LDD	R25,Y+1
	CPI	R24,33
	SBCI	R25,0
	BRLT	??Reset_UART0_3
;   281       };
;   282     RxHead_UART0 = 0;             // Head Top
	LDI	R16,0
	STS	RxHead_UART0,R16
;   283     RxTail_UART0 = 0;             // Tail Top
	LDI	R16,0
	STS	RxTail_UART0,R16
;   284     /* Erase Array Errors Rx/Tx */
;   285     for (i=1;i<=Rx_Tx_Err_SIZE_UART0;i++)
	LDI	R16,1
	LDI	R17,0
	ST	Y,R16
	STD	Y+1,R17
	RJMP	??Reset_UART0_4
;   286       {
;   287       Rx_Tx_Err_UART0[i] = 0;         // Array Rx_Tx_Err Erase
??Reset_UART0_5:
	LDI	R24,0
	LDI	R25,0
	LD	R16,Y
	LDD	R17,Y+1
	LDI	R20,2
	LDI	R21,0
	CALL	?S_MUL_L02
	MOVW	R31 : R30,R17 : R16
	SUBI	R30,LOW((-(Rx_Tx_Err_UART0) & 0xFFFF))
	SBCI	R31,(-(Rx_Tx_Err_UART0) & 0xFFFF) >> 8
	ST	Z,R24
	STD	Z+1,R25
	LD	R16,Y
	LDD	R17,Y+1
	SUBI	R16,255
	SBCI	R17,255
	ST	Y,R16
	STD	Y+1,R17
??Reset_UART0_4:
	LD	R24,Y
	LDD	R25,Y+1
	CPI	R24,6
	SBCI	R25,0
	BRLT	??Reset_UART0_5
;   288       };
;   289     /* Erase variables */
;   290     Count_Rx_UART0 = 0;
	LDI	R16,0
	LDI	R17,0
	LDI	R18,0
	LDI	R19,0
	LDI	R30,LOW(Count_Rx_UART0)
	LDI	R31,(Count_Rx_UART0) >> 8
	ST	Z,R16
	STD	Z+1,R17
	STD	Z+2,R18
	STD	Z+3,R19
;   291     Count_Tx_UART0 = 0;
	LDI	R16,0
	LDI	R17,0
	LDI	R18,0
	LDI	R19,0
	LDI	R30,LOW(Count_Tx_UART0)
	LDI	R31,(Count_Tx_UART0) >> 8
	ST	Z,R16
	STD	Z+1,R17
	STD	Z+2,R18
	STD	Z+3,R19
;   292     Count_Rx_Err_UART0 = 0;
	LDI	R16,0
	LDI	R17,0
	LDI	R18,0
	LDI	R19,0
	LDI	R30,LOW(Count_Rx_Err_UART0)
	LDI	R31,(Count_Rx_Err_UART0) >> 8
	ST	Z,R16
	STD	Z+1,R17
	STD	Z+2,R18
	STD	Z+3,R19
;   293     Count_Tx_Err_UART0 = 0;
	LDI	R16,0
	LDI	R17,0
	LDI	R18,0
	LDI	R19,0
	LDI	R30,LOW(Count_Tx_Err_UART0)
	LDI	R31,(Count_Tx_Err_UART0) >> 8
	ST	Z,R16
	STD	Z+1,R17
	STD	Z+2,R18
	STD	Z+3,R19
;   294     /*  */
;   295     SpeedBaud_UART0 = 0;
	LDI	R16,0
	LDI	R17,0
	LDI	R30,LOW(SpeedBaud_UART0)
	LDI	R31,(SpeedBaud_UART0) >> 8
	ST	Z,R16
	STD	Z+1,R17
;   296     ModeU2X0 = 0;
	LDI	R16,0
	STS	ModeU2X0,R16
;   297     ModeCHR90 = 0;
	LDI	R16,0
	STS	ModeCHR90,R16
;   298     CheckParity_UART0 = 0;
	LDI	R16,0
	STS	CheckParity_UART0,R16
;   299     SizeBit_UART0 = 1;
	LDI	R16,1
	STS	SizeBit_UART0,R16
;   300     ContrStream_UART0 = 0;
	LDI	R16,0
	STS	ContrStream_UART0,R16
;   301     Enb_DTR0 = 0;
	LDI	R16,0
	STS	Enb_DTR0,R16
;   302     Bit_DTR0 = 1;
	LDI	R16,1
	STS	Bit_DTR0,R16
;   303     Enb_DSR0 = 0;
	LDI	R16,0
	STS	Enb_DSR0,R16
;   304     Bit_DSR0 = 1;
	LDI	R16,1
	STS	Bit_DSR0,R16
;   305     Enb_RTS0 = 0;
	LDI	R16,0
	STS	Enb_RTS0,R16
;   306     Bit_RTS0 = 1;
	LDI	R16,1
	STS	Bit_RTS0,R16
;   307     Enb_CTS0 = 0;
	LDI	R16,0
	STS	Enb_CTS0,R16
;   308     Bit_CTS0 = 1;
	LDI	R16,1
	STS	Bit_CTS0,R16
;   309     Enb_XON_XOFF_Tx_UART0 = 0;
	LDI	R16,0
	STS	Enb_XON_XOFF_Tx_UART0,R16
;   310     Count_XOFF_Tx_UART0 = 0;
	LDI	R16,0
	STS	Count_XOFF_Tx_UART0,R16
;   311     Enb_XON_XOFF_Rx_UART0 = 0;
	LDI	R16,0
	STS	Enb_XON_XOFF_Rx_UART0,R16
;   312     Count_XOFF_Rx_UART0 = 0;
	LDI	R16,0
	STS	Count_XOFF_Rx_UART0,R16
;   313     Enb_Echo_UART0 = 0;
	LDI	R16,0
	STS	Enb_Echo_UART0,R16
;   314     ModeMPCM0 =0;
	LDI	R16,0
	STS	ModeMPCM0,R16
;   315     /********************/
;   316     /* New status A1x.y */
;   317     A1x_y = 0;      //  y0 for UART0
	LDI	R16,0
	STS	A1x_y,R16
;   318     /*----------------*/
;   319     /* ? status A2x ? */
;   320     switch( A2x_y)
	LDS	R16,A2x_y
	DEC	R16
	BREQ	??Reset_UART0_6
	DEC	R16
	BREQ	??Reset_UART0_7
	RJMP	??Reset_UART0_8
;   321     {
;   322       case 1: // if A2x_y == y1 Copy sets from EEPROM
;   323       CopySetsEEPROM_UART0();
??Reset_UART0_6:
	RCALL	CopySetsEEPROM_UART0
	RJMP	??Reset_UART0_8
;   324       break;
;   325       case 2: // if A2x_y == y2 Copy sets from ROM
;   326       CopySetsROM_UART0();
??Reset_UART0_7:
	RCALL	CopySetsROM_UART0
;   327       break;
;   328       default:
;   329        ;  // Error! "No status A2x"
;   330       break;
;   331       };
;   332     /********************/
;   333     /* New status A1x.y */
;   334     A1x_y = 1;      //  y1 for UART0
??Reset_UART0_8:
	LDI	R16,1
	STS	A1x_y,R16
;   335     /*- ----------------*/
;   336     /* Calculator BAUD  */
;   337     Init_S_UART0(SpeedBaud_UART0);
	LDI	R30,LOW(SpeedBaud_UART0)
	LDI	R31,(SpeedBaud_UART0) >> 8
	LD	R16,Z
	LDD	R17,Z+1
	RCALL	Init_S_UART0
;   338 
;   339     /*--------------------*/
;   340     /* Enable Rx/Tx UART0 */
;   341 
;   342     // ?? DTR0,RTS0 and enable
;   343 
;   344     /********************/
;   345     /* New status A1x.y */
;   346     A1x_y = 2;      //  y2 for UART0
	LDI	R16,2
	STS	A1x_y,R16
;   347 
;   348     /*--------------------*/
;   349     /* Enable Rx/Tx UART0 */
;   350     /********************/
;   351     /* New status A1x.y */
;   352     A1x_y = 3;      //  y3 for UART0
	LDI	R16,3
	STS	A1x_y,R16
;   353 
;   354     }
	ADIW	R29 : R28,3
	LD	R24,Y+
	LD	R25,Y+
	RET
;   355 
;   356 /*-------------------------------------------*/
;   357 /* "Enable_Err_Count_UART0" Enable counter   */
;   358 /*         errors for Tx_Rx  UART            */

        RSEG CODE:CODE:NOROOT(1)
;   359 void   Enable_Err_Count_UART0 ( void )    // Enb_Err_UART0 = 1
;   360     {
; __nearfunc void Enable_Err_Count_UART0();
Enable_Err_Count_UART0:
        FUNCALL Enable_Err_Count_UART0, Dis_UART0
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Enable_Err_Count_UART0, Enb_UART0
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
	CALL	?PROLOGUE4_L09
;   361     unsigned int i;
;   362     Dis_UART0();
	RCALL	Dis_UART0
;   363     /* Erase Array Errors Rx/Tx */
;   364     for (i=1;i<=Rx_Tx_Err_SIZE_UART0;i++)
	LDI	R24,1
	LDI	R25,0
	RJMP	??Enable_Err_Count_UART0_0
;   365       {
;   366       Rx_Tx_Err_UART0[i] = 0;         // Array Rx_Tx_Err Erase
??Enable_Err_Count_UART0_1:
	LDI	R26,0
	LDI	R27,0
	MOVW	R17 : R16,R25 : R24
	LDI	R20,2
	LDI	R21,0
	CALL	?S_MUL_L02
	MOVW	R31 : R30,R17 : R16
	SUBI	R30,LOW((-(Rx_Tx_Err_UART0) & 0xFFFF))
	SBCI	R31,(-(Rx_Tx_Err_UART0) & 0xFFFF) >> 8
	ST	Z,R26
	STD	Z+1,R27
	ADIW	R25 : R24,1
??Enable_Err_Count_UART0_0:
	CPI	R24,6
	LDI	R16,0
	CPC	R25,R16
	BRCS	??Enable_Err_Count_UART0_1
;   367       };
;   368     /* Erase variables */
;   369     Count_Rx_UART0 = 0;
	LDI	R16,0
	LDI	R17,0
	LDI	R18,0
	LDI	R19,0
	LDI	R30,LOW(Count_Rx_UART0)
	LDI	R31,(Count_Rx_UART0) >> 8
	ST	Z,R16
	STD	Z+1,R17
	STD	Z+2,R18
	STD	Z+3,R19
;   370     Count_Tx_UART0 = 0;
	LDI	R16,0
	LDI	R17,0
	LDI	R18,0
	LDI	R19,0
	LDI	R30,LOW(Count_Tx_UART0)
	LDI	R31,(Count_Tx_UART0) >> 8
	ST	Z,R16
	STD	Z+1,R17
	STD	Z+2,R18
	STD	Z+3,R19
;   371     Count_Rx_Err_UART0 = 0;
	LDI	R16,0
	LDI	R17,0
	LDI	R18,0
	LDI	R19,0
	LDI	R30,LOW(Count_Rx_Err_UART0)
	LDI	R31,(Count_Rx_Err_UART0) >> 8
	ST	Z,R16
	STD	Z+1,R17
	STD	Z+2,R18
	STD	Z+3,R19
;   372     Count_Tx_Err_UART0 = 0;
	LDI	R16,0
	LDI	R17,0
	LDI	R18,0
	LDI	R19,0
	LDI	R30,LOW(Count_Tx_Err_UART0)
	LDI	R31,(Count_Tx_Err_UART0) >> 8
	ST	Z,R16
	STD	Z+1,R17
	STD	Z+2,R18
	STD	Z+3,R19
;   373     /*  */
;   374     Enb_Err_UART0 = 1;
	LDI	R16,1
	STS	Enb_Err_UART0,R16
;   375     Enb_UART0();
	RCALL	Enb_UART0
;   376     }
	LDI	R30,4
	JMP	?EPILOGUE_B4_L09
;   377 
;   378 /*---------------------------------------------*/
;   379 /* "Disable_Err_Count_UART0" Disable counter   */
;   380 /*        errors for Tx_Rx  UART               */

        RSEG CODE:CODE:NOROOT(1)
;   381 void   Disable_Err_Count_UART0 ( void )   // End_Err_UART0 = 0
;   382     {
;   383     Enb_Err_UART0 = 0;
; __nearfunc void Disable_Err_Count_UART0();
Disable_Err_Count_UART0:
	LDI	R16,0
	STS	Enb_Err_UART0,R16
;   384      }
	RET
;   385 
;   386 /*-------------------------------*/
;   387 /* Read Arry Tx_Rx_Err for UART  */

        RSEG CODE:CODE:NOROOT(1)
;   388 int    Read_Tx_Rx_Err_UART0 ( void )    // Type strings table Error
;   389      {
; __nearfunc int Read_Tx_Rx_Err_UART0();
Read_Tx_Rx_Err_UART0:
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 8, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 8, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 8, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 8, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 10, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 10, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL Read_Tx_Rx_Err_UART0, printf
        LOCFRAME CSTACK, 6, STACK
        LOCFRAME RSTACK, 2, STACK
	CALL	?PROLOGUE4_L09
	SBIW	R29 : R28,2
;   390 static volatile unsigned int Arr_Tmp[Rx_Tx_Err_SIZE_UART0];
;   391 unsigned int i;
;   392 volatile unsigned int iT;
;   393 
;   394     /* Rear for Arr Errors */
;   395     for (i=1;i<=Rx_Tx_Err_SIZE_UART0;i++)
	LDI	R24,1
	LDI	R25,0
	RJMP	??Read_Tx_Rx_Err_UART0_0
;   396       {
;   397       Arr_Tmp[i] = Rx_Tx_Err_UART0[i];
??Read_Tx_Rx_Err_UART0_1:
	MOVW	R17 : R16,R25 : R24
	LDI	R20,2
	LDI	R21,0
	CALL	?S_MUL_L02
	MOVW	R31 : R30,R17 : R16
	SUBI	R30,LOW((-(Rx_Tx_Err_UART0) & 0xFFFF))
	SBCI	R31,(-(Rx_Tx_Err_UART0) & 0xFFFF) >> 8
	LD	R26,Z
	LDD	R27,Z+1
	MOVW	R17 : R16,R25 : R24
	LDI	R20,2
	LDI	R21,0
	CALL	?S_MUL_L02
	MOVW	R31 : R30,R17 : R16
	SUBI	R30,LOW((-(??Arr_Tmp) & 0xFFFF))
	SBCI	R31,(-(??Arr_Tmp) & 0xFFFF) >> 8
	ST	Z,R26
	STD	Z+1,R27
	ADIW	R25 : R24,1
??Read_Tx_Rx_Err_UART0_0:
	CPI	R24,6
	LDI	R16,0
	CPC	R25,R16
	BRCS	??Read_Tx_Rx_Err_UART0_1
;   398       };
;   399     iT = printf(" \n\r");
	LDI	R16,LOW(`?<Constant " \\n\\r">`)
	LDI	R17,(`?<Constant " \\n\\r">`) >> 8
	CALL	printf
	ST	Y,R16
	STD	Y+1,R17
;   400     iT = printf("Table Errors Rx/Tx:");
	LDI	R16,LOW(`?<Constant "Table Errors Rx/Tx:">`)
	LDI	R17,(`?<Constant "Table Errors Rx/Tx:">`) >> 8
	CALL	printf
	ST	Y,R16
	STD	Y+1,R17
;   401     iT = printf("  ");
	LDI	R16,LOW(`?<Constant "  ">`)
	LDI	R17,(`?<Constant "  ">`) >> 8
	CALL	printf
	ST	Y,R16
	STD	Y+1,R17
;   402     iT = printf("%d", Arr_Tmp[1]);
	LDI	R30,LOW(??Arr_Tmp)
	LDI	R31,(??Arr_Tmp) >> 8
	LDD	R16,Z+2
	LDD	R17,Z+3
	ST	-Y,R17
	ST	-Y,R16
	LDI	R16,LOW(`?<Constant "%d">`)
	LDI	R17,(`?<Constant "%d">`) >> 8
	CALL	printf
	ADIW	R29 : R28,2
	ST	Y,R16
	STD	Y+1,R17
;   403     iT = printf("  ");
	LDI	R16,LOW(`?<Constant "  ">`)
	LDI	R17,(`?<Constant "  ">`) >> 8
	CALL	printf
	ST	Y,R16
	STD	Y+1,R17
;   404     iT = printf("%d", Arr_Tmp[2]);
	LDI	R30,LOW(??Arr_Tmp)
	LDI	R31,(??Arr_Tmp) >> 8
	LDD	R16,Z+4
	LDD	R17,Z+5
	ST	-Y,R17
	ST	-Y,R16
	LDI	R16,LOW(`?<Constant "%d">`)
	LDI	R17,(`?<Constant "%d">`) >> 8
	CALL	printf
	ADIW	R29 : R28,2
	ST	Y,R16
	STD	Y+1,R17
;   405     iT = printf("  ");
	LDI	R16,LOW(`?<Constant "  ">`)
	LDI	R17,(`?<Constant "  ">`) >> 8
	CALL	printf
	ST	Y,R16
	STD	Y+1,R17
;   406     iT = printf("%d", Arr_Tmp[3]);
	LDI	R30,LOW(??Arr_Tmp)
	LDI	R31,(??Arr_Tmp) >> 8
	LDD	R16,Z+6
	LDD	R17,Z+7
	ST	-Y,R17
	ST	-Y,R16
	LDI	R16,LOW(`?<Constant "%d">`)
	LDI	R17,(`?<Constant "%d">`) >> 8
	CALL	printf
	ADIW	R29 : R28,2
	ST	Y,R16
	STD	Y+1,R17
;   407     iT = printf("  ");
	LDI	R16,LOW(`?<Constant "  ">`)
	LDI	R17,(`?<Constant "  ">`) >> 8
	CALL	printf
	ST	Y,R16
	STD	Y+1,R17
;   408     iT = printf("%d", Arr_Tmp[4]);
	LDI	R30,LOW(??Arr_Tmp)
	LDI	R31,(??Arr_Tmp) >> 8
	LDD	R16,Z+8
	LDD	R17,Z+9
	ST	-Y,R17
	ST	-Y,R16
	LDI	R16,LOW(`?<Constant "%d">`)
	LDI	R17,(`?<Constant "%d">`) >> 8
	CALL	printf
	ADIW	R29 : R28,2
	ST	Y,R16
	STD	Y+1,R17
;   409     iT = printf(" \n\r");
	LDI	R16,LOW(`?<Constant " \\n\\r">`)
	LDI	R17,(`?<Constant " \\n\\r">`) >> 8
	CALL	printf
	ST	Y,R16
	STD	Y+1,R17
;   410     iT = printf("Table Counters  Rx:");
	LDI	R16,LOW(`?<Constant "Table Counters  Rx:">`)
	LDI	R17,(`?<Constant "Table Counters  Rx:">`) >> 8
	CALL	printf
	ST	Y,R16
	STD	Y+1,R17
;   411     iT = printf("  ");
	LDI	R16,LOW(`?<Constant "  ">`)
	LDI	R17,(`?<Constant "  ">`) >> 8
	CALL	printf
	ST	Y,R16
	STD	Y+1,R17
;   412     iT = printf("%ld", Count_Rx_UART0);
	LDI	R30,LOW(Count_Rx_UART0)
	LDI	R31,(Count_Rx_UART0) >> 8
	LD	R16,Z
	LDD	R17,Z+1
	LDD	R18,Z+2
	LDD	R19,Z+3
	ST	-Y,R19
	ST	-Y,R18
	ST	-Y,R17
	ST	-Y,R16
	LDI	R16,LOW(`?<Constant "%ld">`)
	LDI	R17,(`?<Constant "%ld">`) >> 8
	CALL	printf
	ADIW	R29 : R28,4
	ST	Y,R16
	STD	Y+1,R17
;   413     iT = printf("  ");
	LDI	R16,LOW(`?<Constant "  ">`)
	LDI	R17,(`?<Constant "  ">`) >> 8
	CALL	printf
	ST	Y,R16
	STD	Y+1,R17
;   414     iT = printf("%ld", Count_Rx_Err_UART0);
	LDI	R30,LOW(Count_Rx_Err_UART0)
	LDI	R31,(Count_Rx_Err_UART0) >> 8
	LD	R16,Z
	LDD	R17,Z+1
	LDD	R18,Z+2
	LDD	R19,Z+3
	ST	-Y,R19
	ST	-Y,R18
	ST	-Y,R17
	ST	-Y,R16
	LDI	R16,LOW(`?<Constant "%ld">`)
	LDI	R17,(`?<Constant "%ld">`) >> 8
	CALL	printf
	ADIW	R29 : R28,4
	ST	Y,R16
	STD	Y+1,R17
;   415     iT = printf(" \n\r");
	LDI	R16,LOW(`?<Constant " \\n\\r">`)
	LDI	R17,(`?<Constant " \\n\\r">`) >> 8
	CALL	printf
	ST	Y,R16
	STD	Y+1,R17
;   416     return 0;                          // if int = -1 ERROR
	LDI	R16,0
	LDI	R17,0
	ADIW	R29 : R28,2
	LDI	R30,4
	JMP	?EPILOGUE_B4_L09
;   417      }

        RSEG NEAR_Z:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_Z>`
; unsigned int volatile __near Arr_Tmp[5];
??Arr_Tmp:
	DS 10
;   418 
;   419 /*-----------------------------*/
;   420 /*  Control stream  UART0 mode */

        RSEG CODE:CODE:NOROOT(1)
;   421 void   ControlStream_ON_UART0( void )
;   422 {
;   423     ContrStream_UART0 = 1;
; __nearfunc void ControlStream_ON_UART0();
ControlStream_ON_UART0:
	LDI	R16,1
	STS	ContrStream_UART0,R16
;   424 }
	RET
;   425 
;   426 /*-----------------------------*/
;   427 /*  Control stream  UART0 mode */

        RSEG CODE:CODE:NOROOT(1)
;   428 void   ControlStream_OFF_UART0( void )
;   429 {
;   430     ContrStream_UART0 = 0;
; __nearfunc void ControlStream_OFF_UART0();
ControlStream_OFF_UART0:
	LDI	R16,0
	STS	ContrStream_UART0,R16
;   431 }
	RET
;   432 
;   433 
;   434 /*-------------------------*/
;   435 /* "Echo On UART0"         */

        RSEG CODE:CODE:NOROOT(1)
;   436 void   Echo_ON_UART0( void )   // Set Echo = 1 Mode 'ON'
;   437       {
;   438       Enb_Echo_UART0 = 1;
; __nearfunc void Echo_ON_UART0();
Echo_ON_UART0:
	LDI	R16,1
	STS	Enb_Echo_UART0,R16
;   439       }
	RET
;   440 
;   441 /*- -------------------------*/
;   442 /* "Echo OFF UART0"          */

        RSEG CODE:CODE:NOROOT(1)
;   443 void   Echo_OFF_UART0( void )  // Set Echo = 0 Mode 'OFF'
;   444       {
;   445       Enb_Echo_UART0 = 0;
; __nearfunc void Echo_OFF_UART0();
Echo_OFF_UART0:
	LDI	R16,0
	STS	Enb_Echo_UART0,R16
;   446       }
	RET
;   447 
;   448 /*-------------------------*/
;   449 /* "Break UART0" for UART  */

        RSEG CODE:CODE:NOROOT(1)
;   450 void   Break_UART0( void )    // Set pin AVR TXD = MARK ( Low )
;   451       {}
; __nearfunc void Break_UART0();
Break_UART0:
	RET
;   452 
;   453 /*---------------------------------*/
;   454 /*  "DTR ON CONTROLL UART0"        */

        RSEG CODE:CODE:NOROOT(1)
;   455 void     DTR_ON_CONTR_UART0( void )     // Control DTR ON
;   456       {
;   457       Enb_DTR0 = 1;
; __nearfunc void DTR_ON_CONTR_UART0();
DTR_ON_CONTR_UART0:
	LDI	R16,1
	STS	Enb_DTR0,R16
;   458       }
	RET
;   459 
;   460 /*---------------------------------*/
;   461 /*  "DTR OFF CONTROL UART0"        */

        RSEG CODE:CODE:NOROOT(1)
;   462 void     DTR_OFF_CONTR_UART0( void )    // Control DTR OFF
;   463       {
;   464       Enb_DTR0 = 0;
; __nearfunc void DTR_OFF_CONTR_UART0();
DTR_OFF_CONTR_UART0:
	LDI	R16,0
	STS	Enb_DTR0,R16
;   465       }
	RET
;   466 
;   467 /*---------------------------------*/
;   468 /*  "DTR SET UART0"                */

        RSEG CODE:CODE:NOROOT(1)
;   469 void     DTR_SET_UART0( void )          // Set signal DTR = 1
;   470       {
;   471       Bit_DTR0 = 1;
; __nearfunc void DTR_SET_UART0();
DTR_SET_UART0:
	LDI	R16,1
	STS	Bit_DTR0,R16
;   472       PORT_FLOW_D = PORT_FLOW_D | ( 1<< DTR0 ); // Pin port output
	SBI	0x11,0x04
;   473        if ( Bit_DTR0 & 0x01 == 0)
	LDS	R16,Bit_DTR0
;   474        {
;   475        ClrBit( PORT_FLOW_O, DTR0); // pin output set low 0
;   476        }
;   477        else
;   478        {
;   479        SetBit( PORT_FLOW_O, DTR0); // pin output set high 1
	SBI	0x12,0x04
;   480        };
;   481       }
	RET
;   482 
;   483 /*---------------------------------*/
;   484 /*  "DTR CLR UART0"                */

        RSEG CODE:CODE:NOROOT(1)
;   485 void     DTR_CLR_UART0( void )          // Set DTR = 0
;   486       {
;   487       Bit_DTR0 = 0;
; __nearfunc void DTR_CLR_UART0();
DTR_CLR_UART0:
	LDI	R16,0
	STS	Bit_DTR0,R16
;   488       PORT_FLOW_D = PORT_FLOW_D | ( 1<< DTR0 ); // Pin port output
	SBI	0x11,0x04
;   489        if ( Bit_DTR0 & 0x01 == 0)
	LDS	R16,Bit_DTR0
;   490        {
;   491        ClrBit( PORT_FLOW_O, DTR0); // pin output set low 0
;   492        }
;   493        else
;   494        {
;   495        SetBit( PORT_FLOW_O, DTR0); // pin output set high 1
	SBI	0x12,0x04
;   496        };
;   497       }
	RET
;   498 
;   499 /*-----------------------------*/
;   500 /* "RTS_ON_CONTR_UART0"        */

        RSEG CODE:CODE:NOROOT(1)
;   501 void     RTS_ON_CONTR_UART0( void )    // Control RTS ON
;   502       {
;   503       Enb_RTS0 =1;
; __nearfunc void RTS_ON_CONTR_UART0();
RTS_ON_CONTR_UART0:
	LDI	R16,1
	STS	Enb_RTS0,R16
;   504       }
	RET
;   505 
;   506 /*-----------------------------*/
;   507 /*  "RTS_OFF_CONTR_UART0"      */

        RSEG CODE:CODE:NOROOT(1)
;   508 void     RTS_OFF_CONTR_UART0( void )   // Control RTS OFF
;   509       {
;   510       Enb_RTS0 =0;
; __nearfunc void RTS_OFF_CONTR_UART0();
RTS_OFF_CONTR_UART0:
	LDI	R16,0
	STS	Enb_RTS0,R16
;   511       }
	RET
;   512 
;   513 /*------------------------------*/
;   514 /*  "RTS_SET_UART0"             */

        RSEG CODE:CODE:NOROOT(1)
;   515 void     RTS_SET_UART0( void )        // Set RTS = 1
;   516        {
;   517       Bit_RTS0 = 1;
; __nearfunc void RTS_SET_UART0();
RTS_SET_UART0:
	LDI	R16,1
	STS	Bit_RTS0,R16
;   518       PORT_FLOW_D = PORT_FLOW_D  | ( 1<< RTS0 ); // Pin port output
	SBI	0x11,0x05
;   519        if ( Bit_RTS0 & 0x01 == 0)
	LDS	R16,Bit_RTS0
;   520        {
;   521        ClrBit( PORT_FLOW_O, RTS0); // pin output set low 0
;   522        }
;   523        else
;   524        {
;   525        SetBit( PORT_FLOW_O, RTS0); // pin output set high 1
	SBI	0x12,0x05
;   526        };
;   527        }
	RET
;   528 
;   529 /*------------------------*/
;   530 /*  "RTS_CLR_UART0"       */

        RSEG CODE:CODE:NOROOT(1)
;   531 void     RTS_CLR_UART0( void )         // Set RTS = 0
;   532        {
;   533       Bit_RTS0 = 0;
; __nearfunc void RTS_CLR_UART0();
RTS_CLR_UART0:
	LDI	R16,0
	STS	Bit_RTS0,R16
;   534       PORT_FLOW_D = PORT_FLOW_D  | ( 1<< RTS0 ); // Pin port output
	SBI	0x11,0x05
;   535        if ( Bit_RTS0 & 0x01 == 0)
	LDS	R16,Bit_RTS0
;   536        {
;   537        ClrBit( PORT_FLOW_O, RTS0); // pin output set low 0
;   538        }
;   539        else
;   540        {
;   541        SetBit( PORT_FLOW_O, RTS0); // pin output set high 1
	SBI	0x12,0x05
;   542        };
;   543        }
	RET
;   544 
;   545 /*--------------------------*/
;   546 /*  "DSR_ON_CONTR_UART0"    */

        RSEG CODE:CODE:NOROOT(1)
;   547 void     DSR_ON_CONTR_UART0( void )    // Control DSR ON
;   548       {
;   549       Enb_DSR0 = 1;
; __nearfunc void DSR_ON_CONTR_UART0();
DSR_ON_CONTR_UART0:
	LDI	R16,1
	STS	Enb_DSR0,R16
;   550       }
	RET
;   551 
;   552 /*-------------------------*/
;   553 /* "DSR_OFF_CONTR_UART0"   */

        RSEG CODE:CODE:NOROOT(1)
;   554 void     DSR_OFF_CONTR_UART0( void )   // Control DSR OFF
;   555       {
;   556       Enb_DSR0 = 0;
; __nearfunc void DSR_OFF_CONTR_UART0();
DSR_OFF_CONTR_UART0:
	LDI	R16,0
	STS	Enb_DSR0,R16
;   557       }
	RET
;   558 
;   559 /*--------------------------*/
;   560 /*  "DSR_SET_UART0"         */

        RSEG CODE:CODE:NOROOT(1)
;   561 void     DSR_SET_UART0( void )         // Set DSR = 1
;   562       {
;   563       Bit_DSR0 = 1;
; __nearfunc void DSR_SET_UART0();
DSR_SET_UART0:
	LDI	R16,1
	STS	Bit_DSR0,R16
;   564       }
	RET
;   565 
;   566 /*---------------------*/
;   567 /*  "DSR_CLR_UART0"    */

        RSEG CODE:CODE:NOROOT(1)
;   568 void     DSR_CLR_UART0( void )         // Set DSR = 0
;   569        {
;   570        Bit_DSR0 = 0;
; __nearfunc void DSR_CLR_UART0();
DSR_CLR_UART0:
	LDI	R16,0
	STS	Bit_DSR0,R16
;   571        }
	RET
;   572 
;   573 /*--------------------------*/
;   574 /*  "CTS_ON_CONTR_UART0"    */

        RSEG CODE:CODE:NOROOT(1)
;   575 void     CTS_ON_CONTR_UART0( void )    // Control CTS ON
;   576       {
;   577       Enb_CTS0 = 1;
; __nearfunc void CTS_ON_CONTR_UART0();
CTS_ON_CONTR_UART0:
	LDI	R16,1
	STS	Enb_CTS0,R16
;   578       }
	RET
;   579 
;   580 /*-------------------------*/
;   581 /* "CTS_OFF_CONTR_UART0"   */

        RSEG CODE:CODE:NOROOT(1)
;   582 void     CTS_OFF_CONTR_UART0( void )   // Control CTS OFF
;   583       {
;   584       Enb_CTS0 = 0;
; __nearfunc void CTS_OFF_CONTR_UART0();
CTS_OFF_CONTR_UART0:
	LDI	R16,0
	STS	Enb_CTS0,R16
;   585       }
	RET
;   586 
;   587 /*--------------------------*/
;   588 /*  "CTS_SET_UART0"         */

        RSEG CODE:CODE:NOROOT(1)
;   589 void     CTS_SET_UART0( void )         // Set CTS = 1
;   590       {
;   591       Bit_CTS0 = 1;
; __nearfunc void CTS_SET_UART0();
CTS_SET_UART0:
	LDI	R16,1
	STS	Bit_CTS0,R16
;   592       }
	RET
;   593 
;   594 /*---------------------*/
;   595 /*  "CTS_CLR_UART0"    */

        RSEG CODE:CODE:NOROOT(1)
;   596 void     CTS_CLR_UART0( void )         // Set CTS = 0
;   597        {
;   598        Bit_CTS0 = 0;
; __nearfunc void CTS_CLR_UART0();
CTS_CLR_UART0:
	LDI	R16,0
	STS	Bit_CTS0,R16
;   599        }
	RET
;   600 
;   601 /*--------------------------------*/
;   602 /* "XON_XOFF_ON_CONTR_Rx_UART0"   */

        RSEG CODE:CODE:NOROOT(1)
;   603 void     XON_XOFF_ON_CONTR_Rx_UART0( void )  // XON/XOFF  Rx = 1 Enable
;   604         {
;   605         Count_XOFF_Rx_UART0 = 0;
; __nearfunc void XON_XOFF_ON_CONTR_Rx_UART0();
XON_XOFF_ON_CONTR_Rx_UART0:
	LDI	R16,0
	STS	Count_XOFF_Rx_UART0,R16
;   606         Enb_XON_XOFF_Rx_UART0 = 1;
	LDI	R16,1
	STS	Enb_XON_XOFF_Rx_UART0,R16
;   607         }
	RET
;   608 
;   609 /*---------------------------------*/
;   610 /* "XON_XOFF_OFF_CONTR_Rx_UART0"   */

        RSEG CODE:CODE:NOROOT(1)
;   611 void     XON_XOFF_OFF_CONTR_Rx_UART0( void ) // XON/XOFF Rx = 0 Disable
;   612         {
;   613         Count_XOFF_Rx_UART0 = 0;
; __nearfunc void XON_XOFF_OFF_CONTR_Rx_UART0();
XON_XOFF_OFF_CONTR_Rx_UART0:
	LDI	R16,0
	STS	Count_XOFF_Rx_UART0,R16
;   614         Enb_XON_XOFF_Rx_UART0 = 0;
	LDI	R16,0
	STS	Enb_XON_XOFF_Rx_UART0,R16
;   615         }
	RET
;   616 /*--------------------------------*/
;   617 /* "XON_XOFF_ON_CONTR_Tx_UART0"   */

        RSEG CODE:CODE:NOROOT(1)
;   618 void     XON_XOFF_ON_CONTR_Tx_UART0( void )  // XON/XOFF  Tx = 1 Enable
;   619         {
;   620         Count_XOFF_Tx_UART0 = 0;
; __nearfunc void XON_XOFF_ON_CONTR_Tx_UART0();
XON_XOFF_ON_CONTR_Tx_UART0:
	LDI	R16,0
	STS	Count_XOFF_Tx_UART0,R16
;   621         Enb_XON_XOFF_Tx_UART0 = 1;
	LDI	R16,1
	STS	Enb_XON_XOFF_Tx_UART0,R16
;   622         }
	RET
;   623 
;   624 /* "XON_XOFF_OFF_CONTR_Tx_UART0"   */

        RSEG CODE:CODE:NOROOT(1)
;   625 void     XON_XOFF_OFF_CONTR_Tx_UART0( void ) // XON/XOFF Tx = 0 Disable
;   626         {
;   627         Count_XOFF_Tx_UART0 = 0;
; __nearfunc void XON_XOFF_OFF_CONTR_Tx_UART0();
XON_XOFF_OFF_CONTR_Tx_UART0:
	LDI	R16,0
	STS	Count_XOFF_Tx_UART0,R16
;   628         Enb_XON_XOFF_Tx_UART0 = 0;
	LDI	R16,0
	STS	Enb_XON_XOFF_Tx_UART0,R16
;   629         }
	RET
;   630 
;   631 /**********************/
;   632 /* Function IncErrArr */

        RSEG CODE:CODE:NOROOT(1)
;   633 void IncErrArr_UART0 ( int pos )
;   634 {
;   635  if ( Enb_Err_UART0 != 0 )
; __nearfunc void IncErrArr_UART0(int);
IncErrArr_UART0:
	LDS	R18,Enb_Err_UART0
	TST	R18
	BREQ	??IncErrArr_UART0_0
;   636   {
;   637   Rx_Tx_Err_UART0[pos]++;
	LDI	R20,2
	LDI	R21,0
	CALL	?S_MUL_L02
	MOVW	R31 : R30,R17 : R16
	SUBI	R30,LOW((-(Rx_Tx_Err_UART0) & 0xFFFF))
	SBCI	R31,(-(Rx_Tx_Err_UART0) & 0xFFFF) >> 8
	LD	R16,Z
	LDD	R17,Z+1
	SUBI	R16,255
	SBCI	R17,255
	ST	Z,R16
	STD	Z+1,R17
;   638   };
;   639 }
??IncErrArr_UART0_0:
	RET
;   640 /*  End IncErrArr    */
;   641 /*********************/
;   642 
;   643 /****************************/
;   644 /* Read and write functions */

        RSEG CODE:CODE:NOROOT(1)
;   645 unsigned char ReceiveByte_UART0( void )
;   646         {
;   647         unsigned char tmptail;
;   648         unsigned char cByte;
;   649 
;   650         while ( RxHead_UART0 == RxTail_UART0 ) /* wait for incomming data */
; __nearfunc unsigned char ReceiveByte_UART0();
ReceiveByte_UART0:
??ReceiveByte_UART0_0:
	LDS	R16,RxHead_UART0
	LDS	R17,RxTail_UART0
	CP	R16,R17
	BREQ	??ReceiveByte_UART0_0
;   651                 ;
;   652         tmptail = ( RxTail_UART0 + 1 ) & RX_BUFFER_MASK_UART0;/* calculate buffer index */
	LDS	R16,RxTail_UART0
	INC	R16
	ANDI	R16,0x1F
;   653         RxTail_UART0 = tmptail; /* store new index */
	STS	RxTail_UART0,R16
;   654         cByte = RxBuf_UART0[tmptail];
	LDI	R17,0
	MOVW	R31 : R30,R17 : R16
	SUBI	R30,LOW((-(RxBuf_UART0) & 0xFFFF))
	SBCI	R31,(-(RxBuf_UART0) & 0xFFFF) >> 8
	LD	R16,Z
;   655 
;   656         return cByte; /* return data */
	RET
;   657         }
;   658 

        RSEG CODE:CODE:NOROOT(1)
;   659 void TransmitByte_UART0( unsigned char data )
;   660         {
;   661         unsigned char tmphead;
;   662         /* calculate buffer index */
;   663         tmphead = ( TxHead_UART0 + 1 ) & TX_BUFFER_MASK_UART0;
; __nearfunc void TransmitByte_UART0(unsigned char);
TransmitByte_UART0:
	LDS	R18,TxHead_UART0
	INC	R18
	ANDI	R18,0x1F
;   664                 /* wait for free space in buffer or Enable Transmit */
;   665         while ( tmphead == TxTail_UART0 )
??TransmitByte_UART0_0:
	LDS	R17,TxTail_UART0
	CP	R18,R17
	BREQ	??TransmitByte_UART0_0
;   666                 ;
;   667         TxBuf_UART0[tmphead] = data; /* store data in buffer */
	LDI	R19,0
	MOVW	R31 : R30,R19 : R18
	SUBI	R30,LOW((-(TxBuf_UART0) & 0xFFFF))
	SBCI	R31,(-(TxBuf_UART0) & 0xFFFF) >> 8
	ST	Z,R16
;   668         TxHead_UART0 = tmphead; /* store new index */
	STS	TxHead_UART0,R18
;   669         UCSR0B |= (1<<UDRIE0); /* enable UDRE interrupt */
	SBI	0x0A,0x05
;   670         }
	RET
;   671 

        RSEG CODE:CODE:NOROOT(1)
;   672 unsigned char DataInReceiveBuffer( void )
;   673         {
;   674         return ( RxHead_UART0 != RxTail_UART0 );
; __nearfunc unsigned char DataInReceiveBuffer();
DataInReceiveBuffer:
	LDS	R16,RxHead_UART0
	LDS	R17,RxTail_UART0
	CP	R16,R17
	BREQ	??DataInReceiveBuffer_0
	LDI	R16,1
	RET
??DataInReceiveBuffer_0:
	LDI	R16,0
	RET
;   675                 /* return 0 (FALSE) if the receive buffer is empty */
;   676         }
;   677 
;   678 /*************************************/
;   679 /* Function interrupt UART0_RX(void) */
;   680 #pragma vector=UART0_RX_vect

        RSEG CODE:CODE:NOROOT(1)
;   681 static __interrupt void UART0_RX(void)
;   682   {
; static __nearfunc __interrupt void UART0_RX();
UART0_RX:
        FUNCALL UART0_RX, IncErrArr_UART0
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_RX, IncErrArr_UART0
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_RX, CheckParity7
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_RX, CheckParity8
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_RX, IncErrArr_UART0
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_RX, IncErrArr_UART0
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_RX, IncErrArr_UART0
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_RX, IncErrArr_UART0
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_RX, IncErrArr_UART0
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_RX, TransmitByte_UART0
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_RX, TransmitByte_UART0
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_RX, TransmitByte_UART0
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_RX, TransmitByte_UART0
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_RX, TransmitByte_UART0
        LOCFRAME CSTACK, 21, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R27
	ST	-Y,R26
	ST	-Y,R25
	ST	-Y,R24
	ST	-Y,R31
	ST	-Y,R30
	ST	-Y,R3
	ST	-Y,R2
	ST	-Y,R1
	ST	-Y,R0
	ST	-Y,R23
	ST	-Y,R22
	ST	-Y,R21
	ST	-Y,R20
	ST	-Y,R19
	ST	-Y,R18
	ST	-Y,R17
	ST	-Y,R16
	IN	R27,0x3F
	SBIW	R29 : R28,3
;   683     unsigned char tmphead;
;   684     unsigned char cTmp;
;   685     unsigned char cByte;
;   686     unsigned char cPERx;
;   687     volatile unsigned char FlgErr;
;   688     volatile int dTest;
;   689 
;   690 /* if enable flow control stream */
;   691       switch (ContrStream_UART0)
	LDS	R16,ContrStream_UART0
	SUBI	R16,0
	BREQ	??UART0_RX_0
;   692        {
;   693         case 0:
;   694         break;
;   695         default:
;   696           switch (Enb_DTR0)
	LDS	R16,Enb_DTR0
	DEC	R16
	BRNE	??UART0_RX_0
;   697             {
;   698             case 1:
;   699             PORT_FLOW_D = PORT_FLOW_D | ( 1<< DTR0 ); // Pin port output
	SBI	0x11,0x04
;   700               if ( Bit_DTR0 & 0x01 == 0)
	LDS	R16,Bit_DTR0
;   701               {
;   702               ClrBit( PORT_FLOW_O, DTR0); // pin output set low 0
;   703               }
;   704               else
;   705               {
;   706               SetBit( PORT_FLOW_O, DTR0); // pin output set high 1
	SBI	0x12,0x04
;   707               };
;   708             break;
;   709             default:
;   710             break;
;   711             };
;   712         break;
;   713        };
;   714 
;   715       switch (ContrStream_UART0)
??UART0_RX_0:
	LDS	R16,ContrStream_UART0
	SUBI	R16,0
	BREQ	??UART0_RX_1
;   716        {
;   717         case 0:
;   718         break;
;   719         default:
;   720           switch (Enb_DSR0)
	LDS	R16,Enb_DSR0
	DEC	R16
	BRNE	??UART0_RX_2
;   721             {
;   722             case 1:
;   723             PORT_FLOW_D = PORT_FLOW_D & ~( 1<< DSR0 ); // Pin port input
	CBI	0x11,0x06
;   724             Bit_DSR0 = ( (PORT_FLOW_I & ( 1<<DSR0)) >> DSR0 ); // Calculate bit
	IN	R16,0x10
	ANDI	R16,0x40
	LSL	R16
	BST	R16,7
	SBC	R16,R16
	BLD	R16,0
	STS	Bit_DSR0,R16
;   725             break;
;   726             default:
;   727             break;
;   728             };
;   729           switch (Enb_CTS0)
??UART0_RX_2:
	LDS	R16,Enb_CTS0
	DEC	R16
	BRNE	??UART0_RX_1
;   730             {
;   731             case 1:
;   732             PORT_FLOW_D = PORT_FLOW_D & ~( 1<< CTS0 ); // Pin port input
	CBI	0x11,0x03
;   733             Bit_CTS0 = ( (PORT_FLOW_I & ( 1<<CTS0)) >> CTS0 ); // Calculate bit
	IN	R16,0x10
	ANDI	R16,0x08
	ASR	R16
	ASR	R16
	ASR	R16
	STS	Bit_CTS0,R16
;   734             break;
;   735             default:
;   736             break;
;   737             };
;   738         break;
;   739        };
;   740 
;   741     FlgErr = 0;  //  if FlgErr=0 then  NO Errors Rx
??UART0_RX_1:
	LDI	R16,0
	ST	Y,R16
;   742 
;   743     //cTmp = UCSR0A & 0x10;  // Test bit FE0=?
;   744     if ( (UCSR0A & 0x10) != 0 )
	SBIS	0x0B,0x04
	RJMP	??UART0_RX_3
;   745       {
;   746       FlgErr = 1;         // '1' - Rx byte yes Error
	LDI	R16,1
	ST	Y,R16
;   747       IncErrArr_UART0(1); // increment Rx_Tx_Err_UART0[1]
	LDI	R16,1
	LDI	R17,0
	RCALL	IncErrArr_UART0
;   748       };
;   749 
;   750      cByte = UDR0;                  // Read Byte Rx from UDR0
??UART0_RX_3:
	IN	R26,0x0C
;   751 
;   752     //cTmp = UCSR0A & 0x08; // Test bit OE0=?
;   753      if ( (UCSR0A & 0x08 != 0) )
	SBIS	0x0B,0x00
	RJMP	??UART0_RX_4
;   754       {
;   755       FlgErr = 1;
	LDI	R16,1
	ST	Y,R16
;   756       IncErrArr_UART0(2); // increment Rx_Tx_Err_UART0[2]
	LDI	R16,2
	LDI	R17,0
	RCALL	IncErrArr_UART0
;   757           };
;   758 
;   759     /* Calcul Parity for cByte and comperate Bit Parity   */
;   760     switch ( SizeBit_UART0)
??UART0_RX_4:
	LDS	R16,SizeBit_UART0
	SUBI	R16,0
	BREQ	??UART0_RX_5
	DEC	R16
	BREQ	??UART0_RX_6
	RJMP	??UART0_RX_7
;   761      {
;   762      case 0:    // Size 7 bits
;   763      cTmp = CheckParity7( cByte) ;
??UART0_RX_5:
	MOV	R16,R26
	CALL	CheckParity7
	MOV	R25,R16
;   764      cPERx = cByte & (1<<7);  // Read 8 Bit cByte Rx
	MOV	R24,R26
	ANDI	R24,0x80
;   765      cPERx = (cPERx>>7);      // cPERx = 0 or 1
	MOV	R16,R24
	LSL	R16
	LDI	R24,0
	ROL	R24
	RJMP	??UART0_RX_7
;   766      break;
;   767      case 1:
;   768      cTmp = CheckParity8( cByte) ;
??UART0_RX_6:
	MOV	R16,R26
	CALL	CheckParity8
	MOV	R25,R16
;   769      cPERx = (UCSR0B & 0x02) >> 1;  // Read 9 Bit Rx cPEx =0 or 1
	IN	R24,0x0A
	ANDI	R24,0x02
	ASR	R24
;   770      break;
;   771      default:
;   772      break;
;   773      };
;   774       /* return
;   775          if cTmp = 0   then parity cByte
;   776          if cTmp = 255 then no parity
;   777       cPEx =0 or 1
;   778       */
;   779 
;   780        switch (CheckParity_UART0)
??UART0_RX_7:
	LDS	R16,CheckParity_UART0
	DEC	R16
	BREQ	??UART0_RX_8
	DEC	R16
	BREQ	??UART0_RX_9
	DEC	R16
	BREQ	??UART0_RX_10
	DEC	R16
	BREQ	??UART0_RX_11
	RJMP	??UART0_RX_12
;   781      {
;   782      case 0:
;   783      break;
;   784      case 1:  // Parity E
;   785      cTmp = cTmp & 0x01;
??UART0_RX_8:
	ANDI	R25,0x01
;   786      if (cPERx != cTmp)
	CP	R24,R25
	BREQ	??UART0_RX_12
;   787      {
;   788      FlgErr =1;
	LDI	R16,1
	ST	Y,R16
;   789      IncErrArr_UART0(3);   // increment Rx_Tx_Err_UART0[3]
	LDI	R16,3
	LDI	R17,0
	RCALL	IncErrArr_UART0
	RJMP	??UART0_RX_12
;   790      };
;   791      break;
;   792      case 2:  // Parity O
;   793       cTmp = ~cTmp & 0x01;
??UART0_RX_9:
	COM	R25
	ANDI	R25,0x01
;   794        if (cPERx != cTmp)
	CP	R24,R25
	BREQ	??UART0_RX_12
;   795           {
;   796           FlgErr =1;
	LDI	R16,1
	ST	Y,R16
;   797           IncErrArr_UART0(3);   // increment Rx_Tx_Err_UART0[3]
	LDI	R16,3
	LDI	R17,0
	RCALL	IncErrArr_UART0
	RJMP	??UART0_RX_12
;   798           };
;   799      break;
;   800      case 3:
;   801      if (cPERx != 1)  // Control Mark
??UART0_RX_10:
	CPI	R24,1
	BREQ	??UART0_RX_12
;   802      {
;   803      FlgErr =1;
	LDI	R16,1
	ST	Y,R16
;   804      IncErrArr_UART0(3);   // increment Rx_Tx_Err_UART0[3]
	LDI	R16,3
	LDI	R17,0
	RCALL	IncErrArr_UART0
	RJMP	??UART0_RX_12
;   805      };
;   806      break;
;   807      case 4:
;   808      if (cPERx != 0)  // Control Space
??UART0_RX_11:
	TST	R24
	BREQ	??UART0_RX_12
;   809      {
;   810      FlgErr =1;
	LDI	R16,1
	ST	Y,R16
;   811      IncErrArr_UART0(3);   // increment Rx_Tx_Err_UART0[3]
	LDI	R16,3
	LDI	R17,0
	RCALL	IncErrArr_UART0
;   812      };
;   813      break;
;   814      default:
;   815      break;
;   816      };
;   817 
;   818     /* Check buffer Rx */
;   819      if ( FlgErr == 0 )  // No Errors for Rx
??UART0_RX_12:
	LD	R16,Y
	TST	R16
	BREQ	??UART0_RX_13
	RJMP	??UART0_RX_14
;   820         {
;   821         /* calculate buffer index */
;   822         tmphead = ( RxHead_UART0 + 1 ) & RX_BUFFER_MASK_UART0;
??UART0_RX_13:
	LDS	R24,RxHead_UART0
	INC	R24
	ANDI	R24,0x1F
;   823 
;   824         if ( tmphead == RxTail_UART0 )
	LDS	R16,RxTail_UART0
	CP	R24,R16
	BRNE	??UART0_RX_15
;   825                 {
;   826                 IncErrArr_UART0(4); // increment Rx_Tx_Err_UART0[4]
	LDI	R16,4
	LDI	R17,0
	RCALL	IncErrArr_UART0
	RJMP	??UART0_RX_16
;   827                 }
;   828         else
;   829         RxHead_UART0 = tmphead; /* store new index */
??UART0_RX_15:
	STS	RxHead_UART0,R24
;   830         {
;   831            switch (ContrStream_UART0) // Begin Switch ContrStream_UART0
??UART0_RX_16:
	LDS	R16,ContrStream_UART0
	DEC	R16
	BREQ	??UART0_RX_17
	RJMP	??UART0_RX_18
;   832                 {
;   833                  case 0:
;   834                  break;
;   835                  case 1:  // Yes control stream
;   836                       if ( RxHead_UART0 > (RX_BUFFER_SIZE_UART0-4) )
??UART0_RX_17:
	LDS	R16,RxHead_UART0
	CPI	R16,29
	BRCS	??UART0_RX_19
;   837                         {
;   838                                   /* Signal DTR0 = 0 Stop Tx from PC IBM */
;   839                                   /* if enable flow control stream */
;   840                                   switch (Enb_RTS0)
	LDS	R16,Enb_RTS0
	DEC	R16
	BRNE	??UART0_RX_20
;   841                                   {
;   842                                   case 1:
;   843                                   PORT_FLOW_D = PORT_FLOW_D  | ( 1<< RTS0 ); // Pin port output
	SBI	0x11,0x05
;   844                                   SetBit( PORT_FLOW_O, RTS0); // pin output set hing 1
	SBI	0x12,0x05
;   845                                   Bit_RTS0 = 1;
	LDI	R16,1
	STS	Bit_RTS0,R16
	RJMP	??UART0_RX_20
;   846                                   break;
;   847                                   default:
;   848                                   break;
;   849                                   };
;   850                          }
;   851                        else
;   852                        {
;   853                                 /* Signal DTR0 = 0 Stop Tx from PC IBM */
;   854                                 /* if enable flow control stream */
;   855                                 switch (Enb_RTS0)
??UART0_RX_19:
	LDS	R16,Enb_RTS0
	DEC	R16
	BRNE	??UART0_RX_20
;   856                                  {
;   857                                 case 1:
;   858                                 PORT_FLOW_D = PORT_FLOW_D | ( 1<< RTS0 ); // Pin port output
	SBI	0x11,0x05
;   859                                 ClrBit( PORT_FLOW_O, RTS0); // pin output set high 1
	CBI	0x12,0x05
;   860                                 Bit_RTS0 = 0;
	LDI	R16,0
	STS	Bit_RTS0,R16
;   861                                 break;
;   862                                 default:
;   863                                 break;
;   864                                  };
;   865 
;   866                        };  // End if
;   867 
;   868                       switch(Enb_XON_XOFF_Rx_UART0) // Begin Switch Enb_XON_XOFF_Rx_UART0
??UART0_RX_20:
	LDS	R16,Enb_XON_XOFF_Rx_UART0
	DEC	R16
	BRNE	??UART0_RX_18
;   869                         {
;   870                         case 0:
;   871                         break;
;   872                         case 1:
;   873                               if ( RxHead_UART0 > (RX_BUFFER_SIZE_UART0-4) )
	LDS	R16,RxHead_UART0
	CPI	R16,29
	BRCS	??UART0_RX_21
;   874                               {
;   875                                   switch( Count_XOFF_Rx_UART0)
	LDS	R16,Count_XOFF_Rx_UART0
	SUBI	R16,0
	BREQ	??UART0_RX_22
	SUBI	R16,1
	BRCS	??UART0_RX_23
	SUBI	R16,4
	BRCS	??UART0_RX_24
	SUBI	R16,0
	BREQ	??UART0_RX_25
	RJMP	??UART0_RX_23
;   876                                   {
;   877                                   case 0:
;   878                                   TransmitByte_UART0(Sym_XOFF);
??UART0_RX_22:
	LDS	R16,Sym_XOFF
	RCALL	TransmitByte_UART0
;   879                                   Count_XOFF_Rx_UART0++;
	LDI	R30,LOW(Count_XOFF_Rx_UART0)
	LDI	R31,(Count_XOFF_Rx_UART0) >> 8
	LD	R16,Z
	INC	R16
	ST	Z,R16
	RJMP	??UART0_RX_18
;   880                                   break;
;   881                                   case 1:
;   882                                   case 2:
;   883                                   case 3:
;   884                                   case 4:
;   885                                   Count_XOFF_Rx_UART0++;  //increment counter
??UART0_RX_24:
	LDI	R30,LOW(Count_XOFF_Rx_UART0)
	LDI	R31,(Count_XOFF_Rx_UART0) >> 8
	LD	R16,Z
	INC	R16
	ST	Z,R16
	RJMP	??UART0_RX_18
;   886                                   break;
;   887                                   case 5:
;   888                                   TransmitByte_UART0(Sym_XOFF);
??UART0_RX_25:
	LDS	R16,Sym_XOFF
	RCALL	TransmitByte_UART0
;   889                                   Count_XOFF_Rx_UART0 = 1;
	LDI	R16,1
	STS	Count_XOFF_Rx_UART0,R16
	RJMP	??UART0_RX_18
;   890                                   break;
;   891                                   default:
;   892                                   TransmitByte_UART0(Sym_XOFF);
??UART0_RX_23:
	LDS	R16,Sym_XOFF
	RCALL	TransmitByte_UART0
;   893                                   Count_XOFF_Rx_UART0 = 1;
	LDI	R16,1
	STS	Count_XOFF_Rx_UART0,R16
	RJMP	??UART0_RX_18
;   894                                   break;
;   895                                   };
;   896                               }
;   897                               else
;   898                               {
;   899                                 switch( Count_XOFF_Rx_UART0)
??UART0_RX_21:
	LDS	R16,Count_XOFF_Rx_UART0
	SUBI	R16,0
	BREQ	??UART0_RX_18
;   900                                 {
;   901                                 case 0:
;   902                                 break;
;   903                                 default:
;   904                                 TransmitByte_UART0(Sym_XON);
	LDS	R16,Sym_XON
	RCALL	TransmitByte_UART0
;   905                                 Count_XOFF_Rx_UART0 = 0;
	LDI	R16,0
	STS	Count_XOFF_Rx_UART0,R16
;   906                                 break;
;   907                                 };
;   908                               };
;   909                         break;
;   910                         default:
;   911                         break;
;   912                         };  //// End Switch ( Enb_XON_XOFF_Rx_UART0 )
;   913 
;   914                  break;
;   915                  default:
;   916                  break;
;   917                  };  // End Switch ( ContrStream_UART0 )
;   918         };
;   919         if ( FlgErr == 0)
??UART0_RX_18:
	LD	R16,Y
	TST	R16
	BRNE	??UART0_RX_26
;   920         {
;   921         RxBuf_UART0[tmphead] = cByte; /* store received data in buffer */
	LDI	R25,0
	MOVW	R31 : R30,R25 : R24
	SUBI	R30,LOW((-(RxBuf_UART0) & 0xFFFF))
	SBCI	R31,(-(RxBuf_UART0) & 0xFFFF) >> 8
	ST	Z,R26
;   922 
;   923           switch (ContrStream_UART0)
	LDS	R16,ContrStream_UART0
	DEC	R16
	BRNE	??UART0_RX_26
;   924            {
;   925            case 1:
;   926              switch (Enb_XON_XOFF_Tx_UART0)
	LDS	R16,Enb_XON_XOFF_Tx_UART0
	DEC	R16
	BRNE	??UART0_RX_26
;   927               {
;   928               case 0:
;   929               break;
;   930               case 1:
;   931                 if ( cByte == Sym_XOFF)
	LDS	R16,Sym_XOFF
	CP	R26,R16
	BRNE	??UART0_RX_27
;   932                 {
;   933                 Count_XOFF_Tx_UART0 = 1;  // Disable Transmit
	LDI	R16,1
	STS	Count_XOFF_Tx_UART0,R16
;   934                 };
;   935                 if ( cByte == Sym_XON)
??UART0_RX_27:
	LDS	R16,Sym_XON
	CP	R26,R16
	BRNE	??UART0_RX_26
;   936                 {
;   937                 Count_XOFF_Tx_UART0 = 0;  // Enable Transmit
	LDI	R16,0
	STS	Count_XOFF_Tx_UART0,R16
;   938                 };
;   939               break;
;   940               default:
;   941               break;
;   942               };
;   943            break;
;   944            default:
;   945            break;
;   946            };
;   947         };
;   948 
;   949         /* if Mode Echo then Tx Byte*/
;   950          if ( Enb_Echo_UART0 == 1)
??UART0_RX_26:
	LDS	R16,Enb_Echo_UART0
	CPI	R16,1
	BRNE	??UART0_RX_28
;   951          {
;   952          TransmitByte_UART0(cByte);
	MOV	R16,R26
	RCALL	TransmitByte_UART0
;   953          };
;   954 
;   955         if ( Enb_Err_UART0 == 1 )
??UART0_RX_28:
	LDS	R16,Enb_Err_UART0
	CPI	R16,1
	BRNE	??UART0_RX_29
;   956           {
;   957           Count_Rx_UART0++;
	LDI	R30,LOW(Count_Rx_UART0)
	LDI	R31,(Count_Rx_UART0) >> 8
	LD	R16,Z
	LDD	R17,Z+1
	LDD	R18,Z+2
	LDD	R19,Z+3
	SUBI	R16,255
	SBCI	R17,255
	SBCI	R18,255
	SBCI	R19,255
	ST	Z,R16
	STD	Z+1,R17
	STD	Z+2,R18
	STD	Z+3,R19
	RJMP	??UART0_RX_29
;   958           };
;   959         }
;   960         else        // Yes Errors Rx for UART0
;   961         {
;   962         if ( Enb_Err_UART0 == 1 )
??UART0_RX_14:
	LDS	R16,Enb_Err_UART0
	CPI	R16,1
	BRNE	??UART0_RX_29
;   963           {
;   964           Count_Rx_Err_UART0++;
	LDI	R30,LOW(Count_Rx_Err_UART0)
	LDI	R31,(Count_Rx_Err_UART0) >> 8
	LD	R16,Z
	LDD	R17,Z+1
	LDD	R18,Z+2
	LDD	R19,Z+3
	SUBI	R16,255
	SBCI	R17,255
	SBCI	R18,255
	SBCI	R19,255
	ST	Z,R16
	STD	Z+1,R17
	STD	Z+2,R18
	STD	Z+3,R19
;   965           };
;   966         };
;   967   }
??UART0_RX_29:
	ADIW	R29 : R28,3
	OUT	0x3F,R27
	LD	R16,Y+
	LD	R17,Y+
	LD	R18,Y+
	LD	R19,Y+
	LD	R20,Y+
	LD	R21,Y+
	LD	R22,Y+
	LD	R23,Y+
	LD	R0,Y+
	LD	R1,Y+
	LD	R2,Y+
	LD	R3,Y+
	LD	R30,Y+
	LD	R31,Y+
	LD	R24,Y+
	LD	R25,Y+
	LD	R26,Y+
	LD	R27,Y+
	RETI
;   968 /* End function interrupt UART0_RX(void) */
;   969 /*****************************************/
;   970 
;   971 
;   972 /****************************************/
;   973 /* This method interrupt event TX Empty */
;   974 #pragma vector=UART0_UDRE_vect

        RSEG CODE:CODE:NOROOT(1)
;   975 static __interrupt void UART0_UDRE(void)
;   976     {
; static __nearfunc __interrupt void UART0_UDRE();
UART0_UDRE:
        FUNCALL UART0_UDRE, CheckParity7
        LOCFRAME CSTACK, 16, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_UDRE, CheckParity8
        LOCFRAME CSTACK, 16, STACK
        LOCFRAME RSTACK, 2, STACK
        FUNCALL UART0_UDRE, CheckParity8
        LOCFRAME CSTACK, 16, STACK
        LOCFRAME RSTACK, 2, STACK
	ST	-Y,R25
	ST	-Y,R24
	ST	-Y,R31
	ST	-Y,R30
	ST	-Y,R3
	ST	-Y,R2
	ST	-Y,R1
	ST	-Y,R0
	ST	-Y,R23
	ST	-Y,R22
	ST	-Y,R21
	ST	-Y,R20
	ST	-Y,R19
	ST	-Y,R18
	ST	-Y,R17
	ST	-Y,R16
	IN	R25,0x3F
;   977     unsigned char tmptail;
;   978     unsigned char cTmp;
;   979     unsigned char cByte;
;   980     unsigned char cPEx;
;   981     unsigned char EnbTx;
;   982 
;   983     EnbTx = 1;  // Yes Enable Tx
	LDI	R16,1
;   984 
;   985 /* if enable flow control stream for signal DTR0 */
;   986       switch (ContrStream_UART0) // Begin  switch (ContrStream_UART0)
	LDS	R17,ContrStream_UART0
	DEC	R17
	BRNE	??UART0_UDRE_0
;   987        {
;   988         case 1:
;   989           switch (Enb_DTR0)// Begin switch (Enb_DTR0)
	LDS	R17,Enb_DTR0
	DEC	R17
	BRNE	??UART0_UDRE_0
;   990             {
;   991             case 1:
;   992             PORT_FLOW_D = PORT_FLOW_D | ( 1<< DTR0 ); // Pin port output
	SBI	0x11,0x04
;   993               if ( Bit_DTR0 & 0x01 == 0)
	LDS	R17,Bit_DTR0
;   994               {
;   995               ClrBit( PORT_FLOW_O, DTR0); // pin output set low 0
;   996                }
;   997               else
;   998               {
;   999               SetBit( PORT_FLOW_O, DTR0); // pin output set high 1
	SBI	0x12,0x04
;  1000               };
;  1001             break;
;  1002             default:
;  1003             break;
;  1004             };// End switch (Enb_DTR0)
;  1005         break;
;  1006         default:
;  1007         break;
;  1008        };// Begin  switch (ContrStream_UART0)
;  1009 
;  1010 /* if enable flow control stream */
;  1011       switch (ContrStream_UART0) // Begin switch (ContrStream_UART0)
??UART0_UDRE_0:
	LDS	R17,ContrStream_UART0
	DEC	R17
	BRNE	??UART0_UDRE_1
;  1012        {
;  1013         case 1:
;  1014           switch (Enb_RTS0)
	LDS	R17,Enb_RTS0
	DEC	R17
	BRNE	??UART0_UDRE_1
;  1015             {
;  1016             case 1:
;  1017             PORT_FLOW_D = PORT_FLOW_D | ( 1<< RTS0 ); // Pin port output
	SBI	0x11,0x05
;  1018               if ( Bit_RTS0 & 0x01 == 0)
	LDS	R17,Bit_RTS0
;  1019               {
;  1020               ClrBit( PORT_FLOW_O, RTS0); // pin output set low 0
;  1021                }
;  1022               else
;  1023               {
;  1024               SetBit( PORT_FLOW_O, RTS0); // pin output set high 1
	SBI	0x12,0x05
;  1025               };
;  1026             break;
;  1027             default:
;  1028             break;
;  1029             };
;  1030         break;
;  1031         default:
;  1032         break;
;  1033        }; // End switch switch (ContrStream_UART0)
;  1034 
;  1035     /* if enable flow control stream */
;  1036       switch (ContrStream_UART0)// Begin  switch (ContrStream_UART0)
??UART0_UDRE_1:
	LDS	R17,ContrStream_UART0
	DEC	R17
	BRNE	??UART0_UDRE_2
;  1037        {
;  1038         case 1:
;  1039           switch (Enb_DSR0)
	LDS	R17,Enb_DSR0
	DEC	R17
	BRNE	??UART0_UDRE_3
;  1040             {
;  1041             case 1:
;  1042             PORT_FLOW_D = PORT_FLOW_D & ~( 1<< DSR0 ); // Pin port input
	CBI	0x11,0x06
;  1043             Bit_DSR0 = ( (PORT_FLOW_I & ( 1<<DSR0)) >> DSR0 ); // Calculate bit
	IN	R17,0x10
	ANDI	R17,0x40
	LSL	R17
	BST	R17,7
	SBC	R17,R17
	BLD	R17,0
	STS	Bit_DSR0,R17
;  1044             break;
;  1045             default:
;  1046             break;
;  1047             };
;  1048           switch (Enb_CTS0)
??UART0_UDRE_3:
	LDS	R17,Enb_CTS0
	DEC	R17
	BRNE	??UART0_UDRE_2
;  1049             {
;  1050             case 1:
;  1051             PORT_FLOW_D = PORT_FLOW_D & ~( 1<< CTS0 ); // Pin port input
	CBI	0x11,0x03
;  1052             Bit_CTS0 = ( (PORT_FLOW_I & ( 1<<CTS0)) >> CTS0 ); // Calculate bit
	IN	R17,0x10
	ANDI	R17,0x08
	ASR	R17
	ASR	R17
	ASR	R17
	STS	Bit_CTS0,R17
;  1053             break;
;  1054             default:
;  1055             break;
;  1056             };
;  1057         break;
;  1058         default:
;  1059         break;
;  1060        };// End  switch (ContrStream_UART0)
;  1061 
;  1062     /* ?? Test Controls stream UART0 */
;  1063 
;  1064     switch ( ContrStream_UART0 )
??UART0_UDRE_2:
	LDS	R17,ContrStream_UART0
	DEC	R17
	BRNE	??UART0_UDRE_4
;  1065       {
;  1066       case 1:
;  1067         if (Enb_XON_XOFF_Tx_UART0 == 1)
	LDS	R17,Enb_XON_XOFF_Tx_UART0
	CPI	R17,1
	BRNE	??UART0_UDRE_5
;  1068         {
;  1069           switch (Count_XOFF_Tx_UART0)
	LDS	R17,Count_XOFF_Tx_UART0
	SUBI	R17,0
	BREQ	??UART0_UDRE_5
;  1070             {
;  1071             case 0:
;  1072             break;
;  1073             default:
;  1074             EnbTx = 0;  // Disable Tx software flow
	LDI	R16,0
;  1075             break;
;  1076             };
;  1077         };
;  1078         if ( Enb_CTS0 == 1)
??UART0_UDRE_5:
	LDS	R17,Enb_CTS0
	CPI	R17,1
	BRNE	??UART0_UDRE_6
;  1079         {
;  1080           switch (Bit_CTS0)
	LDS	R17,Bit_CTS0
	DEC	R17
	BRNE	??UART0_UDRE_6
;  1081             {
;  1082             case 1:
;  1083             EnbTx = 0;  // Disable Tx hardware flow
	LDI	R16,0
;  1084             break;
;  1085             default:
;  1086             break;
;  1087             };
;  1088          };
;  1089          if (Enb_DSR0 == 1)
??UART0_UDRE_6:
	LDS	R17,Enb_DSR0
	CPI	R17,1
	BRNE	??UART0_UDRE_7
;  1090          {
;  1091           switch (Bit_DSR0)
	LDS	R17,Bit_DSR0
	DEC	R17
	BRNE	??UART0_UDRE_7
;  1092             {
;  1093             case 1:
;  1094             EnbTx = 0;  // Disable Tx hardware flow
	LDI	R16,0
;  1095             break;
;  1096             default:
;  1097             break;
;  1098             };
;  1099           };
;  1100          if (Enb_RTS0 == 1)
??UART0_UDRE_7:
	LDS	R17,Enb_RTS0
	CPI	R17,1
	BRNE	??UART0_UDRE_8
;  1101          {
;  1102           switch (Bit_RTS0)
	LDS	R17,Bit_RTS0
	DEC	R17
	BRNE	??UART0_UDRE_8
;  1103             {
;  1104             case 1:
;  1105             EnbTx = 0;  // Disable Tx hardware flow
	LDI	R16,0
;  1106             break;
;  1107             default:
;  1108             break;
;  1109             };
;  1110           };
;  1111           if (Enb_DTR0 == 1)
??UART0_UDRE_8:
	LDS	R17,Enb_DTR0
	CPI	R17,1
	BRNE	??UART0_UDRE_4
;  1112           {
;  1113           switch (Bit_DTR0)
	LDS	R17,Bit_DTR0
	DEC	R17
	BRNE	??UART0_UDRE_4
;  1114             {
;  1115             case 1:
;  1116             EnbTx = 0;  // Disable Tx hardware flow
	LDI	R16,0
;  1117             break;
;  1118             default:
;  1119             break;
;  1120             };
;  1121           };
;  1122       break;
;  1123       default:
;  1124       break;
;  1125       };
;  1126 
;  1127      /* Enable Yes then  Transmit Byte */
;  1128      if ( EnbTx == 1 )
??UART0_UDRE_4:
	CPI	R16,1
	BREQ	??UART0_UDRE_9
	RJMP	??UART0_UDRE_10
;  1129      {
;  1130         /* check if all data is transmitted */
;  1131         if ( TxHead_UART0 != TxTail_UART0 )
??UART0_UDRE_9:
	LDS	R16,TxHead_UART0
	LDS	R17,TxTail_UART0
	CP	R16,R17
	BRNE	??UART0_UDRE_11
	RJMP	??UART0_UDRE_12
;  1132            {
;  1133            /* calculate buffer index */
;  1134            tmptail = ( TxTail_UART0 + 1 ) & TX_BUFFER_MASK_UART0;
??UART0_UDRE_11:
	LDS	R16,TxTail_UART0
	INC	R16
	ANDI	R16,0x1F
;  1135            TxTail_UART0 = tmptail; /* store new index */
	STS	TxTail_UART0,R16
;  1136            cByte = TxBuf_UART0[tmptail];    // Byte for Tx UART0
	LDI	R17,0
	MOVW	R31 : R30,R17 : R16
	SUBI	R30,LOW((-(TxBuf_UART0) & 0xFFFF))
	SBCI	R31,(-(TxBuf_UART0) & 0xFFFF) >> 8
	LD	R24,Z
;  1137 
;  1138            /* Calculate Parity for mode SizeBit */
;  1139           switch ( SizeBit_UART0)
	LDS	R16,SizeBit_UART0
	SUBI	R16,0
	BREQ	??UART0_UDRE_13
	DEC	R16
	BREQ	??UART0_UDRE_14
	RJMP	??UART0_UDRE_15
;  1140               {
;  1141               case 0:
;  1142               cTmp = CheckParity7( cByte) ;
??UART0_UDRE_13:
	MOV	R16,R24
	CALL	CheckParity7
	RJMP	??UART0_UDRE_16
;  1143               break;
;  1144               case 1:
;  1145               cTmp = CheckParity8( cByte) ;
??UART0_UDRE_14:
	MOV	R16,R24
	CALL	CheckParity8
	RJMP	??UART0_UDRE_16
;  1146               break;
;  1147               default:
;  1148               cTmp = CheckParity8( cByte) ;
??UART0_UDRE_15:
	MOV	R16,R24
	CALL	CheckParity8
;  1149               break;
;  1150               };
;  1151 
;  1152            /* For Modes CheckParity_UART0 */
;  1153               switch (CheckParity_UART0)
??UART0_UDRE_16:
	LDS	R17,CheckParity_UART0
	SUBI	R17,0
	BREQ	??UART0_UDRE_17
	DEC	R17
	BREQ	??UART0_UDRE_18
	DEC	R17
	BREQ	??UART0_UDRE_19
	DEC	R17
	BREQ	??UART0_UDRE_20
	DEC	R17
	BREQ	??UART0_UDRE_21
	RJMP	??UART0_UDRE_22
;  1154               {
;  1155               case 0:
;  1156               break;
;  1157               case 1:
;  1158                 if ( cTmp == 0) // cByte parity
??UART0_UDRE_18:
	TST	R16
	BRNE	??UART0_UDRE_23
;  1159                 {
;  1160                  UCSR0B = UCSR0B & ~(1<<TXB80);  // TXB80 = 0
	CBI	0x0A,0x00
	RJMP	??UART0_UDRE_17
;  1161                 }
;  1162                 else
;  1163                 {
;  1164                 UCSR0B = UCSR0B | (1<<TXB80);   // TXB80 = 1
??UART0_UDRE_23:
	SBI	0x0A,0x00
	RJMP	??UART0_UDRE_17
;  1165                 };
;  1166               break;
;  1167               case 2:
;  1168 
;  1169                 if ( cTmp == 0) // cByte parity
??UART0_UDRE_19:
	TST	R16
	BRNE	??UART0_UDRE_24
;  1170                 {
;  1171                  UCSR0B = UCSR0B | (1<<TXB80);   // TXB80 = 1
	SBI	0x0A,0x00
	RJMP	??UART0_UDRE_17
;  1172                 }
;  1173                 else
;  1174                 {
;  1175                  UCSR0B = UCSR0B & ~(1<<TXB80);  // TXB80 = 0
??UART0_UDRE_24:
	CBI	0x0A,0x00
	RJMP	??UART0_UDRE_17
;  1176                 };
;  1177               break;
;  1178               case 3: // Mark
;  1179               UCSR0B = UCSR0B | (1<<TXB80);   // TXB80 = 1
??UART0_UDRE_20:
	SBI	0x0A,0x00
	RJMP	??UART0_UDRE_17
;  1180               break;
;  1181               case 4: // Space
;  1182               UCSR0B = UCSR0B & ~(1<<TXB80);  // TXB80 = 0
??UART0_UDRE_21:
	CBI	0x0A,0x00
	RJMP	??UART0_UDRE_17
;  1183               break;
;  1184               default:
;  1185               UCSR0B = UCSR0B | (1<<TXB80);   // TXB80 = 1
??UART0_UDRE_22:
	SBI	0x0A,0x00
;  1186               break;
;  1187               };
;  1188           /* Set bits for mode SizeBit */
;  1189               cPEx = UCSR0B & 0x01;    // Calculate bit TXB80
??UART0_UDRE_17:
	LDI	R17,0
	SBIC	0x0A,0x00
	INC	R17
;  1190                                        // cPEx = 0 or 1
;  1191           switch ( SizeBit_UART0)
	LDS	R18,SizeBit_UART0
	SUBI	R18,0
	BREQ	??UART0_UDRE_26
	DEC	R18
	BREQ	??UART0_UDRE_27
	RJMP	??UART0_UDRE_28
;  1192               {
;  1193               case 0: // Mode data size 7 bits
;  1194               cTmp = cByte | (0x80);     // b7=1
??UART0_UDRE_26:
	MOV	R16,R24
	ORI	R16,0x80
;  1195                 if ( cPEx == 0)
	TST	R17
	BRNE	??UART0_UDRE_29
;  1196                 {
;  1197                  ClrBit(cTmp,7);
	ANDI	R16,0x7F
	LDI	R17,0
	RJMP	??UART0_UDRE_28
;  1198                 }
;  1199                 else
;  1200                 {
;  1201                  SetBit(cTmp,7);
??UART0_UDRE_29:
	ORI	R16,0x80
	LDI	R17,1
	RJMP	??UART0_UDRE_28
;  1202                  };
;  1203               break;
;  1204               case 1: // Mode data size 7 bits
;  1205               cTmp = cByte;
??UART0_UDRE_27:
	MOV	R16,R24
;  1206               break;
;  1207               default:
;  1208               break;
;  1209               };
;  1210             UDR0 = cTmp; /* start transmition */
??UART0_UDRE_28:
	OUT	0x0C,R16
	RJMP	??UART0_UDRE_30
;  1211             }
;  1212         else
;  1213             {
;  1214             UCSR0B &= ~(1<<UDRIE0); /* disable UDRE interrupt */
??UART0_UDRE_12:
	CBI	0x0A,0x05
	RJMP	??UART0_UDRE_30
;  1215             };
;  1216       }
;  1217       else
;  1218       {
;  1219       UCSR0B &= ~(1<<UDRIE0); /* disable UDRE interrupt */
??UART0_UDRE_10:
	CBI	0x0A,0x05
;  1220       };
;  1221  }
??UART0_UDRE_30:
	OUT	0x3F,R25
	LD	R16,Y+
	LD	R17,Y+
	LD	R18,Y+
	LD	R19,Y+
	LD	R20,Y+
	LD	R21,Y+
	LD	R22,Y+
	LD	R23,Y+
	LD	R0,Y+
	LD	R1,Y+
	LD	R2,Y+
	LD	R3,Y+
	LD	R30,Y+
	LD	R31,Y+
	LD	R24,Y+
	LD	R25,Y+
	RETI

        COMMON INTVEC:CODE:ROOT(1)
        ORG 52
	JMP	UART0_RX

        COMMON INTVEC:CODE:ROOT(1)
        ORG 60
	JMP	UART0_UDRE

        RSEG NEAR_I:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_I>`
; char __near <Constant "%ld">[4];
`?<Constant "%ld">`:
	DS 4
	REQUIRE `?<Initializer for <Constant "%ld">>`

        RSEG NEAR_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "%ld">>`:
	DB "%ld"

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_I>`:
	DW	SFE(NEAR_I) - SFB(NEAR_I)
	DW	SFB(NEAR_I)
	DW	SFB(NEAR_ID)
	REQUIRE ?need_segment_init

        RSEG NEAR_I:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_I>`
; char __near <Constant "Table Counters  Rx:">[20];
`?<Constant "Table Counters  Rx:">`:
	DS 20
	REQUIRE `?<Initializer for <Constant "Table Counters  R`

        RSEG NEAR_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "Table Counters  R`:
	DB "Table Counters  Rx:"

        RSEG NEAR_I:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_I>`
; char __near <Constant "%d">[3];
`?<Constant "%d">`:
	DS 3
	REQUIRE `?<Initializer for <Constant "%d">>`

        RSEG NEAR_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "%d">>`:
	DB "%d"

        RSEG NEAR_I:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_I>`
; char __near <Constant "  ">[3];
`?<Constant "  ">`:
	DS 3
	REQUIRE `?<Initializer for <Constant "  ">>`

        RSEG NEAR_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "  ">>`:
	DB "  "

        RSEG NEAR_I:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_I>`
; char __near <Constant "Table Errors Rx/Tx:">[20];
`?<Constant "Table Errors Rx/Tx:">`:
	DS 20
	REQUIRE `?<Initializer for <Constant "Table Errors Rx/T`

        RSEG NEAR_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "Table Errors Rx/T`:
	DB "Table Errors Rx/Tx:"

        RSEG NEAR_I:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_I>`
; char __near <Constant " \n\r">[4];
`?<Constant " \\n\\r">`:
	DS 4
	REQUIRE `?<Initializer for <Constant " \\n\\r">>`

        RSEG NEAR_I:DATA:NOROOT(0)
	REQUIRE `?<Segment init: NEAR_I>`
; static unsigned char volatile __near A2x_y;
A2x_y:
	DS 1
	REQUIRE `?<Initializer for A2x_y>`

        RSEG NEAR_ID:CODE:NOROOT(0)
`?<Initializer for <Constant " \\n\\r">>`:
	DB " \012\015"

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_Z>`:
	DW	SFE(NEAR_Z) - SFB(NEAR_Z)
	DW	SFB(NEAR_Z)
	DW	0
	REQUIRE ?need_segment_init

        RSEG NEAR_ID:CODE:NOROOT(0)
`?<Initializer for A2x_y>`:
	DB 2

        END
;  1222 /* This method interrupt event TX Empty */
;  1223 /****************************************/
;  1224 
;  1225 #ifdef TEST_UART0
;  1226 /* main - a simple test program*/
;  1227 void main( void )
;  1228         {
;  1229         volatile long int l_i;
;  1230         volatile unsigned char cByte;
;  1231         volatile int iByte;
;  1232         volatile int iRet;
;  1233         unsigned int i;
;  1234       /*
;  1235         int x;
;  1236         char y;
;  1237         float z;
;  1238       */
;  1239         Reset_UART0();
;  1240         Init_S_UART0(57600); // 9600 default
;  1241         Init_2S_UART0(0);
;  1242         Init_B_UART0(1);  // Size Bits '8'
;  1243         Init_P_UART0(0);   // Parity    'N'
;  1244                           // Stop Bit  '1'
;  1245         Echo_OFF_UART0(); // Echo OFF
;  1246         ControlStream_OFF_UART0();      // Flow Control ON
;  1247         XON_XOFF_OFF_CONTR_Rx_UART0(); // Software Control OFF
;  1248         XON_XOFF_OFF_CONTR_Tx_UART0(); // Enable Tx Control
;  1249         /* Enable control hardware flow all signals */
;  1250          DSR_OFF_CONTR_UART0();  // Hardware Flow Control DSR
;  1251          DTR_OFF_CONTR_UART0();  // Hardware Flow Control DTR
;  1252          CTS_OFF_CONTR_UART0();  // Hardware Flow Control CTS
;  1253          RTS_OFF_CONTR_UART0();  // Hardware Flow Control RTS
;  1254          RTS_CLR_UART0();       // RTS0=0 Request to send
;  1255          DTR_CLR_UART0();       // DTR0=0 Data Terminal Ready
;  1256          CTS_CLR_UART0();
;  1257          DSR_CLR_UART0();
;  1258         /***********/
;  1259 
;  1260         Enable_Err_Count_UART0();
;  1261         i = 0;
;  1262 
;  1263         _SEI(); /* enable interrupts => enable UART interrupts */
;  1264         iRet = printf("Test ver 0.02 for file 'A1x.c' UART0 \n\r");
;  1265         if (Enb_XON_XOFF_Rx_UART0 !=  0)
;  1266         {
;  1267         iRet = printf("%c",Sym_XON);
;  1268         Count_XOFF_Rx_UART0 = 0;
;  1269         };                            // Enable Tx for Computer
;  1270 
;  1271                 /* test print */ 
;  1272            /*
;  1273                 x=1;
;  1274                 y='t';
;  1275                 z=1230.09876;
;  1276                 iRet = printf("%d",x); // yes                
;  1277                 iRet = printf("%c",y); // yes                
;  1278                 iRet = printf("%f",z); // no type "f" 
;  1279            */
;  1280                 /* end print */
;  1281 
;  1282 
;  1283         while ( 1 ) /* forever */
;  1284                {
;  1285 
;  1286                 /* test new function getchar() and prints stdin */
;  1287                 do 
;  1288                 { 
;  1289                   iByte = getchar_K();     // new size buffer 40 yes
;  1290                   iRet = printf("%c",toupper( (unsigned char) iByte));
;  1291                   if (iByte == 0x0A)  // ^J LF  
;  1292                   {
;  1293                   iRet = printf("\r");                  
;  1294                   };
;  1295                 }
;  1296                 while ( iByte != 0x0A); 
;  1297                  
;  1298                
;  1299                                 
;  1300               /* test function gets( array) */
;  1301               /* Error test
;  1302                 iRet =  (int) gets(test); 
;  1303                 if  ( iRet != 0 )
;  1304                 {
;  1305                 iRet = printf("%s",test);                
;  1306                 };
;  1307               */               
;  1308                
;  1309                 /* test counters errors */
;  1310                 
;  1311                 if (DataInReceiveBuffer()!=0)
;  1312                 {
;  1313                 //cByte = ReceiveByte_UART0();
;  1314                 //iRet = printf("%c",cByte); // yes
;  1315                   if ( i > 50)  // if 20 symbols Rx and Tx
;  1316                   {
;  1317                   //iRet = Read_Tx_Rx_Err_UART0();
;  1318                   i = 1;
;  1319                   };
;  1320                 i++;
;  1321                 };
;  1322 
;  1323                 //iByte = (int) cByte;
;  1324                 //putchar((int)cByte); // yes
;  1325                 //TransmitByte(cByte); /* echo the received character */
;  1326                 //putchar((int)cByte); // yes
;  1327                 //iRet = sprintf(p,"%ld",Count_Rx_UART0); // yes
;  1328                 //iRet = puts(p); // yes
;  1329                 //iRet = printf("\n\r Test main i="); // yes
;  1330                 //iRet = printf("%d", i); // yes
;  1331                 //iRet = printf("%ld",Count_Rx_UART0); // yes
;  1332             };
;  1333         }
;  1334 #endif
; 
;     10 bytes in segment ABSOLUTE
;   3316 bytes in segment CODE
;      1 byte  in segment EEPROM_I
;     12 bytes in segment INITTAB
;      8 bytes in segment INTVEC
;     24 bytes in segment NEAR_F
;     55 bytes in segment NEAR_I
;     55 bytes in segment NEAR_ID
;    138 bytes in segment NEAR_Z
; 
;   3403 bytes of CODE memory (+ 12 bytes shared)
;    193 bytes of DATA memory (+ 10 bytes shared)
;      1 byte  of XDATA memory
;
;Errors: none
;Warnings: 2
