##############################################################################
#                                                                            #
# IAR Atmel AVR C/EC++ Compiler V2.26N/WIN             01/Oct/2002  12:42:14 #
# Copyright 1996-2001 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Source file  =  C:\AVR_CC\UART_MOD\uart0_A1x.c                          #
#    Command line =  --cpu=m161 -ms -o C:\AVR_CC\MiniRobot_CODE\Debug\Obj\   #
#                    -I C:\AVR_CC\AVR\SRC\CLIB\INC\ -lC                      #
#                    C:\AVR_CC\MiniRobot_CODE\Debug\List\ -lA                #
#                    C:\AVR_CC\MiniRobot_CODE\Debug\List\ -e -y              #
#                    --initializers_in_flash -z3 --no_cse --no_inline        #
#                    --no_code_motion --no_cross_call --no_clustering        #
#                    --library_module --debug -DENABLE_BIT_DEFINITIONS       #
#                    C:\AVR_CC\UART_MOD\uart0_A1x.c                          #
#    List file    =  C:\AVR_CC\MiniRobot_CODE\Debug\List\uart0_A1x.lst       #
#    Object file  =  C:\AVR_CC\MiniRobot_CODE\Debug\Obj\uart0_A1x.r90        #
#                                                                            #
#                                                                            #
##############################################################################

      1          /*********************************************
      2          * Programm:       UART0_A1x.c                *
      3          *                                            *
      4          *  Note:  For projekt MINIROBIT BUILDING     *
      5          *                                            *
      6          * Name:  Module Code adapted from Atmel AVR  *
      7          *        Application for Amega161            *
      8          *        Interrupt mode driver for UART0.    *
      9          *                                            *
     10          * Edit data:     28.08.2002                  *
     11          * Last data:     1.10.2002                  *
     12          * Version:       0.02                        *
     13          **********************************************/
     14          
     15          #include "iom161.h"

   \                                 In segment ABSOLUTE, at 0x29
   \   union <unnamed> volatile __io _A_UBRR0;
   \                     _A_UBRR0:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x2a
   \   union <unnamed> volatile __io _A_UCSR0B;
   \                     _A_UCSR0B:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x2b
   \   union <unnamed> volatile __io _A_UCSR0A;
   \                     _A_UCSR0A:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x2c
   \   union <unnamed> volatile __io _A_UDR0;
   \                     _A_UDR0:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x30
   \   union <unnamed> volatile __io _A_PIND;
   \                     _A_PIND:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x31
   \   union <unnamed> volatile __io _A_DDRD;
   \                     _A_DDRD:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x32
   \   union <unnamed> volatile __io _A_PORTD;
   \                     _A_PORTD:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x34
   \   union <unnamed> volatile __io _A_DDRC;
   \                     _A_DDRC:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x35
   \   union <unnamed> volatile __io _A_PORTC;
   \                     _A_PORTC:
   \   00000000                              DS 1
     16          #include "uart0_A1x.h"
     17          #include "uart0_A1x_decl.h"

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned int const __flash fSpeedBaud_UART0;
   \                     fSpeedBaud_UART0:
   \   00000000   2580                       DW 9600

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fModeU2X0;
   \                     fModeU2X0:
   \   00000000   00                         DB 0

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fModeCHR90;
   \                     fModeCHR90:
   \   00000000   00                         DB 0

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fCheckParity_UART0;
   \                     fCheckParity_UART0:
   \   00000000   00                         DB 0

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fSizeBit_UART0;
   \                     fSizeBit_UART0:
   \   00000000   01                         DB 1

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fContrStream_UART0;
   \                     fContrStream_UART0:
   \   00000000   00                         DB 0

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fEnb_DTR0;
   \                     fEnb_DTR0:
   \   00000000   01                         DB 1

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fBit_DTR0;
   \                     fBit_DTR0:
   \   00000000   01                         DB 1

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fEnb_DSR0;
   \                     fEnb_DSR0:
   \   00000000   01                         DB 1

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fBit_DSR0;
   \                     fBit_DSR0:
   \   00000000   01                         DB 1

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fEnb_RTS0;
   \                     fEnb_RTS0:
   \   00000000   01                         DB 1

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fBit_RTS0;
   \                     fBit_RTS0:
   \   00000000   01                         DB 1

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fEnb_CTS0;
   \                     fEnb_CTS0:
   \   00000000   01                         DB 1

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fBit_CTS0;
   \                     fBit_CTS0:
   \   00000000   01                         DB 1

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fSym_XON;
   \                     fSym_XON:
   \   00000000   11                         DB 17

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fSym_XOFF;
   \                     fSym_XOFF:
   \   00000000   13                         DB 19

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fEnb_XON_XOFF_Tx_UART0;
   \                     fEnb_XON_XOFF_Tx_UART0:
   \   00000000   01                         DB 1

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fCount_XOFF_Tx_UART0;
   \                     fCount_XOFF_Tx_UART0:
   \   00000000   00                         DB 0

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fEnb_XON_XOFF_Rx_UART0;
   \                     fEnb_XON_XOFF_Rx_UART0:
   \   00000000   01                         DB 1

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fCount_XOFF_Rx_UART0;
   \                     fCount_XOFF_Rx_UART0:
   \   00000000   00                         DB 0

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fEnb_Echo_UART0;
   \                     fEnb_Echo_UART0:
   \   00000000   01                         DB 1

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fModeMPCM0;
   \                     fModeMPCM0:
   \   00000000   00                         DB 0

   \                                 In segment NEAR_F, align 1, keep-with-next
   \   unsigned char const __flash fEnb_Err_UART0;
   \                     fEnb_Err_UART0:
   \   00000000   00                         DB 0

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near A1x_y;
   \                     A1x_y:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned int volatile __near SpeedBaud_UART0;
   \                     SpeedBaud_UART0:
   \   00000000                              DS 2

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near ModeU2X0;
   \                     ModeU2X0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near ModeCHR90;
   \                     ModeCHR90:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near CheckParity_UART0;
   \                     CheckParity_UART0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near SizeBit_UART0;
   \                     SizeBit_UART0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near ContrStream_UART0;
   \                     ContrStream_UART0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Enb_DTR0;
   \                     Enb_DTR0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Bit_DTR0;
   \                     Bit_DTR0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Enb_DSR0;
   \                     Enb_DSR0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Bit_DSR0;
   \                     Bit_DSR0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Enb_RTS0;
   \                     Enb_RTS0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Bit_RTS0;
   \                     Bit_RTS0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Enb_CTS0;
   \                     Enb_CTS0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Bit_CTS0;
   \                     Bit_CTS0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Sym_XON;
   \                     Sym_XON:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Sym_XOFF;
   \                     Sym_XOFF:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Enb_XON_XOFF_Tx_UART0;
   \                     Enb_XON_XOFF_Tx_UART0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Count_XOFF_Rx_UART0;
   \                     Count_XOFF_Rx_UART0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Enb_XON_XOFF_Rx_UART0;
   \                     Enb_XON_XOFF_Rx_UART0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Count_XOFF_Tx_UART0;
   \                     Count_XOFF_Tx_UART0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Enb_Echo_UART0;
   \                     Enb_Echo_UART0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near ModeMPCM0;
   \                     ModeMPCM0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near Enb_Err_UART0;
   \                     Enb_Err_UART0:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x40
   \   00000000                              DS 1

   \                                 In segment EEPROM_I, align 1, keep-with-next
   \   unsigned char __eeprom S3e;
   \                     S3e:
   \   00000000   00                         DB 0

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char __near S4e;
   \                     S4e:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char __near S5e;
   \                     S5e:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char __near S16e;
   \                     S16e:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char __near S18e;
   \                     S18e:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char __near S21e;
   \                     S21e:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char __near S22e;
   \                     S22e:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char __near S23e;
   \                     S23e:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char __near S39e;
   \                     S39e:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned char __near S51e;
   \                     S51e:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near RxBuf_UART0[32];
   \                     RxBuf_UART0:
   \   00000000                              DS 32

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near RxHead_UART0;
   \                     RxHead_UART0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near RxTail_UART0;
   \                     RxTail_UART0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near TxBuf_UART0[32];
   \                     TxBuf_UART0:
   \   00000000                              DS 32

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near TxHead_UART0;
   \                     TxHead_UART0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned char volatile __near TxTail_UART0;
   \                     TxTail_UART0:
   \   00000000                              DS 1

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned int volatile __near Rx_Tx_Err_UART0[5];
   \                     Rx_Tx_Err_UART0:
   \   00000000                              DS 10

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned long volatile __near Count_Rx_UART0;
   \                     Count_Rx_UART0:
   \   00000000                              DS 4

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned long volatile __near Count_Rx_Err_UART0;
   \                     Count_Rx_Err_UART0:
   \   00000000                              DS 4

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned long volatile __near Count_Tx_UART0;
   \                     Count_Tx_UART0:
   \   00000000                              DS 4

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   static unsigned long volatile __near Count_Tx_Err_UART0;
   \                     Count_Tx_Err_UART0:
   \   00000000                              DS 4
     18          #include "stdio.h"
     19          #include "ctype.h"
     20          
     21          /* Debug test UART0 for module */
     22          // #define TEST_UART0
     23          
     24          
     25          /*---------------------*/
     26          /*  Start Rx/Tx UART0  */

   \                                 In segment CODE, align 2, keep-with-next
     27          void  Enb_UART0(void)       // Enable  Rx/Tx
     28          {
     29            UCSR0B = UCSR0B | (1<<TXEN0);  // TXEN0 = 1
   \   __nearfunc void Enb_UART0();
   \                     Enb_UART0:
   \   00000000   9A53                       SBI     0x0A,0x03
     30            UCSR0B = UCSR0B | (1<<RXEN0);  // RXEN0 = 1
   \   00000002   9A54                       SBI     0x0A,0x04
     31            UCSR0B = UCSR0B | (1<<RXCIE0); // RXCIE0= 1
   \   00000004   9A57                       SBI     0x0A,0x07
     32          }
   \   00000006   9508                       RET
     33          /*-------------------*/
     34          /*  Start Rx UART0  */

   \                                 In segment CODE, align 2, keep-with-next
     35          void  Enb_Rx_UART0(void)       // Enable  Rx
     36          {
     37            UCSR0B = UCSR0B | (1<<RXEN0);  // RXEN0 = 1
   \   __nearfunc void Enb_Rx_UART0();
   \                     Enb_Rx_UART0:
   \   00000000   9A54                       SBI     0x0A,0x04
     38            UCSR0B = UCSR0B | (1<<RXCIE0); // RXCIE0= 1
   \   00000002   9A57                       SBI     0x0A,0x07
     39          }
   \   00000004   9508                       RET
     40          
     41          /*-------------------*/
     42          /*  Start Tx UART0  */

   \                                 In segment CODE, align 2, keep-with-next
     43          void  Enb_Tx_UART0(void)       // Enable  Tx
     44          {
     45            UCSR0B = UCSR0B | (1<<TXEN0);  // TXEN0 = 1
   \   __nearfunc void Enb_Tx_UART0();
   \                     Enb_Tx_UART0:
   \   00000000   9A53                       SBI     0x0A,0x03
     46          }
   \   00000002   9508                       RET
     47          /*--------------------*/
     48          /*  Stop Rx/Tx UART0  */

   \                                 In segment CODE, align 2, keep-with-next
     49          void  Dis_UART0(void)       // Disable  Rx/Tx
     50          {
     51            UCSR0B = UCSR0B & ~(1<<TXEN0);  // TXEN0 = 0
   \   __nearfunc void Dis_UART0();
   \                     Dis_UART0:
   \   00000000   9853                       CBI     0x0A,0x03
     52            UCSR0B = UCSR0B & ~(1<<RXEN0);  // RXEN0 = 0
   \   00000002   9854                       CBI     0x0A,0x04
     53            UCSR0B = UCSR0B & ~(1<<RXCIE0); // RXCIE0 = 0
   \   00000004   9857                       CBI     0x0A,0x07
     54          }
   \   00000006   9508                       RET
     55          
     56          /*------------------*/
     57          /*  Stop  Rx UART0  */

   \                                 In segment CODE, align 2, keep-with-next
     58          void  Dis_Rx_UART0(void)       // Disable  Rx
     59          {
     60            UCSR0B = UCSR0B & ~(1<<RXEN0);  // RXEN0 = 0
   \   __nearfunc void Dis_Rx_UART0();
   \                     Dis_Rx_UART0:
   \   00000000   9854                       CBI     0x0A,0x04
     61            UCSR0B = UCSR0B & ~(1<<RXCIE0); // RXCIE0 = 0
   \   00000002   9857                       CBI     0x0A,0x07
     62          }
   \   00000004   9508                       RET
     63          
     64          /*--------------------*/
     65          /*  Stop   Tx UART0  */

   \                                 In segment CODE, align 2, keep-with-next
     66          void  Dis_Tx_UART0(void)       // Disable  Tx
     67          {
     68            UCSR0B = UCSR0B & ~(1<<TXEN0);  // TXEN0 = 0
   \   __nearfunc void Dis_Tx_UART0();
   \                     Dis_Tx_UART0:
   \   00000000   9853                       CBI     0x0A,0x03
     69          }
   \   00000002   9508                       RET
     70          
     71          
     72          /*--------------------------------*/
     73          /*  Copy Sets Variable UART0 mode */

   \                                 In segment CODE, align 2, keep-with-next
     74          void  CopySetsROM_UART0(void)       // Sets is Default
     75                {
     76            SpeedBaud_UART0 = fSpeedBaud_UART0;
   \   __nearfunc void CopySetsROM_UART0();
   \                     CopySetsROM_UART0:
   \   00000000   ....                       LDI     R30,LOW(fSpeedBaud_UART0)
   \   00000002   ....                       LDI     R31,(fSpeedBaud_UART0) >> 8
   \   00000004   9105                       LPM     R16,Z+
   \   00000006   9114                       LPM     R17,Z
   \   00000008   9731                       SBIW    R31 : R30,1
   \   0000000A   ....                       LDI     R30,LOW(SpeedBaud_UART0)
   \   0000000C   ....                       LDI     R31,(SpeedBaud_UART0) >> 8
   \   0000000E   8300                       ST      Z,R16
   \   00000010   8311                       STD     Z+1,R17
     77            ModeU2X0 = fModeU2X0;
   \   00000012   ....                       LDI     R30,LOW(fModeU2X0)
   \   00000014   ....                       LDI     R31,(fModeU2X0) >> 8
   \   00000016   9104                       LPM     R16,Z
   \   00000018   9300....                   STS     ModeU2X0,R16
     78            ModeCHR90 = fModeCHR90;
   \   0000001C   ....                       LDI     R30,LOW(fModeCHR90)
   \   0000001E   ....                       LDI     R31,(fModeCHR90) >> 8
   \   00000020   9104                       LPM     R16,Z
   \   00000022   9300....                   STS     ModeCHR90,R16
     79            CheckParity_UART0 = fCheckParity_UART0;
   \   00000026   ....                       LDI     R30,LOW(fCheckParity_UART0)
   \   00000028   ....                       LDI     R31,(fCheckParity_UART0) >> 8
   \   0000002A   9104                       LPM     R16,Z
   \   0000002C   9300....                   STS     CheckParity_UART0,R16
     80            SizeBit_UART0 = fSizeBit_UART0;
   \   00000030   ....                       LDI     R30,LOW(fSizeBit_UART0)
   \   00000032   ....                       LDI     R31,(fSizeBit_UART0) >> 8
   \   00000034   9104                       LPM     R16,Z
   \   00000036   9300....                   STS     SizeBit_UART0,R16
     81            ContrStream_UART0 = fContrStream_UART0;
   \   0000003A   ....                       LDI     R30,LOW(fContrStream_UART0)
   \   0000003C   ....                       LDI     R31,(fContrStream_UART0) >> 8
   \   0000003E   9104                       LPM     R16,Z
   \   00000040   9300....                   STS     ContrStream_UART0,R16
     82            Enb_DTR0 = fEnb_DTR0;
   \   00000044   ....                       LDI     R30,LOW(fEnb_DTR0)
   \   00000046   ....                       LDI     R31,(fEnb_DTR0) >> 8
   \   00000048   9104                       LPM     R16,Z
   \   0000004A   9300....                   STS     Enb_DTR0,R16
     83            Bit_DTR0 = fBit_DTR0;
   \   0000004E   ....                       LDI     R30,LOW(fBit_DTR0)
   \   00000050   ....                       LDI     R31,(fBit_DTR0) >> 8
   \   00000052   9104                       LPM     R16,Z
   \   00000054   9300....                   STS     Bit_DTR0,R16
     84            Enb_DSR0 = fEnb_DSR0;
   \   00000058   ....                       LDI     R30,LOW(fEnb_DSR0)
   \   0000005A   ....                       LDI     R31,(fEnb_DSR0) >> 8
   \   0000005C   9104                       LPM     R16,Z
   \   0000005E   9300....                   STS     Enb_DSR0,R16
     85            Bit_DSR0 = fBit_DSR0;
   \   00000062   ....                       LDI     R30,LOW(fBit_DSR0)
   \   00000064   ....                       LDI     R31,(fBit_DSR0) >> 8
   \   00000066   9104                       LPM     R16,Z
   \   00000068   9300....                   STS     Bit_DSR0,R16
     86            Enb_RTS0 = fEnb_RTS0;
   \   0000006C   ....                       LDI     R30,LOW(fEnb_RTS0)
   \   0000006E   ....                       LDI     R31,(fEnb_RTS0) >> 8
   \   00000070   9104                       LPM     R16,Z
   \   00000072   9300....                   STS     Enb_RTS0,R16
     87            Bit_RTS0 = fBit_RTS0;
   \   00000076   ....                       LDI     R30,LOW(fBit_RTS0)
   \   00000078   ....                       LDI     R31,(fBit_RTS0) >> 8
   \   0000007A   9104                       LPM     R16,Z
   \   0000007C   9300....                   STS     Bit_RTS0,R16
     88            Enb_CTS0 = fEnb_CTS0;
   \   00000080   ....                       LDI     R30,LOW(fEnb_CTS0)
   \   00000082   ....                       LDI     R31,(fEnb_CTS0) >> 8
   \   00000084   9104                       LPM     R16,Z
   \   00000086   9300....                   STS     Enb_CTS0,R16
     89            Bit_CTS0 = fBit_CTS0;
   \   0000008A   ....                       LDI     R30,LOW(fBit_CTS0)
   \   0000008C   ....                       LDI     R31,(fBit_CTS0) >> 8
   \   0000008E   9104                       LPM     R16,Z
   \   00000090   9300....                   STS     Bit_CTS0,R16
     90            Sym_XON = fSym_XON;
   \   00000094   ....                       LDI     R30,LOW(fSym_XON)
   \   00000096   ....                       LDI     R31,(fSym_XON) >> 8
   \   00000098   9104                       LPM     R16,Z
   \   0000009A   9300....                   STS     Sym_XON,R16
     91            Sym_XOFF= fSym_XOFF;
   \   0000009E   ....                       LDI     R30,LOW(fSym_XOFF)
   \   000000A0   ....                       LDI     R31,(fSym_XOFF) >> 8
   \   000000A2   9104                       LPM     R16,Z
   \   000000A4   9300....                   STS     Sym_XOFF,R16
     92            Enb_XON_XOFF_Tx_UART0 = fEnb_XON_XOFF_Tx_UART0;
   \   000000A8   ....                       LDI     R30,LOW(fEnb_XON_XOFF_Tx_UART0)
   \   000000AA   ....                       LDI     R31,(fEnb_XON_XOFF_Tx_UART0) >> 8
   \   000000AC   9104                       LPM     R16,Z
   \   000000AE   9300....                   STS     Enb_XON_XOFF_Tx_UART0,R16
     93            Count_XOFF_Tx_UART0 = fCount_XOFF_Tx_UART0;
   \   000000B2   ....                       LDI     R30,LOW(fCount_XOFF_Tx_UART0)
   \   000000B4   ....                       LDI     R31,(fCount_XOFF_Tx_UART0) >> 8
   \   000000B6   9104                       LPM     R16,Z
   \   000000B8   9300....                   STS     Count_XOFF_Tx_UART0,R16
     94            Enb_XON_XOFF_Rx_UART0 = fEnb_XON_XOFF_Rx_UART0;
   \   000000BC   ....                       LDI     R30,LOW(fEnb_XON_XOFF_Rx_UART0)
   \   000000BE   ....                       LDI     R31,(fEnb_XON_XOFF_Rx_UART0) >> 8
   \   000000C0   9104                       LPM     R16,Z
   \   000000C2   9300....                   STS     Enb_XON_XOFF_Rx_UART0,R16
     95            Count_XOFF_Rx_UART0 = fCount_XOFF_Rx_UART0;
   \   000000C6   ....                       LDI     R30,LOW(fCount_XOFF_Rx_UART0)
   \   000000C8   ....                       LDI     R31,(fCount_XOFF_Rx_UART0) >> 8
   \   000000CA   9104                       LPM     R16,Z
   \   000000CC   9300....                   STS     Count_XOFF_Rx_UART0,R16
     96            Enb_Echo_UART0 = fEnb_Echo_UART0 ;
   \   000000D0   ....                       LDI     R30,LOW(fEnb_Echo_UART0)
   \   000000D2   ....                       LDI     R31,(fEnb_Echo_UART0) >> 8
   \   000000D4   9104                       LPM     R16,Z
   \   000000D6   9300....                   STS     Enb_Echo_UART0,R16
     97            ModeMPCM0 = fModeMPCM0;
   \   000000DA   ....                       LDI     R30,LOW(fModeMPCM0)
   \   000000DC   ....                       LDI     R31,(fModeMPCM0) >> 8
   \   000000DE   9104                       LPM     R16,Z
   \   000000E0   9300....                   STS     ModeMPCM0,R16
     98            Enb_Err_UART0 = fEnb_Err_UART0;
   \   000000E4   ....                       LDI     R30,LOW(fEnb_Err_UART0)
   \   000000E6   ....                       LDI     R31,(fEnb_Err_UART0) >> 8
   \   000000E8   9104                       LPM     R16,Z
   \   000000EA   9300....                   STS     Enb_Err_UART0,R16
     99            }
   \   000000EE   9508                       RET
    100          
    101          /*--------------------------------*/
    102          /*  Copy Sets Variable UART0 mode */

   \                                 In segment CODE, align 2, keep-with-next
    103          void  CopySetsEEPROM_UART0(void)    // Sets is Profile EEPROM
    104                {}
   \   __nearfunc void CopySetsEEPROM_UART0();
   \                     CopySetsEEPROM_UART0:
   \   00000000   9508                       RET
    105          
    106          /*------------------*/
    107          /*  Init UART0 mode */

   \                                 In segment CODE, align 2, keep-with-next
    108          void    Init_S_UART0  ( unsigned int SpeedBaund )  // speed  UART0
    109                  {
   \   __nearfunc void Init_S_UART0(unsigned int);
   \                     Init_S_UART0:
   \   00000000   ........                   CALL    ?PROLOGUE3_L09
   \   00000004   9726                       SBIW    R29 : R28,6
   \   00000006   01C8                       MOVW    R25 : R24,R17 : R16
    110              volatile char FlagErr;
    111              volatile unsigned char cTmp;
    112              volatile unsigned long lTmp;
    113          
    114              Dis_UART0();
   \   00000008   ....                       RCALL   Dis_UART0
    115              FlagErr = 1; // Set Flag Error
   \   0000000A   E001                       LDI     R16,1
   \   0000000C   8309                       STD     Y+1,R16
    116              cTmp = UCSR0A & 0x02; // Real bit mode U2X0 in reg UCSR0A
   \   0000000E   B10B                       IN      R16,0x0B
   \   00000010   7002                       ANDI    R16,0x02
   \   00000012   8308                       ST      Y,R16
    117              switch (SpeedBaund)
   \   00000014   01FC                       MOVW    R31 : R30,R25 : R24
   \   00000016   50E0                       SUBI    R30,0
   \   00000018   49F6                       SBCI    R31,150
   \   0000001A   F0C9                       BREQ    ??Init_S_UART0_0
   \   0000001C   50E0                       SUBI    R30,0
   \   0000001E   44FB                       SBCI    R31,75
   \   00000020   F0B1                       BREQ    ??Init_S_UART0_0
   \   00000022   52EC                       SUBI    R30,44
   \   00000024   42F0                       SBCI    R31,32
   \   00000026   F099                       BREQ    ??Init_S_UART0_0
   \   00000028   52EC                       SUBI    R30,44
   \   0000002A   40F1                       SBCI    R31,1
   \   0000002C   F081                       BREQ    ??Init_S_UART0_0
   \   0000002E   55E8                       SUBI    R30,88
   \   00000030   40F2                       SBCI    R31,2
   \   00000032   F069                       BREQ    ??Init_S_UART0_0
   \   00000034   5BE0                       SUBI    R30,176
   \   00000036   40F4                       SBCI    R31,4
   \   00000038   F051                       BREQ    ??Init_S_UART0_0
   \   0000003A   56E0                       SUBI    R30,96
   \   0000003C   40F9                       SBCI    R31,9
   \   0000003E   F039                       BREQ    ??Init_S_UART0_0
   \   00000040   5CE0                       SUBI    R30,192
   \   00000042   41F2                       SBCI    R31,18
   \   00000044   F021                       BREQ    ??Init_S_UART0_0
   \   00000046   58E0                       SUBI    R30,128
   \   00000048   42F5                       SBCI    R31,37
   \   0000004A   F009                       BREQ    ??Init_S_UART0_1
   \   0000004C   C053                       RJMP    ??Init_S_UART0_2
    118                {
    119                case 300:
    120                case 600:
    121                case 1200:
    122                case 2400:
    123                case 4800:
    124                case 9600:
    125                case 19200:
    126                case 38400:
    127                case 57600:
    128                if ( cTmp == 0)
   \                     ??Init_S_UART0_1:
   \                     ??Init_S_UART0_0:
   \   0000004E   8108                       LD      R16,Y
   \   00000050   2300                       TST     R16
   \   00000052   F531                       BRNE    ??Init_S_UART0_3
    129                  {   // calculate UBR for On Speed Mode
    130                   lTmp = (unsigned long)FQCK / 16 / (unsigned long)SpeedBaund - 1;
   \   00000054   E000                       LDI     R16,0
   \   00000056   E018                       LDI     R17,8
   \   00000058   E027                       LDI     R18,7
   \   0000005A   E030                       LDI     R19,0
   \   0000005C   01AC                       MOVW    R21 : R20,R25 : R24
   \   0000005E   E060                       LDI     R22,0
   \   00000060   E070                       LDI     R23,0
   \   00000062   ........                   CALL    ?UL_DIVMOD_L03
   \   00000066   5001                       SUBI    R16,1
   \   00000068   4010                       SBCI    R17,0
   \   0000006A   4020                       SBCI    R18,0
   \   0000006C   4030                       SBCI    R19,0
   \   0000006E   830A                       STD     Y+2,R16
   \   00000070   831B                       STD     Y+3,R17
   \   00000072   832C                       STD     Y+4,R18
   \   00000074   833D                       STD     Y+5,R19
    131                   UBRR0 =(unsigned char)lTmp;                  // low byte UBR
   \   00000076   810A                       LDD     R16,Y+2
   \   00000078   811B                       LDD     R17,Y+3
   \   0000007A   812C                       LDD     R18,Y+4
   \   0000007C   813D                       LDD     R19,Y+5
   \   0000007E   B909                       OUT     0x09,R16
    132                   UBRH.uh0 = (unsigned char)(lTmp / 256);     // high byte UBR
   \   00000080   810A                       LDD     R16,Y+2
   \   00000082   811B                       LDD     R17,Y+3
   \   00000084   812C                       LDD     R18,Y+4
   \   00000086   813D                       LDD     R19,Y+5
   \   00000088   B5A0                       IN      R26,0x20
   \   0000008A   7FA0                       ANDI    R26,0xF0
   \   0000008C   E040                       LDI     R20,0
   \   0000008E   E051                       LDI     R21,1
   \   00000090   E060                       LDI     R22,0
   \   00000092   E070                       LDI     R23,0
   \   00000094   ........                   CALL    ?UL_DIVMOD_L03
   \   00000098   700F                       ANDI    R16,0x0F
   \   0000009A   2B0A                       OR      R16,R26
   \   0000009C   BD00                       OUT     0x20,R16
   \   0000009E   C025                       RJMP    ??Init_S_UART0_4
    133                   }
    134                else
    135                  {   // calculate UBR for Double Speed Mode
    136                   lTmp = (unsigned long)FQCK / 8 / (unsigned long)SpeedBaund - 1;
   \                     ??Init_S_UART0_3:
   \   000000A0   E000                       LDI     R16,0
   \   000000A2   E110                       LDI     R17,16
   \   000000A4   E02E                       LDI     R18,14
   \   000000A6   E030                       LDI     R19,0
   \   000000A8   01AC                       MOVW    R21 : R20,R25 : R24
   \   000000AA   E060                       LDI     R22,0
   \   000000AC   E070                       LDI     R23,0
   \   000000AE   ........                   CALL    ?UL_DIVMOD_L03
   \   000000B2   5001                       SUBI    R16,1
   \   000000B4   4010                       SBCI    R17,0
   \   000000B6   4020                       SBCI    R18,0
   \   000000B8   4030                       SBCI    R19,0
   \   000000BA   830A                       STD     Y+2,R16
   \   000000BC   831B                       STD     Y+3,R17
   \   000000BE   832C                       STD     Y+4,R18
   \   000000C0   833D                       STD     Y+5,R19
    137                   UBRR0 =(unsigned char)lTmp;                  // low byte UBR
   \   000000C2   810A                       LDD     R16,Y+2
   \   000000C4   811B                       LDD     R17,Y+3
   \   000000C6   812C                       LDD     R18,Y+4
   \   000000C8   813D                       LDD     R19,Y+5
   \   000000CA   B909                       OUT     0x09,R16
    138                   UBRH.uh0 = (unsigned char)(lTmp / 256);     // high byte UBR
   \   000000CC   810A                       LDD     R16,Y+2
   \   000000CE   811B                       LDD     R17,Y+3
   \   000000D0   812C                       LDD     R18,Y+4
   \   000000D2   813D                       LDD     R19,Y+5
   \   000000D4   B5A0                       IN      R26,0x20
   \   000000D6   7FA0                       ANDI    R26,0xF0
   \   000000D8   E040                       LDI     R20,0
   \   000000DA   E051                       LDI     R21,1
   \   000000DC   E060                       LDI     R22,0
   \   000000DE   E070                       LDI     R23,0
   \   000000E0   ........                   CALL    ?UL_DIVMOD_L03
   \   000000E4   700F                       ANDI    R16,0x0F
   \   000000E6   2B0A                       OR      R16,R26
   \   000000E8   BD00                       OUT     0x20,R16
    139                   };
    140                SpeedBaud_UART0 = SpeedBaund;
   \                     ??Init_S_UART0_4:
   \   000000EA   ....                       LDI     R30,LOW(SpeedBaud_UART0)
   \   000000EC   ....                       LDI     R31,(SpeedBaud_UART0) >> 8
   \   000000EE   8380                       ST      Z,R24
   \   000000F0   8391                       STD     Z+1,R25
   \   000000F2   C002                       RJMP    ??Init_S_UART0_5
    141                break;
    142                default:
    143                  // if error speed store old speed
    144                  FlagErr = 0;
   \                     ??Init_S_UART0_2:
   \   000000F4   E000                       LDI     R16,0
   \   000000F6   8309                       STD     Y+1,R16
    145                break;
    146                };
    147              Enb_UART0();
   \                     ??Init_S_UART0_5:
   \   000000F8   ....                       RCALL   Enb_UART0
    148              }
   \   000000FA   9626                       ADIW    R29 : R28,6
   \   000000FC   E0E3                       LDI     R30,3
   \   000000FE   ........                   JMP     ?EPILOGUE_B3_L09
    149          

   \                                 In segment CODE, align 2, keep-with-next
    150          void    Init_2S_UART0 ( unsigned char ModeU2X0 )        // baud*2 UART0
    151                  {
   \   __nearfunc void Init_2S_UART0(unsigned char);
   \                     Init_2S_UART0:
   \   00000000   938A                       ST      -Y,R24
   \   00000002   2F80                       MOV     R24,R16
    152                  Dis_UART0();
   \   00000004   ....                       RCALL   Dis_UART0
    153                  if ( ModeU2X0 == 0)          // if ModeU2X0=0 then U2X0=0
   \   00000006   2388                       TST     R24
   \   00000008   F439                       BRNE    ??Init_2S_UART0_0
    154                    {                          // else U2X0=1
    155                    UCSR0A = UCSR0A & ~(0x02);
   \   0000000A   9859                       CBI     0x0B,0x01
    156                    Init_S_UART0(SpeedBaud_UART0); // UART0 is 1*SpeedBaund
   \   0000000C   ....                       LDI     R30,LOW(SpeedBaud_UART0)
   \   0000000E   ....                       LDI     R31,(SpeedBaud_UART0) >> 8
   \   00000010   8100                       LD      R16,Z
   \   00000012   8111                       LDD     R17,Z+1
   \   00000014   ....                       RCALL   Init_S_UART0
   \   00000016   C007                       RJMP    ??Init_2S_UART0_1
    157                    }
    158                  else
    159                    {
    160                    UCSR0A = UCSR0A & ~(0x02);
   \                     ??Init_2S_UART0_0:
   \   00000018   9859                       CBI     0x0B,0x01
    161                    Init_S_UART0(SpeedBaud_UART0);
   \   0000001A   ....                       LDI     R30,LOW(SpeedBaud_UART0)
   \   0000001C   ....                       LDI     R31,(SpeedBaud_UART0) >> 8
   \   0000001E   8100                       LD      R16,Z
   \   00000020   8111                       LDD     R17,Z+1
   \   00000022   ....                       RCALL   Init_S_UART0
    162                    UCSR0A = UCSR0A | (0x02); // UART0 is 2*SpeedBaund
   \   00000024   9A59                       SBI     0x0B,0x01
    163                    };
    164                  Enb_UART0();
   \                     ??Init_2S_UART0_1:
   \   00000026   ....                       RCALL   Enb_UART0
    165                  }
   \   00000028   9189                       LD      R24,Y+
   \   0000002A   9508                       RET

   \                                 In segment CODE, align 2, keep-with-next
    166          void    Init_P_UART0  ( unsigned char Parity ) // control parity
    167                  {
   \   __nearfunc void Init_P_UART0(unsigned char);
   \                     Init_P_UART0:
   \   00000000   938A                       ST      -Y,R24
   \   00000002   2F80                       MOV     R24,R16
    168                  Dis_UART0();
   \   00000004   ....                       RCALL   Dis_UART0
    169                  switch ( Parity )
   \   00000006   2F08                       MOV     R16,R24
   \   00000008   5000                       SUBI    R16,0
   \   0000000A   F029                       BREQ    ??Init_P_UART0_0
   \   0000000C   5001                       SUBI    R16,1
   \   0000000E   F0C8                       BRCS    ??Init_P_UART0_1
   \   00000010   5004                       SUBI    R16,4
   \   00000012   F030                       BRCS    ??Init_P_UART0_2
   \   00000014   C016                       RJMP    ??Init_P_UART0_1
    170                    {
    171                    case 0:
    172                    Init_CHR9_UART0(0); // Mode 8 bits
   \                     ??Init_P_UART0_0:
   \   00000016   E000                       LDI     R16,0
   \   00000018   ....                       RCALL   Init_CHR9_UART0
    173                    CheckParity_UART0 = Parity;
   \   0000001A   9380....                   STS     CheckParity_UART0,R24
   \   0000001E   C016                       RJMP    ??Init_P_UART0_3
    174                    break;
    175                    case 1:
    176                    case 2:
    177                    case 3:
    178                    case 4:
    179                    CheckParity_UART0 = Parity;
   \                     ??Init_P_UART0_2:
   \   00000020   9380....                   STS     CheckParity_UART0,R24
    180                        switch ( SizeBit_UART0 )
   \   00000024   9100....                   LDS     R16,SizeBit_UART0
   \   00000028   5000                       SUBI    R16,0
   \   0000002A   F019                       BREQ    ??Init_P_UART0_4
   \   0000002C   950A                       DEC     R16
   \   0000002E   F019                       BREQ    ??Init_P_UART0_5
   \   00000030   C005                       RJMP    ??Init_P_UART0_6
    181                              {
    182                              case 0:
    183                              Init_CHR9_UART0(0); // Mode 8 bits
   \                     ??Init_P_UART0_4:
   \   00000032   E000                       LDI     R16,0
   \   00000034   ....                       RCALL   Init_CHR9_UART0
    184                              case 1:
    185                              Init_CHR9_UART0(1); // Mode 9 bits
   \                     ??Init_P_UART0_5:
   \   00000036   E001                       LDI     R16,1
   \   00000038   ....                       RCALL   Init_CHR9_UART0
   \   0000003A   C008                       RJMP    ??Init_P_UART0_3
    186                              break;
    187                              default:
    188                              Init_CHR9_UART0(0); // Mode 8 bits
   \                     ??Init_P_UART0_6:
   \   0000003C   E000                       LDI     R16,0
   \   0000003E   ....                       RCALL   Init_CHR9_UART0
   \   00000040   C005                       RJMP    ??Init_P_UART0_3
    189                              break;
    190                              };
    191                    break;
    192                    default:
    193                    CheckParity_UART0 = 0;
   \                     ??Init_P_UART0_1:
   \   00000042   E000                       LDI     R16,0
   \   00000044   9300....                   STS     CheckParity_UART0,R16
    194                    Init_CHR9_UART0(0); // Mode 8 bits
   \   00000048   E000                       LDI     R16,0
   \   0000004A   ....                       RCALL   Init_CHR9_UART0
    195                    break;
    196                    };
    197                  Enb_UART0();
   \                     ??Init_P_UART0_3:
   \   0000004C   ....                       RCALL   Enb_UART0
    198                  }
   \   0000004E   9189                       LD      R24,Y+
   \   00000050   9508                       RET
    199          

   \                                 In segment CODE, align 2, keep-with-next
    200          void    Init_B_UART0  ( unsigned char SizeBit )
    201                  {
   \   __nearfunc void Init_B_UART0(unsigned char);
   \                     Init_B_UART0:
   \   00000000   938A                       ST      -Y,R24
   \   00000002   2F80                       MOV     R24,R16
    202                  Dis_UART0();
   \   00000004   ....                       RCALL   Dis_UART0
    203                  switch ( SizeBit )
   \   00000006   2F08                       MOV     R16,R24
   \   00000008   5000                       SUBI    R16,0
   \   0000000A   F011                       BREQ    ??Init_B_UART0_0
   \   0000000C   950A                       DEC     R16
   \   0000000E   F419                       BRNE    ??Init_B_UART0_1
    204                    {
    205                    case 0:
    206                    case 1:
    207                    SizeBit_UART0 = SizeBit;
   \                     ??Init_B_UART0_0:
   \   00000010   9380....                   STS     SizeBit_UART0,R24
   \   00000014   C003                       RJMP    ??Init_B_UART0_2
    208                    break;
    209                    default:
    210                    SizeBit_UART0 = 1;    // SizeBit 8 bits
   \                     ??Init_B_UART0_1:
   \   00000016   E001                       LDI     R16,1
   \   00000018   9300....                   STS     SizeBit_UART0,R16
    211                    break;
    212                    };
    213                  Enb_UART0();
   \                     ??Init_B_UART0_2:
   \   0000001C   ....                       RCALL   Enb_UART0
    214                  }
   \   0000001E   9189                       LD      R24,Y+
   \   00000020   9508                       RET
    215          

   \                                 In segment CODE, align 2, keep-with-next
    216          void    Init_CHR9_UART0 ( unsigned char Mode )     // Rx/Tx 8 or 9 bits
    217                  {
    218                  switch ( Mode)
   \   __nearfunc void Init_CHR9_UART0(unsigned char);
   \                     Init_CHR9_UART0:
   \   00000000   2F10                       MOV     R17,R16
   \   00000002   5010                       SUBI    R17,0
   \   00000004   F019                       BREQ    ??Init_CHR9_UART0_0
   \   00000006   951A                       DEC     R17
   \   00000008   F031                       BREQ    ??Init_CHR9_UART0_1
   \   0000000A   C00A                       RJMP    ??Init_CHR9_UART0_2
    219                    {
    220                    case 0:
    221                      UCSR0B = UCSR0B & ~(0x04); // Mode 8 bit Rx/Tx
   \                     ??Init_CHR9_UART0_0:
   \   0000000C   9852                       CBI     0x0A,0x02
    222                      UCSR0B = UCSR0B & ~(0x01); // Set 9 bit = 0
   \   0000000E   9850                       CBI     0x0A,0x00
    223                      ModeCHR90 = Mode;
   \   00000010   9300....                   STS     ModeCHR90,R16
   \   00000014   9508                       RET
    224                    break;
    225                    case 1:
    226                      UCSR0B = UCSR0B | (0x04); // Mode 9 bit Rx/Tx
   \                     ??Init_CHR9_UART0_1:
   \   00000016   9A52                       SBI     0x0A,0x02
    227                      UCSR0B = UCSR0B | (0x01);  // Set 9 bit = 1
   \   00000018   9A50                       SBI     0x0A,0x00
    228                      ModeCHR90 = Mode;
   \   0000001A   9300....                   STS     ModeCHR90,R16
   \   0000001E   9508                       RET
    229                    break;
    230                    default:
    231                      UCSR0B = UCSR0B & ~(0x04); // Mode 8 bit Rx/Tx
   \                     ??Init_CHR9_UART0_2:
   \   00000020   9852                       CBI     0x0A,0x02
    232                      UCSR0B = UCSR0B & ~(0x01); // Set 9 bit = 0
   \   00000022   9850                       CBI     0x0A,0x00
    233                      ModeCHR90 = 0;
   \   00000024   E000                       LDI     R16,0
   \   00000026   9300....                   STS     ModeCHR90,R16
    234                    break;
    235                    };
    236                  }
   \   0000002A   9508                       RET
    237          

   \                                 In segment CODE, align 2, keep-with-next
    238          void    Init_MPCM_UART0 ( unsigned char ModeMPCM0 )     // Mode Multi-processor Com port
    239                  {
   \   __nearfunc void Init_MPCM_UART0(unsigned char);
   \                     Init_MPCM_UART0:
   \   00000000   938A                       ST      -Y,R24
   \   00000002   2F80                       MOV     R24,R16
    240                  Dis_UART0();
   \   00000004   ....                       RCALL   Dis_UART0
    241                  if ( ModeMPCM0 == 0)
   \   00000006   2388                       TST     R24
   \   00000008   F411                       BRNE    ??Init_MPCM_UART0_0
    242                  {
    243                 UCSR0A = UCSR0A & ~(0x01); // Mode MPCM0 for Rx/Tx
   \   0000000A   9858                       CBI     0x0B,0x00
   \   0000000C   C001                       RJMP    ??Init_MPCM_UART0_1
    244                  }
    245                  else
    246                  {
    247                 UCSR0A = UCSR0A | (0x01); // Mode MPCM0 for Rx/Tx
   \                     ??Init_MPCM_UART0_0:
   \   0000000E   9A58                       SBI     0x0B,0x00
    248                  };
    249                  Enb_UART0();
   \                     ??Init_MPCM_UART0_1:
   \   00000010   ....                       RCALL   Enb_UART0
    250                  }
   \   00000012   9189                       LD      R24,Y+
   \   00000014   9508                       RET
    251          
    252          /*------------------------------------------*/
    253          /*               Reset UART                 */

   \                                 In segment CODE, align 2, keep-with-next
    254          void  Reset_UART0 ( void )   // Reset UART0 Status A1x.y0
    255                {
   \   __nearfunc void Reset_UART0();
   \                     Reset_UART0:
   \   00000000   939A                       ST      -Y,R25
   \   00000002   938A                       ST      -Y,R24
   \   00000004   9723                       SBIW    R29 : R28,3
    256              volatile unsigned char cTmp;
    257              volatile int i;
    258              /* Sets out pins   DTR0=1, RTS0=1 */
    259              cTmp = DDRC ^ ( 1+4 );   // Mode Pins to Out
   \   00000006   B314                       IN      R17,0x14
   \   00000008   E005                       LDI     R16,5
   \   0000000A   2701                       EOR     R16,R17
   \   0000000C   830A                       STD     Y+2,R16
    260              DDRC = cTmp;
   \   0000000E   810A                       LDD     R16,Y+2
   \   00000010   BB04                       OUT     0x14,R16
    261              cTmp = PORTC ^ ( 1+4 ); // Pins Out bits
   \   00000012   B315                       IN      R17,0x15
   \   00000014   E005                       LDI     R16,5
   \   00000016   2701                       EOR     R16,R17
   \   00000018   830A                       STD     Y+2,R16
    262              PORTC = cTmp ;
   \   0000001A   810A                       LDD     R16,Y+2
   \   0000001C   BB05                       OUT     0x15,R16
    263              /* Programm state SYSTEM RESET */
    264              UCSR0B=0x02;              // Disable UART0 Rx/Tx
   \   0000001E   E002                       LDI     R16,2
   \   00000020   B90A                       OUT     0x0A,R16
    265              cTmp = UDR0;              // Clear ERROR Resiverd
   \   00000022   B10C                       IN      R16,0x0C
   \   00000024   830A                       STD     Y+2,R16
    266              UCSR0A=0x20;              // Erase Errors
   \   00000026   E200                       LDI     R16,32
   \   00000028   B90B                       OUT     0x0B,R16
    267              UBRH.uh0=0x00;
   \   0000002A   B500                       IN      R16,0x20
   \   0000002C   7F00                       ANDI    R16,0xF0
   \   0000002E   BD00                       OUT     0x20,R16
    268              UBRR0=0x0;
   \   00000030   E000                       LDI     R16,0
   \   00000032   B909                       OUT     0x09,R16
    269              /* Erase all variables  */
    270              /* Erase Buffer Tx */
    271              for (i=1;i<=TX_BUFFER_SIZE_UART0;i++)
   \   00000034   E001                       LDI     R16,1
   \   00000036   E010                       LDI     R17,0
   \   00000038   8308                       ST      Y,R16
   \   0000003A   8319                       STD     Y+1,R17
   \   0000003C   C00D                       RJMP    ??Reset_UART0_0
    272                {
    273                TxBuf_UART0[i] = 0;         // Buffer Tx Erase
   \                     ??Reset_UART0_1:
   \   0000003E   E000                       LDI     R16,0
   \   00000040   8128                       LD      R18,Y
   \   00000042   8139                       LDD     R19,Y+1
   \   00000044   01F9                       MOVW    R31 : R30,R19 : R18
   \   00000046   ....                       SUBI    R30,LOW((-(TxBuf_UART0) & 0xFFFF))
   \   00000048   ....                       SBCI    R31,(-(TxBuf_UART0) & 0xFFFF) >> 8
   \   0000004A   8300                       ST      Z,R16
   \   0000004C   8108                       LD      R16,Y
   \   0000004E   8119                       LDD     R17,Y+1
   \   00000050   5F0F                       SUBI    R16,255
   \   00000052   4F1F                       SBCI    R17,255
   \   00000054   8308                       ST      Y,R16
   \   00000056   8319                       STD     Y+1,R17
   \                     ??Reset_UART0_0:
   \   00000058   8188                       LD      R24,Y
   \   0000005A   8199                       LDD     R25,Y+1
   \   0000005C   3281                       CPI     R24,33
   \   0000005E   4090                       SBCI    R25,0
   \   00000060   F374                       BRLT    ??Reset_UART0_1
    274                };
    275              TxHead_UART0 = 0;             // Head Top
   \   00000062   E000                       LDI     R16,0
   \   00000064   9300....                   STS     TxHead_UART0,R16
    276              TxTail_UART0 = 0;             // Tail Top
   \   00000068   E000                       LDI     R16,0
   \   0000006A   9300....                   STS     TxTail_UART0,R16
    277              /* Erase Buffer Rx */
    278              for (i=1;i<=RX_BUFFER_SIZE_UART0;i++)
   \   0000006E   E001                       LDI     R16,1
   \   00000070   E010                       LDI     R17,0
   \   00000072   8308                       ST      Y,R16
   \   00000074   8319                       STD     Y+1,R17
   \   00000076   C00D                       RJMP    ??Reset_UART0_2
    279                {
    280                RxBuf_UART0[i] = 0;         // Buffer Rx Erase
   \                     ??Reset_UART0_3:
   \   00000078   E000                       LDI     R16,0
   \   0000007A   8128                       LD      R18,Y
   \   0000007C   8139                       LDD     R19,Y+1
   \   0000007E   01F9                       MOVW    R31 : R30,R19 : R18
   \   00000080   ....                       SUBI    R30,LOW((-(RxBuf_UART0) & 0xFFFF))
   \   00000082   ....                       SBCI    R31,(-(RxBuf_UART0) & 0xFFFF) >> 8
   \   00000084   8300                       ST      Z,R16
   \   00000086   8108                       LD      R16,Y
   \   00000088   8119                       LDD     R17,Y+1
   \   0000008A   5F0F                       SUBI    R16,255
   \   0000008C   4F1F                       SBCI    R17,255
   \   0000008E   8308                       ST      Y,R16
   \   00000090   8319                       STD     Y+1,R17
   \                     ??Reset_UART0_2:
   \   00000092   8188                       LD      R24,Y
   \   00000094   8199                       LDD     R25,Y+1
   \   00000096   3281                       CPI     R24,33
   \   00000098   4090                       SBCI    R25,0
   \   0000009A   F374                       BRLT    ??Reset_UART0_3
    281                };
    282              RxHead_UART0 = 0;             // Head Top
   \   0000009C   E000                       LDI     R16,0
   \   0000009E   9300....                   STS     RxHead_UART0,R16
    283              RxTail_UART0 = 0;             // Tail Top
   \   000000A2   E000                       LDI     R16,0
   \   000000A4   9300....                   STS     RxTail_UART0,R16
    284              /* Erase Array Errors Rx/Tx */
    285              for (i=1;i<=Rx_Tx_Err_SIZE_UART0;i++)
   \   000000A8   E001                       LDI     R16,1
   \   000000AA   E010                       LDI     R17,0
   \   000000AC   8308                       ST      Y,R16
   \   000000AE   8319                       STD     Y+1,R17
   \   000000B0   C013                       RJMP    ??Reset_UART0_4
    286                {
    287                Rx_Tx_Err_UART0[i] = 0;         // Array Rx_Tx_Err Erase
   \                     ??Reset_UART0_5:
   \   000000B2   E080                       LDI     R24,0
   \   000000B4   E090                       LDI     R25,0
   \   000000B6   8108                       LD      R16,Y
   \   000000B8   8119                       LDD     R17,Y+1
   \   000000BA   E042                       LDI     R20,2
   \   000000BC   E050                       LDI     R21,0
   \   000000BE   ........                   CALL    ?S_MUL_L02
   \   000000C2   01F8                       MOVW    R31 : R30,R17 : R16
   \   000000C4   ....                       SUBI    R30,LOW((-(Rx_Tx_Err_UART0) & 0xFFFF))
   \   000000C6   ....                       SBCI    R31,(-(Rx_Tx_Err_UART0) & 0xFFFF) >> 8
   \   000000C8   8380                       ST      Z,R24
   \   000000CA   8391                       STD     Z+1,R25
   \   000000CC   8108                       LD      R16,Y
   \   000000CE   8119                       LDD     R17,Y+1
   \   000000D0   5F0F                       SUBI    R16,255
   \   000000D2   4F1F                       SBCI    R17,255
   \   000000D4   8308                       ST      Y,R16
   \   000000D6   8319                       STD     Y+1,R17
   \                     ??Reset_UART0_4:
   \   000000D8   8188                       LD      R24,Y
   \   000000DA   8199                       LDD     R25,Y+1
   \   000000DC   3086                       CPI     R24,6
   \   000000DE   4090                       SBCI    R25,0
   \   000000E0   F344                       BRLT    ??Reset_UART0_5
    288                };
    289              /* Erase variables */
    290              Count_Rx_UART0 = 0;
   \   000000E2   E000                       LDI     R16,0
   \   000000E4   E010                       LDI     R17,0
   \   000000E6   E020                       LDI     R18,0
   \   000000E8   E030                       LDI     R19,0
   \   000000EA   ....                       LDI     R30,LOW(Count_Rx_UART0)
   \   000000EC   ....                       LDI     R31,(Count_Rx_UART0) >> 8
   \   000000EE   8300                       ST      Z,R16
   \   000000F0   8311                       STD     Z+1,R17
   \   000000F2   8322                       STD     Z+2,R18
   \   000000F4   8333                       STD     Z+3,R19
    291              Count_Tx_UART0 = 0;
   \   000000F6   E000                       LDI     R16,0
   \   000000F8   E010                       LDI     R17,0
   \   000000FA   E020                       LDI     R18,0
   \   000000FC   E030                       LDI     R19,0
   \   000000FE   ....                       LDI     R30,LOW(Count_Tx_UART0)
   \   00000100   ....                       LDI     R31,(Count_Tx_UART0) >> 8
   \   00000102   8300                       ST      Z,R16
   \   00000104   8311                       STD     Z+1,R17
   \   00000106   8322                       STD     Z+2,R18
   \   00000108   8333                       STD     Z+3,R19
    292              Count_Rx_Err_UART0 = 0;
   \   0000010A   E000                       LDI     R16,0
   \   0000010C   E010                       LDI     R17,0
   \   0000010E   E020                       LDI     R18,0
   \   00000110   E030                       LDI     R19,0
   \   00000112   ....                       LDI     R30,LOW(Count_Rx_Err_UART0)
   \   00000114   ....                       LDI     R31,(Count_Rx_Err_UART0) >> 8
   \   00000116   8300                       ST      Z,R16
   \   00000118   8311                       STD     Z+1,R17
   \   0000011A   8322                       STD     Z+2,R18
   \   0000011C   8333                       STD     Z+3,R19
    293              Count_Tx_Err_UART0 = 0;
   \   0000011E   E000                       LDI     R16,0
   \   00000120   E010                       LDI     R17,0
   \   00000122   E020                       LDI     R18,0
   \   00000124   E030                       LDI     R19,0
   \   00000126   ....                       LDI     R30,LOW(Count_Tx_Err_UART0)
   \   00000128   ....                       LDI     R31,(Count_Tx_Err_UART0) >> 8
   \   0000012A   8300                       ST      Z,R16
   \   0000012C   8311                       STD     Z+1,R17
   \   0000012E   8322                       STD     Z+2,R18
   \   00000130   8333                       STD     Z+3,R19
    294              /*  */
    295              SpeedBaud_UART0 = 0;
   \   00000132   E000                       LDI     R16,0
   \   00000134   E010                       LDI     R17,0
   \   00000136   ....                       LDI     R30,LOW(SpeedBaud_UART0)
   \   00000138   ....                       LDI     R31,(SpeedBaud_UART0) >> 8
   \   0000013A   8300                       ST      Z,R16
   \   0000013C   8311                       STD     Z+1,R17
    296              ModeU2X0 = 0;
   \   0000013E   E000                       LDI     R16,0
   \   00000140   9300....                   STS     ModeU2X0,R16
    297              ModeCHR90 = 0;
   \   00000144   E000                       LDI     R16,0
   \   00000146   9300....                   STS     ModeCHR90,R16
    298              CheckParity_UART0 = 0;
   \   0000014A   E000                       LDI     R16,0
   \   0000014C   9300....                   STS     CheckParity_UART0,R16
    299              SizeBit_UART0 = 1;
   \   00000150   E001                       LDI     R16,1
   \   00000152   9300....                   STS     SizeBit_UART0,R16
    300              ContrStream_UART0 = 0;
   \   00000156   E000                       LDI     R16,0
   \   00000158   9300....                   STS     ContrStream_UART0,R16
    301              Enb_DTR0 = 0;
   \   0000015C   E000                       LDI     R16,0
   \   0000015E   9300....                   STS     Enb_DTR0,R16
    302              Bit_DTR0 = 1;
   \   00000162   E001                       LDI     R16,1
   \   00000164   9300....                   STS     Bit_DTR0,R16
    303              Enb_DSR0 = 0;
   \   00000168   E000                       LDI     R16,0
   \   0000016A   9300....                   STS     Enb_DSR0,R16
    304              Bit_DSR0 = 1;
   \   0000016E   E001                       LDI     R16,1
   \   00000170   9300....                   STS     Bit_DSR0,R16
    305              Enb_RTS0 = 0;
   \   00000174   E000                       LDI     R16,0
   \   00000176   9300....                   STS     Enb_RTS0,R16
    306              Bit_RTS0 = 1;
   \   0000017A   E001                       LDI     R16,1
   \   0000017C   9300....                   STS     Bit_RTS0,R16
    307              Enb_CTS0 = 0;
   \   00000180   E000                       LDI     R16,0
   \   00000182   9300....                   STS     Enb_CTS0,R16
    308              Bit_CTS0 = 1;
   \   00000186   E001                       LDI     R16,1
   \   00000188   9300....                   STS     Bit_CTS0,R16
    309              Enb_XON_XOFF_Tx_UART0 = 0;
   \   0000018C   E000                       LDI     R16,0
   \   0000018E   9300....                   STS     Enb_XON_XOFF_Tx_UART0,R16
    310              Count_XOFF_Tx_UART0 = 0;
   \   00000192   E000                       LDI     R16,0
   \   00000194   9300....                   STS     Count_XOFF_Tx_UART0,R16
    311              Enb_XON_XOFF_Rx_UART0 = 0;
   \   00000198   E000                       LDI     R16,0
   \   0000019A   9300....                   STS     Enb_XON_XOFF_Rx_UART0,R16
    312              Count_XOFF_Rx_UART0 = 0;
   \   0000019E   E000                       LDI     R16,0
   \   000001A0   9300....                   STS     Count_XOFF_Rx_UART0,R16
    313              Enb_Echo_UART0 = 0;
   \   000001A4   E000                       LDI     R16,0
   \   000001A6   9300....                   STS     Enb_Echo_UART0,R16
    314              ModeMPCM0 =0;
   \   000001AA   E000                       LDI     R16,0
   \   000001AC   9300....                   STS     ModeMPCM0,R16
    315              /********************/
    316              /* New status A1x.y */
    317              A1x_y = 0;      //  y0 for UART0
   \   000001B0   E000                       LDI     R16,0
   \   000001B2   9300....                   STS     A1x_y,R16
    318              /*----------------*/
    319              /* ? status A2x ? */
    320              switch( A2x_y)
   \   000001B6   9100....                   LDS     R16,A2x_y
   \   000001BA   950A                       DEC     R16
   \   000001BC   F019                       BREQ    ??Reset_UART0_6
   \   000001BE   950A                       DEC     R16
   \   000001C0   F019                       BREQ    ??Reset_UART0_7
   \   000001C2   C003                       RJMP    ??Reset_UART0_8
    321              {
    322                case 1: // if A2x_y == y1 Copy sets from EEPROM
    323                CopySetsEEPROM_UART0();
   \                     ??Reset_UART0_6:
   \   000001C4   ....                       RCALL   CopySetsEEPROM_UART0
   \   000001C6   C001                       RJMP    ??Reset_UART0_8
    324                break;
    325                case 2: // if A2x_y == y2 Copy sets from ROM
    326                CopySetsROM_UART0();
   \                     ??Reset_UART0_7:
   \   000001C8   ....                       RCALL   CopySetsROM_UART0
    327                break;
    328                default:
    329                 ;  // Error! "No status A2x"
    330                break;
    331                };
    332              /********************/
    333              /* New status A1x.y */
    334              A1x_y = 1;      //  y1 for UART0
   \                     ??Reset_UART0_8:
   \   000001CA   E001                       LDI     R16,1
   \   000001CC   9300....                   STS     A1x_y,R16
    335              /*- ----------------*/
    336              /* Calculator BAUD  */
    337              Init_S_UART0(SpeedBaud_UART0);
   \   000001D0   ....                       LDI     R30,LOW(SpeedBaud_UART0)
   \   000001D2   ....                       LDI     R31,(SpeedBaud_UART0) >> 8
   \   000001D4   8100                       LD      R16,Z
   \   000001D6   8111                       LDD     R17,Z+1
   \   000001D8   ....                       RCALL   Init_S_UART0
    338          
    339              /*--------------------*/
    340              /* Enable Rx/Tx UART0 */
    341          
    342              // ?? DTR0,RTS0 and enable
    343          
    344              /********************/
    345              /* New status A1x.y */
    346              A1x_y = 2;      //  y2 for UART0
   \   000001DA   E002                       LDI     R16,2
   \   000001DC   9300....                   STS     A1x_y,R16
    347          
    348              /*--------------------*/
    349              /* Enable Rx/Tx UART0 */
    350              /********************/
    351              /* New status A1x.y */
    352              A1x_y = 3;      //  y3 for UART0
   \   000001E0   E003                       LDI     R16,3
   \   000001E2   9300....                   STS     A1x_y,R16
    353          
    354              }
   \   000001E6   9623                       ADIW    R29 : R28,3
   \   000001E8   9189                       LD      R24,Y+
   \   000001EA   9199                       LD      R25,Y+
   \   000001EC   9508                       RET
    355          
    356          /*-------------------------------------------*/
    357          /* "Enable_Err_Count_UART0" Enable counter   */
    358          /*         errors for Tx_Rx  UART            */

   \                                 In segment CODE, align 2, keep-with-next
    359          void   Enable_Err_Count_UART0 ( void )    // Enb_Err_UART0 = 1
    360              {
   \   __nearfunc void Enable_Err_Count_UART0();
   \                     Enable_Err_Count_UART0:
   \   00000000   ........                   CALL    ?PROLOGUE4_L09
    361              unsigned int i;
    362              Dis_UART0();
   \   00000004   ....                       RCALL   Dis_UART0
    363              /* Erase Array Errors Rx/Tx */
    364              for (i=1;i<=Rx_Tx_Err_SIZE_UART0;i++)
   \   00000006   E081                       LDI     R24,1
   \   00000008   E090                       LDI     R25,0
   \   0000000A   C00D                       RJMP    ??Enable_Err_Count_UART0_0
    365                {
    366                Rx_Tx_Err_UART0[i] = 0;         // Array Rx_Tx_Err Erase
   \                     ??Enable_Err_Count_UART0_1:
   \   0000000C   E0A0                       LDI     R26,0
   \   0000000E   E0B0                       LDI     R27,0
   \   00000010   018C                       MOVW    R17 : R16,R25 : R24
   \   00000012   E042                       LDI     R20,2
   \   00000014   E050                       LDI     R21,0
   \   00000016   ........                   CALL    ?S_MUL_L02
   \   0000001A   01F8                       MOVW    R31 : R30,R17 : R16
   \   0000001C   ....                       SUBI    R30,LOW((-(Rx_Tx_Err_UART0) & 0xFFFF))
   \   0000001E   ....                       SBCI    R31,(-(Rx_Tx_Err_UART0) & 0xFFFF) >> 8
   \   00000020   83A0                       ST      Z,R26
   \   00000022   83B1                       STD     Z+1,R27
   \   00000024   9601                       ADIW    R25 : R24,1
   \                     ??Enable_Err_Count_UART0_0:
   \   00000026   3086                       CPI     R24,6
   \   00000028   E000                       LDI     R16,0
   \   0000002A   0790                       CPC     R25,R16
   \   0000002C   F378                       BRCS    ??Enable_Err_Count_UART0_1
    367                };
    368              /* Erase variables */
    369              Count_Rx_UART0 = 0;
   \   0000002E   E000                       LDI     R16,0
   \   00000030   E010                       LDI     R17,0
   \   00000032   E020                       LDI     R18,0
   \   00000034   E030                       LDI     R19,0
   \   00000036   ....                       LDI     R30,LOW(Count_Rx_UART0)
   \   00000038   ....                       LDI     R31,(Count_Rx_UART0) >> 8
   \   0000003A   8300                       ST      Z,R16
   \   0000003C   8311                       STD     Z+1,R17
   \   0000003E   8322                       STD     Z+2,R18
   \   00000040   8333                       STD     Z+3,R19
    370              Count_Tx_UART0 = 0;
   \   00000042   E000                       LDI     R16,0
   \   00000044   E010                       LDI     R17,0
   \   00000046   E020                       LDI     R18,0
   \   00000048   E030                       LDI     R19,0
   \   0000004A   ....                       LDI     R30,LOW(Count_Tx_UART0)
   \   0000004C   ....                       LDI     R31,(Count_Tx_UART0) >> 8
   \   0000004E   8300                       ST      Z,R16
   \   00000050   8311                       STD     Z+1,R17
   \   00000052   8322                       STD     Z+2,R18
   \   00000054   8333                       STD     Z+3,R19
    371              Count_Rx_Err_UART0 = 0;
   \   00000056   E000                       LDI     R16,0
   \   00000058   E010                       LDI     R17,0
   \   0000005A   E020                       LDI     R18,0
   \   0000005C   E030                       LDI     R19,0
   \   0000005E   ....                       LDI     R30,LOW(Count_Rx_Err_UART0)
   \   00000060   ....                       LDI     R31,(Count_Rx_Err_UART0) >> 8
   \   00000062   8300                       ST      Z,R16
   \   00000064   8311                       STD     Z+1,R17
   \   00000066   8322                       STD     Z+2,R18
   \   00000068   8333                       STD     Z+3,R19
    372              Count_Tx_Err_UART0 = 0;
   \   0000006A   E000                       LDI     R16,0
   \   0000006C   E010                       LDI     R17,0
   \   0000006E   E020                       LDI     R18,0
   \   00000070   E030                       LDI     R19,0
   \   00000072   ....                       LDI     R30,LOW(Count_Tx_Err_UART0)
   \   00000074   ....                       LDI     R31,(Count_Tx_Err_UART0) >> 8
   \   00000076   8300                       ST      Z,R16
   \   00000078   8311                       STD     Z+1,R17
   \   0000007A   8322                       STD     Z+2,R18
   \   0000007C   8333                       STD     Z+3,R19
    373              /*  */
    374              Enb_Err_UART0 = 1;
   \   0000007E   E001                       LDI     R16,1
   \   00000080   9300....                   STS     Enb_Err_UART0,R16
    375              Enb_UART0();
   \   00000084   ....                       RCALL   Enb_UART0
    376              }
   \   00000086   E0E4                       LDI     R30,4
   \   00000088   ........                   JMP     ?EPILOGUE_B4_L09
    377          
    378          /*---------------------------------------------*/
    379          /* "Disable_Err_Count_UART0" Disable counter   */
    380          /*        errors for Tx_Rx  UART               */

   \                                 In segment CODE, align 2, keep-with-next
    381          void   Disable_Err_Count_UART0 ( void )   // End_Err_UART0 = 0
    382              {
    383              Enb_Err_UART0 = 0;
   \   __nearfunc void Disable_Err_Count_UART0();
   \                     Disable_Err_Count_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Enb_Err_UART0,R16
    384               }
   \   00000006   9508                       RET
    385          
    386          /*-------------------------------*/
    387          /* Read Arry Tx_Rx_Err for UART  */

   \                                 In segment CODE, align 2, keep-with-next
    388          int    Read_Tx_Rx_Err_UART0 ( void )    // Type strings table Error
    389               {
   \   __nearfunc int Read_Tx_Rx_Err_UART0();
   \                     Read_Tx_Rx_Err_UART0:
   \   00000000   ........                   CALL    ?PROLOGUE4_L09
   \   00000004   9722                       SBIW    R29 : R28,2
    390          static volatile unsigned int Arr_Tmp[Rx_Tx_Err_SIZE_UART0];
    391          unsigned int i;
    392          volatile unsigned int iT;
    393          
    394              /* Rear for Arr Errors */
    395              for (i=1;i<=Rx_Tx_Err_SIZE_UART0;i++)
   \   00000006   E081                       LDI     R24,1
   \   00000008   E090                       LDI     R25,0
   \   0000000A   C015                       RJMP    ??Read_Tx_Rx_Err_UART0_0
    396                {
    397                Arr_Tmp[i] = Rx_Tx_Err_UART0[i];
   \                     ??Read_Tx_Rx_Err_UART0_1:
   \   0000000C   018C                       MOVW    R17 : R16,R25 : R24
   \   0000000E   E042                       LDI     R20,2
   \   00000010   E050                       LDI     R21,0
   \   00000012   ........                   CALL    ?S_MUL_L02
   \   00000016   01F8                       MOVW    R31 : R30,R17 : R16
   \   00000018   ....                       SUBI    R30,LOW((-(Rx_Tx_Err_UART0) & 0xFFFF))
   \   0000001A   ....                       SBCI    R31,(-(Rx_Tx_Err_UART0) & 0xFFFF) >> 8
   \   0000001C   81A0                       LD      R26,Z
   \   0000001E   81B1                       LDD     R27,Z+1
   \   00000020   018C                       MOVW    R17 : R16,R25 : R24
   \   00000022   E042                       LDI     R20,2
   \   00000024   E050                       LDI     R21,0
   \   00000026   ........                   CALL    ?S_MUL_L02
   \   0000002A   01F8                       MOVW    R31 : R30,R17 : R16
   \   0000002C   ....                       SUBI    R30,LOW((-(??Arr_Tmp) & 0xFFFF))
   \   0000002E   ....                       SBCI    R31,(-(??Arr_Tmp) & 0xFFFF) >> 8
   \   00000030   83A0                       ST      Z,R26
   \   00000032   83B1                       STD     Z+1,R27
   \   00000034   9601                       ADIW    R25 : R24,1
   \                     ??Read_Tx_Rx_Err_UART0_0:
   \   00000036   3086                       CPI     R24,6
   \   00000038   E000                       LDI     R16,0
   \   0000003A   0790                       CPC     R25,R16
   \   0000003C   F338                       BRCS    ??Read_Tx_Rx_Err_UART0_1
    398                };
    399              iT = printf(" \n\r");
   \   0000003E   ....                       LDI     R16,LOW(`?<Constant " \\n\\r">`)
   \   00000040   ....                       LDI     R17,(`?<Constant " \\n\\r">`) >> 8
   \   00000042   ........                   CALL    printf
   \   00000046   8308                       ST      Y,R16
   \   00000048   8319                       STD     Y+1,R17
    400              iT = printf("Table Errors Rx/Tx:");
   \   0000004A   ....                       LDI     R16,LOW(`?<Constant "Table Errors Rx/Tx:">`)
   \   0000004C   ....                       LDI     R17,(`?<Constant "Table Errors Rx/Tx:">`) >> 8
   \   0000004E   ........                   CALL    printf
   \   00000052   8308                       ST      Y,R16
   \   00000054   8319                       STD     Y+1,R17
    401              iT = printf("  ");
   \   00000056   ....                       LDI     R16,LOW(`?<Constant "  ">`)
   \   00000058   ....                       LDI     R17,(`?<Constant "  ">`) >> 8
   \   0000005A   ........                   CALL    printf
   \   0000005E   8308                       ST      Y,R16
   \   00000060   8319                       STD     Y+1,R17
    402              iT = printf("%d", Arr_Tmp[1]);
   \   00000062   ....                       LDI     R30,LOW(??Arr_Tmp)
   \   00000064   ....                       LDI     R31,(??Arr_Tmp) >> 8
   \   00000066   8102                       LDD     R16,Z+2
   \   00000068   8113                       LDD     R17,Z+3
   \   0000006A   931A                       ST      -Y,R17
   \   0000006C   930A                       ST      -Y,R16
   \   0000006E   ....                       LDI     R16,LOW(`?<Constant "%d">`)
   \   00000070   ....                       LDI     R17,(`?<Constant "%d">`) >> 8
   \   00000072   ........                   CALL    printf
   \   00000076   9622                       ADIW    R29 : R28,2
   \   00000078   8308                       ST      Y,R16
   \   0000007A   8319                       STD     Y+1,R17
    403              iT = printf("  ");
   \   0000007C   ....                       LDI     R16,LOW(`?<Constant "  ">`)
   \   0000007E   ....                       LDI     R17,(`?<Constant "  ">`) >> 8
   \   00000080   ........                   CALL    printf
   \   00000084   8308                       ST      Y,R16
   \   00000086   8319                       STD     Y+1,R17
    404              iT = printf("%d", Arr_Tmp[2]);
   \   00000088   ....                       LDI     R30,LOW(??Arr_Tmp)
   \   0000008A   ....                       LDI     R31,(??Arr_Tmp) >> 8
   \   0000008C   8104                       LDD     R16,Z+4
   \   0000008E   8115                       LDD     R17,Z+5
   \   00000090   931A                       ST      -Y,R17
   \   00000092   930A                       ST      -Y,R16
   \   00000094   ....                       LDI     R16,LOW(`?<Constant "%d">`)
   \   00000096   ....                       LDI     R17,(`?<Constant "%d">`) >> 8
   \   00000098   ........                   CALL    printf
   \   0000009C   9622                       ADIW    R29 : R28,2
   \   0000009E   8308                       ST      Y,R16
   \   000000A0   8319                       STD     Y+1,R17
    405              iT = printf("  ");
   \   000000A2   ....                       LDI     R16,LOW(`?<Constant "  ">`)
   \   000000A4   ....                       LDI     R17,(`?<Constant "  ">`) >> 8
   \   000000A6   ........                   CALL    printf
   \   000000AA   8308                       ST      Y,R16
   \   000000AC   8319                       STD     Y+1,R17
    406              iT = printf("%d", Arr_Tmp[3]);
   \   000000AE   ....                       LDI     R30,LOW(??Arr_Tmp)
   \   000000B0   ....                       LDI     R31,(??Arr_Tmp) >> 8
   \   000000B2   8106                       LDD     R16,Z+6
   \   000000B4   8117                       LDD     R17,Z+7
   \   000000B6   931A                       ST      -Y,R17
   \   000000B8   930A                       ST      -Y,R16
   \   000000BA   ....                       LDI     R16,LOW(`?<Constant "%d">`)
   \   000000BC   ....                       LDI     R17,(`?<Constant "%d">`) >> 8
   \   000000BE   ........                   CALL    printf
   \   000000C2   9622                       ADIW    R29 : R28,2
   \   000000C4   8308                       ST      Y,R16
   \   000000C6   8319                       STD     Y+1,R17
    407              iT = printf("  ");
   \   000000C8   ....                       LDI     R16,LOW(`?<Constant "  ">`)
   \   000000CA   ....                       LDI     R17,(`?<Constant "  ">`) >> 8
   \   000000CC   ........                   CALL    printf
   \   000000D0   8308                       ST      Y,R16
   \   000000D2   8319                       STD     Y+1,R17
    408              iT = printf("%d", Arr_Tmp[4]);
   \   000000D4   ....                       LDI     R30,LOW(??Arr_Tmp)
   \   000000D6   ....                       LDI     R31,(??Arr_Tmp) >> 8
   \   000000D8   8500                       LDD     R16,Z+8
   \   000000DA   8511                       LDD     R17,Z+9
   \   000000DC   931A                       ST      -Y,R17
   \   000000DE   930A                       ST      -Y,R16
   \   000000E0   ....                       LDI     R16,LOW(`?<Constant "%d">`)
   \   000000E2   ....                       LDI     R17,(`?<Constant "%d">`) >> 8
   \   000000E4   ........                   CALL    printf
   \   000000E8   9622                       ADIW    R29 : R28,2
   \   000000EA   8308                       ST      Y,R16
   \   000000EC   8319                       STD     Y+1,R17
    409              iT = printf(" \n\r");
   \   000000EE   ....                       LDI     R16,LOW(`?<Constant " \\n\\r">`)
   \   000000F0   ....                       LDI     R17,(`?<Constant " \\n\\r">`) >> 8
   \   000000F2   ........                   CALL    printf
   \   000000F6   8308                       ST      Y,R16
   \   000000F8   8319                       STD     Y+1,R17
    410              iT = printf("Table Counters  Rx:");
   \   000000FA   ....                       LDI     R16,LOW(`?<Constant "Table Counters  Rx:">`)
   \   000000FC   ....                       LDI     R17,(`?<Constant "Table Counters  Rx:">`) >> 8
   \   000000FE   ........                   CALL    printf
   \   00000102   8308                       ST      Y,R16
   \   00000104   8319                       STD     Y+1,R17
    411              iT = printf("  ");
   \   00000106   ....                       LDI     R16,LOW(`?<Constant "  ">`)
   \   00000108   ....                       LDI     R17,(`?<Constant "  ">`) >> 8
   \   0000010A   ........                   CALL    printf
   \   0000010E   8308                       ST      Y,R16
   \   00000110   8319                       STD     Y+1,R17
    412              iT = printf("%ld", Count_Rx_UART0);
   \   00000112   ....                       LDI     R30,LOW(Count_Rx_UART0)
   \   00000114   ....                       LDI     R31,(Count_Rx_UART0) >> 8
   \   00000116   8100                       LD      R16,Z
   \   00000118   8111                       LDD     R17,Z+1
   \   0000011A   8122                       LDD     R18,Z+2
   \   0000011C   8133                       LDD     R19,Z+3
   \   0000011E   933A                       ST      -Y,R19
   \   00000120   932A                       ST      -Y,R18
   \   00000122   931A                       ST      -Y,R17
   \   00000124   930A                       ST      -Y,R16
   \   00000126   ....                       LDI     R16,LOW(`?<Constant "%ld">`)
   \   00000128   ....                       LDI     R17,(`?<Constant "%ld">`) >> 8
   \   0000012A   ........                   CALL    printf
   \   0000012E   9624                       ADIW    R29 : R28,4
   \   00000130   8308                       ST      Y,R16
   \   00000132   8319                       STD     Y+1,R17
    413              iT = printf("  ");
   \   00000134   ....                       LDI     R16,LOW(`?<Constant "  ">`)
   \   00000136   ....                       LDI     R17,(`?<Constant "  ">`) >> 8
   \   00000138   ........                   CALL    printf
   \   0000013C   8308                       ST      Y,R16
   \   0000013E   8319                       STD     Y+1,R17
    414              iT = printf("%ld", Count_Rx_Err_UART0);
   \   00000140   ....                       LDI     R30,LOW(Count_Rx_Err_UART0)
   \   00000142   ....                       LDI     R31,(Count_Rx_Err_UART0) >> 8
   \   00000144   8100                       LD      R16,Z
   \   00000146   8111                       LDD     R17,Z+1
   \   00000148   8122                       LDD     R18,Z+2
   \   0000014A   8133                       LDD     R19,Z+3
   \   0000014C   933A                       ST      -Y,R19
   \   0000014E   932A                       ST      -Y,R18
   \   00000150   931A                       ST      -Y,R17
   \   00000152   930A                       ST      -Y,R16
   \   00000154   ....                       LDI     R16,LOW(`?<Constant "%ld">`)
   \   00000156   ....                       LDI     R17,(`?<Constant "%ld">`) >> 8
   \   00000158   ........                   CALL    printf
   \   0000015C   9624                       ADIW    R29 : R28,4
   \   0000015E   8308                       ST      Y,R16
   \   00000160   8319                       STD     Y+1,R17
    415              iT = printf(" \n\r");
   \   00000162   ....                       LDI     R16,LOW(`?<Constant " \\n\\r">`)
   \   00000164   ....                       LDI     R17,(`?<Constant " \\n\\r">`) >> 8
   \   00000166   ........                   CALL    printf
   \   0000016A   8308                       ST      Y,R16
   \   0000016C   8319                       STD     Y+1,R17
    416              return 0;                          // if int = -1 ERROR
   \   0000016E   E000                       LDI     R16,0
   \   00000170   E010                       LDI     R17,0
   \   00000172   9622                       ADIW    R29 : R28,2
   \   00000174   E0E4                       LDI     R30,4
   \   00000176   ........                   JMP     ?EPILOGUE_B4_L09
    417               }

   \                                 In segment NEAR_Z, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_Z>`
   \   unsigned int volatile __near Arr_Tmp[5];
   \                     ??Arr_Tmp:
   \   00000000                              DS 10
    418          
    419          /*-----------------------------*/
    420          /*  Control stream  UART0 mode */

   \                                 In segment CODE, align 2, keep-with-next
    421          void   ControlStream_ON_UART0( void )
    422          {
    423              ContrStream_UART0 = 1;
   \   __nearfunc void ControlStream_ON_UART0();
   \                     ControlStream_ON_UART0:
   \   00000000   E001                       LDI     R16,1
   \   00000002   9300....                   STS     ContrStream_UART0,R16
    424          }
   \   00000006   9508                       RET
    425          
    426          /*-----------------------------*/
    427          /*  Control stream  UART0 mode */

   \                                 In segment CODE, align 2, keep-with-next
    428          void   ControlStream_OFF_UART0( void )
    429          {
    430              ContrStream_UART0 = 0;
   \   __nearfunc void ControlStream_OFF_UART0();
   \                     ControlStream_OFF_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     ContrStream_UART0,R16
    431          }
   \   00000006   9508                       RET
    432          
    433          
    434          /*-------------------------*/
    435          /* "Echo On UART0"         */

   \                                 In segment CODE, align 2, keep-with-next
    436          void   Echo_ON_UART0( void )   // Set Echo = 1 Mode 'ON'
    437                {
    438                Enb_Echo_UART0 = 1;
   \   __nearfunc void Echo_ON_UART0();
   \                     Echo_ON_UART0:
   \   00000000   E001                       LDI     R16,1
   \   00000002   9300....                   STS     Enb_Echo_UART0,R16
    439                }
   \   00000006   9508                       RET
    440          
    441          /*- -------------------------*/
    442          /* "Echo OFF UART0"          */

   \                                 In segment CODE, align 2, keep-with-next
    443          void   Echo_OFF_UART0( void )  // Set Echo = 0 Mode 'OFF'
    444                {
    445                Enb_Echo_UART0 = 0;
   \   __nearfunc void Echo_OFF_UART0();
   \                     Echo_OFF_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Enb_Echo_UART0,R16
    446                }
   \   00000006   9508                       RET
    447          
    448          /*-------------------------*/
    449          /* "Break UART0" for UART  */

   \                                 In segment CODE, align 2, keep-with-next
    450          void   Break_UART0( void )    // Set pin AVR TXD = MARK ( Low )
    451                {}
   \   __nearfunc void Break_UART0();
   \                     Break_UART0:
   \   00000000   9508                       RET
    452          
    453          /*---------------------------------*/
    454          /*  "DTR ON CONTROLL UART0"        */

   \                                 In segment CODE, align 2, keep-with-next
    455          void     DTR_ON_CONTR_UART0( void )     // Control DTR ON
    456                {
    457                Enb_DTR0 = 1;
   \   __nearfunc void DTR_ON_CONTR_UART0();
   \                     DTR_ON_CONTR_UART0:
   \   00000000   E001                       LDI     R16,1
   \   00000002   9300....                   STS     Enb_DTR0,R16
    458                }
   \   00000006   9508                       RET
    459          
    460          /*---------------------------------*/
    461          /*  "DTR OFF CONTROL UART0"        */

   \                                 In segment CODE, align 2, keep-with-next
    462          void     DTR_OFF_CONTR_UART0( void )    // Control DTR OFF
    463                {
    464                Enb_DTR0 = 0;
   \   __nearfunc void DTR_OFF_CONTR_UART0();
   \                     DTR_OFF_CONTR_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Enb_DTR0,R16
    465                }
   \   00000006   9508                       RET
    466          
    467          /*---------------------------------*/
    468          /*  "DTR SET UART0"                */

   \                                 In segment CODE, align 2, keep-with-next
    469          void     DTR_SET_UART0( void )          // Set signal DTR = 1
    470                {
    471                Bit_DTR0 = 1;
   \   __nearfunc void DTR_SET_UART0();
   \                     DTR_SET_UART0:
   \   00000000   E001                       LDI     R16,1
   \   00000002   9300....                   STS     Bit_DTR0,R16
    472                PORT_FLOW_D = PORT_FLOW_D | ( 1<< DTR0 ); // Pin port output
   \   00000006   9A8C                       SBI     0x11,0x04
    473                 if ( Bit_DTR0 & 0x01 == 0)
   \   00000008   9100....                   LDS     R16,Bit_DTR0
    474                 {
    475                 ClrBit( PORT_FLOW_O, DTR0); // pin output set low 0
    476                 }
    477                 else
    478                 {
    479                 SetBit( PORT_FLOW_O, DTR0); // pin output set high 1
   \   0000000C   9A94                       SBI     0x12,0x04
    480                 };
    481                }
   \   0000000E   9508                       RET
    482          
    483          /*---------------------------------*/
    484          /*  "DTR CLR UART0"                */

   \                                 In segment CODE, align 2, keep-with-next
    485          void     DTR_CLR_UART0( void )          // Set DTR = 0
    486                {
    487                Bit_DTR0 = 0;
   \   __nearfunc void DTR_CLR_UART0();
   \                     DTR_CLR_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Bit_DTR0,R16
    488                PORT_FLOW_D = PORT_FLOW_D | ( 1<< DTR0 ); // Pin port output
   \   00000006   9A8C                       SBI     0x11,0x04
    489                 if ( Bit_DTR0 & 0x01 == 0)
   \   00000008   9100....                   LDS     R16,Bit_DTR0
    490                 {
    491                 ClrBit( PORT_FLOW_O, DTR0); // pin output set low 0
    492                 }
    493                 else
    494                 {
    495                 SetBit( PORT_FLOW_O, DTR0); // pin output set high 1
   \   0000000C   9A94                       SBI     0x12,0x04
    496                 };
    497                }
   \   0000000E   9508                       RET
    498          
    499          /*-----------------------------*/
    500          /* "RTS_ON_CONTR_UART0"        */

   \                                 In segment CODE, align 2, keep-with-next
    501          void     RTS_ON_CONTR_UART0( void )    // Control RTS ON
    502                {
    503                Enb_RTS0 =1;
   \   __nearfunc void RTS_ON_CONTR_UART0();
   \                     RTS_ON_CONTR_UART0:
   \   00000000   E001                       LDI     R16,1
   \   00000002   9300....                   STS     Enb_RTS0,R16
    504                }
   \   00000006   9508                       RET
    505          
    506          /*-----------------------------*/
    507          /*  "RTS_OFF_CONTR_UART0"      */

   \                                 In segment CODE, align 2, keep-with-next
    508          void     RTS_OFF_CONTR_UART0( void )   // Control RTS OFF
    509                {
    510                Enb_RTS0 =0;
   \   __nearfunc void RTS_OFF_CONTR_UART0();
   \                     RTS_OFF_CONTR_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Enb_RTS0,R16
    511                }
   \   00000006   9508                       RET
    512          
    513          /*------------------------------*/
    514          /*  "RTS_SET_UART0"             */

   \                                 In segment CODE, align 2, keep-with-next
    515          void     RTS_SET_UART0( void )        // Set RTS = 1
    516                 {
    517                Bit_RTS0 = 1;
   \   __nearfunc void RTS_SET_UART0();
   \                     RTS_SET_UART0:
   \   00000000   E001                       LDI     R16,1
   \   00000002   9300....                   STS     Bit_RTS0,R16
    518                PORT_FLOW_D = PORT_FLOW_D  | ( 1<< RTS0 ); // Pin port output
   \   00000006   9A8D                       SBI     0x11,0x05
    519                 if ( Bit_RTS0 & 0x01 == 0)
   \   00000008   9100....                   LDS     R16,Bit_RTS0
    520                 {
    521                 ClrBit( PORT_FLOW_O, RTS0); // pin output set low 0
    522                 }
    523                 else
    524                 {
    525                 SetBit( PORT_FLOW_O, RTS0); // pin output set high 1
   \   0000000C   9A95                       SBI     0x12,0x05
    526                 };
    527                 }
   \   0000000E   9508                       RET
    528          
    529          /*------------------------*/
    530          /*  "RTS_CLR_UART0"       */

   \                                 In segment CODE, align 2, keep-with-next
    531          void     RTS_CLR_UART0( void )         // Set RTS = 0
    532                 {
    533                Bit_RTS0 = 0;
   \   __nearfunc void RTS_CLR_UART0();
   \                     RTS_CLR_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Bit_RTS0,R16
    534                PORT_FLOW_D = PORT_FLOW_D  | ( 1<< RTS0 ); // Pin port output
   \   00000006   9A8D                       SBI     0x11,0x05
    535                 if ( Bit_RTS0 & 0x01 == 0)
   \   00000008   9100....                   LDS     R16,Bit_RTS0
    536                 {
    537                 ClrBit( PORT_FLOW_O, RTS0); // pin output set low 0
    538                 }
    539                 else
    540                 {
    541                 SetBit( PORT_FLOW_O, RTS0); // pin output set high 1
   \   0000000C   9A95                       SBI     0x12,0x05
    542                 };
    543                 }
   \   0000000E   9508                       RET
    544          
    545          /*--------------------------*/
    546          /*  "DSR_ON_CONTR_UART0"    */

   \                                 In segment CODE, align 2, keep-with-next
    547          void     DSR_ON_CONTR_UART0( void )    // Control DSR ON
    548                {
    549                Enb_DSR0 = 1;
   \   __nearfunc void DSR_ON_CONTR_UART0();
   \                     DSR_ON_CONTR_UART0:
   \   00000000   E001                       LDI     R16,1
   \   00000002   9300....                   STS     Enb_DSR0,R16
    550                }
   \   00000006   9508                       RET
    551          
    552          /*-------------------------*/
    553          /* "DSR_OFF_CONTR_UART0"   */

   \                                 In segment CODE, align 2, keep-with-next
    554          void     DSR_OFF_CONTR_UART0( void )   // Control DSR OFF
    555                {
    556                Enb_DSR0 = 0;
   \   __nearfunc void DSR_OFF_CONTR_UART0();
   \                     DSR_OFF_CONTR_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Enb_DSR0,R16
    557                }
   \   00000006   9508                       RET
    558          
    559          /*--------------------------*/
    560          /*  "DSR_SET_UART0"         */

   \                                 In segment CODE, align 2, keep-with-next
    561          void     DSR_SET_UART0( void )         // Set DSR = 1
    562                {
    563                Bit_DSR0 = 1;
   \   __nearfunc void DSR_SET_UART0();
   \                     DSR_SET_UART0:
   \   00000000   E001                       LDI     R16,1
   \   00000002   9300....                   STS     Bit_DSR0,R16
    564                }
   \   00000006   9508                       RET
    565          
    566          /*---------------------*/
    567          /*  "DSR_CLR_UART0"    */

   \                                 In segment CODE, align 2, keep-with-next
    568          void     DSR_CLR_UART0( void )         // Set DSR = 0
    569                 {
    570                 Bit_DSR0 = 0;
   \   __nearfunc void DSR_CLR_UART0();
   \                     DSR_CLR_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Bit_DSR0,R16
    571                 }
   \   00000006   9508                       RET
    572          
    573          /*--------------------------*/
    574          /*  "CTS_ON_CONTR_UART0"    */

   \                                 In segment CODE, align 2, keep-with-next
    575          void     CTS_ON_CONTR_UART0( void )    // Control CTS ON
    576                {
    577                Enb_CTS0 = 1;
   \   __nearfunc void CTS_ON_CONTR_UART0();
   \                     CTS_ON_CONTR_UART0:
   \   00000000   E001                       LDI     R16,1
   \   00000002   9300....                   STS     Enb_CTS0,R16
    578                }
   \   00000006   9508                       RET
    579          
    580          /*-------------------------*/
    581          /* "CTS_OFF_CONTR_UART0"   */

   \                                 In segment CODE, align 2, keep-with-next
    582          void     CTS_OFF_CONTR_UART0( void )   // Control CTS OFF
    583                {
    584                Enb_CTS0 = 0;
   \   __nearfunc void CTS_OFF_CONTR_UART0();
   \                     CTS_OFF_CONTR_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Enb_CTS0,R16
    585                }
   \   00000006   9508                       RET
    586          
    587          /*--------------------------*/
    588          /*  "CTS_SET_UART0"         */

   \                                 In segment CODE, align 2, keep-with-next
    589          void     CTS_SET_UART0( void )         // Set CTS = 1
    590                {
    591                Bit_CTS0 = 1;
   \   __nearfunc void CTS_SET_UART0();
   \                     CTS_SET_UART0:
   \   00000000   E001                       LDI     R16,1
   \   00000002   9300....                   STS     Bit_CTS0,R16
    592                }
   \   00000006   9508                       RET
    593          
    594          /*---------------------*/
    595          /*  "CTS_CLR_UART0"    */

   \                                 In segment CODE, align 2, keep-with-next
    596          void     CTS_CLR_UART0( void )         // Set CTS = 0
    597                 {
    598                 Bit_CTS0 = 0;
   \   __nearfunc void CTS_CLR_UART0();
   \                     CTS_CLR_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Bit_CTS0,R16
    599                 }
   \   00000006   9508                       RET
    600          
    601          /*--------------------------------*/
    602          /* "XON_XOFF_ON_CONTR_Rx_UART0"   */

   \                                 In segment CODE, align 2, keep-with-next
    603          void     XON_XOFF_ON_CONTR_Rx_UART0( void )  // XON/XOFF  Rx = 1 Enable
    604                  {
    605                  Count_XOFF_Rx_UART0 = 0;
   \   __nearfunc void XON_XOFF_ON_CONTR_Rx_UART0();
   \                     XON_XOFF_ON_CONTR_Rx_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Count_XOFF_Rx_UART0,R16
    606                  Enb_XON_XOFF_Rx_UART0 = 1;
   \   00000006   E001                       LDI     R16,1
   \   00000008   9300....                   STS     Enb_XON_XOFF_Rx_UART0,R16
    607                  }
   \   0000000C   9508                       RET
    608          
    609          /*---------------------------------*/
    610          /* "XON_XOFF_OFF_CONTR_Rx_UART0"   */

   \                                 In segment CODE, align 2, keep-with-next
    611          void     XON_XOFF_OFF_CONTR_Rx_UART0( void ) // XON/XOFF Rx = 0 Disable
    612                  {
    613                  Count_XOFF_Rx_UART0 = 0;
   \   __nearfunc void XON_XOFF_OFF_CONTR_Rx_UART0();
   \                     XON_XOFF_OFF_CONTR_Rx_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Count_XOFF_Rx_UART0,R16
    614                  Enb_XON_XOFF_Rx_UART0 = 0;
   \   00000006   E000                       LDI     R16,0
   \   00000008   9300....                   STS     Enb_XON_XOFF_Rx_UART0,R16
    615                  }
   \   0000000C   9508                       RET
    616          /*--------------------------------*/
    617          /* "XON_XOFF_ON_CONTR_Tx_UART0"   */

   \                                 In segment CODE, align 2, keep-with-next
    618          void     XON_XOFF_ON_CONTR_Tx_UART0( void )  // XON/XOFF  Tx = 1 Enable
    619                  {
    620                  Count_XOFF_Tx_UART0 = 0;
   \   __nearfunc void XON_XOFF_ON_CONTR_Tx_UART0();
   \                     XON_XOFF_ON_CONTR_Tx_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Count_XOFF_Tx_UART0,R16
    621                  Enb_XON_XOFF_Tx_UART0 = 1;
   \   00000006   E001                       LDI     R16,1
   \   00000008   9300....                   STS     Enb_XON_XOFF_Tx_UART0,R16
    622                  }
   \   0000000C   9508                       RET
    623          
    624          /* "XON_XOFF_OFF_CONTR_Tx_UART0"   */

   \                                 In segment CODE, align 2, keep-with-next
    625          void     XON_XOFF_OFF_CONTR_Tx_UART0( void ) // XON/XOFF Tx = 0 Disable
    626                  {
    627                  Count_XOFF_Tx_UART0 = 0;
   \   __nearfunc void XON_XOFF_OFF_CONTR_Tx_UART0();
   \                     XON_XOFF_OFF_CONTR_Tx_UART0:
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     Count_XOFF_Tx_UART0,R16
    628                  Enb_XON_XOFF_Tx_UART0 = 0;
   \   00000006   E000                       LDI     R16,0
   \   00000008   9300....                   STS     Enb_XON_XOFF_Tx_UART0,R16
    629                  }
   \   0000000C   9508                       RET
    630          
    631          /**********************/
    632          /* Function IncErrArr */

   \                                 In segment CODE, align 2, keep-with-next
    633          void IncErrArr_UART0 ( int pos )
    634          {
    635           if ( Enb_Err_UART0 != 0 )
   \   __nearfunc void IncErrArr_UART0(int);
   \                     IncErrArr_UART0:
   \   00000000   9120....                   LDS     R18,Enb_Err_UART0
   \   00000004   2322                       TST     R18
   \   00000006   F069                       BREQ    ??IncErrArr_UART0_0
    636            {
    637            Rx_Tx_Err_UART0[pos]++;
   \   00000008   E042                       LDI     R20,2
   \   0000000A   E050                       LDI     R21,0
   \   0000000C   ........                   CALL    ?S_MUL_L02
   \   00000010   01F8                       MOVW    R31 : R30,R17 : R16
   \   00000012   ....                       SUBI    R30,LOW((-(Rx_Tx_Err_UART0) & 0xFFFF))
   \   00000014   ....                       SBCI    R31,(-(Rx_Tx_Err_UART0) & 0xFFFF) >> 8
   \   00000016   8100                       LD      R16,Z
   \   00000018   8111                       LDD     R17,Z+1
   \   0000001A   5F0F                       SUBI    R16,255
   \   0000001C   4F1F                       SBCI    R17,255
   \   0000001E   8300                       ST      Z,R16
   \   00000020   8311                       STD     Z+1,R17
    638            };
    639          }
   \                     ??IncErrArr_UART0_0:
   \   00000022   9508                       RET
    640          /*  End IncErrArr    */
    641          /*********************/
    642          
    643          /****************************/
    644          /* Read and write functions */

   \                                 In segment CODE, align 2, keep-with-next
    645          unsigned char ReceiveByte_UART0( void )
    646                  {
    647                  unsigned char tmptail;
    648                  unsigned char cByte;
    649          
    650                  while ( RxHead_UART0 == RxTail_UART0 ) /* wait for incomming data */
   \   __nearfunc unsigned char ReceiveByte_UART0();
   \                     ReceiveByte_UART0:
   \                     ??ReceiveByte_UART0_0:
   \   00000000   9100....                   LDS     R16,RxHead_UART0
   \   00000004   9110....                   LDS     R17,RxTail_UART0
   \   00000008   1701                       CP      R16,R17
   \   0000000A   F3D1                       BREQ    ??ReceiveByte_UART0_0
    651                          ;
    652                  tmptail = ( RxTail_UART0 + 1 ) & RX_BUFFER_MASK_UART0;/* calculate buffer index */
   \   0000000C   9100....                   LDS     R16,RxTail_UART0
   \   00000010   9503                       INC     R16
   \   00000012   710F                       ANDI    R16,0x1F
    653                  RxTail_UART0 = tmptail; /* store new index */
   \   00000014   9300....                   STS     RxTail_UART0,R16
    654                  cByte = RxBuf_UART0[tmptail];
   \   00000018   E010                       LDI     R17,0
   \   0000001A   01F8                       MOVW    R31 : R30,R17 : R16
   \   0000001C   ....                       SUBI    R30,LOW((-(RxBuf_UART0) & 0xFFFF))
   \   0000001E   ....                       SBCI    R31,(-(RxBuf_UART0) & 0xFFFF) >> 8
   \   00000020   8100                       LD      R16,Z
    655          
    656                  return cByte; /* return data */
   \   00000022   9508                       RET
    657                  }
    658          

   \                                 In segment CODE, align 2, keep-with-next
    659          void TransmitByte_UART0( unsigned char data )
    660                  {
    661                  unsigned char tmphead;
    662                  /* calculate buffer index */
    663                  tmphead = ( TxHead_UART0 + 1 ) & TX_BUFFER_MASK_UART0;
   \   __nearfunc void TransmitByte_UART0(unsigned char);
   \                     TransmitByte_UART0:
   \   00000000   9120....                   LDS     R18,TxHead_UART0
   \   00000004   9523                       INC     R18
   \   00000006   712F                       ANDI    R18,0x1F
    664                          /* wait for free space in buffer or Enable Transmit */
    665                  while ( tmphead == TxTail_UART0 )
   \                     ??TransmitByte_UART0_0:
   \   00000008   9110....                   LDS     R17,TxTail_UART0
   \   0000000C   1721                       CP      R18,R17
   \   0000000E   F3E1                       BREQ    ??TransmitByte_UART0_0
    666                          ;
    667                  TxBuf_UART0[tmphead] = data; /* store data in buffer */
   \   00000010   E030                       LDI     R19,0
   \   00000012   01F9                       MOVW    R31 : R30,R19 : R18
   \   00000014   ....                       SUBI    R30,LOW((-(TxBuf_UART0) & 0xFFFF))
   \   00000016   ....                       SBCI    R31,(-(TxBuf_UART0) & 0xFFFF) >> 8
   \   00000018   8300                       ST      Z,R16
    668                  TxHead_UART0 = tmphead; /* store new index */
   \   0000001A   9320....                   STS     TxHead_UART0,R18
    669                  UCSR0B |= (1<<UDRIE0); /* enable UDRE interrupt */
   \   0000001E   9A55                       SBI     0x0A,0x05
    670                  }
   \   00000020   9508                       RET
    671          

   \                                 In segment CODE, align 2, keep-with-next
    672          unsigned char DataInReceiveBuffer( void )
    673                  {
    674                  return ( RxHead_UART0 != RxTail_UART0 );
   \   __nearfunc unsigned char DataInReceiveBuffer();
   \                     DataInReceiveBuffer:
   \   00000000   9100....                   LDS     R16,RxHead_UART0
   \   00000004   9110....                   LDS     R17,RxTail_UART0
   \   00000008   1701                       CP      R16,R17
   \   0000000A   F011                       BREQ    ??DataInReceiveBuffer_0
   \   0000000C   E001                       LDI     R16,1
   \   0000000E   9508                       RET
   \                     ??DataInReceiveBuffer_0:
   \   00000010   E000                       LDI     R16,0
   \   00000012   9508                       RET
    675                          /* return 0 (FALSE) if the receive buffer is empty */
    676                  }
    677          
    678          /*************************************/
    679          /* Function interrupt UART0_RX(void) */
    680          #pragma vector=UART0_RX_vect

   \                                 In segment CODE, align 2, keep-with-next
    681          static __interrupt void UART0_RX(void)
                                         ^
Warning[Pe177]: function "UART0_RX" was declared but never referenced
    682            {
   \   static __nearfunc __interrupt void UART0_RX();
   \                     UART0_RX:
   \   00000000   93BA                       ST      -Y,R27
   \   00000002   93AA                       ST      -Y,R26
   \   00000004   939A                       ST      -Y,R25
   \   00000006   938A                       ST      -Y,R24
   \   00000008   93FA                       ST      -Y,R31
   \   0000000A   93EA                       ST      -Y,R30
   \   0000000C   923A                       ST      -Y,R3
   \   0000000E   922A                       ST      -Y,R2
   \   00000010   921A                       ST      -Y,R1
   \   00000012   920A                       ST      -Y,R0
   \   00000014   937A                       ST      -Y,R23
   \   00000016   936A                       ST      -Y,R22
   \   00000018   935A                       ST      -Y,R21
   \   0000001A   934A                       ST      -Y,R20
   \   0000001C   933A                       ST      -Y,R19
   \   0000001E   932A                       ST      -Y,R18
   \   00000020   931A                       ST      -Y,R17
   \   00000022   930A                       ST      -Y,R16
   \   00000024   B7BF                       IN      R27,0x3F
   \   00000026   9723                       SBIW    R29 : R28,3
    683              unsigned char tmphead;
    684              unsigned char cTmp;
    685              unsigned char cByte;
    686              unsigned char cPERx;
    687              volatile unsigned char FlgErr;
    688              volatile int dTest;
    689          
    690          /* if enable flow control stream */
    691                switch (ContrStream_UART0)
   \   00000028   9100....                   LDS     R16,ContrStream_UART0
   \   0000002C   5000                       SUBI    R16,0
   \   0000002E   F041                       BREQ    ??UART0_RX_0
    692                 {
    693                  case 0:
    694                  break;
    695                  default:
    696                    switch (Enb_DTR0)
   \   00000030   9100....                   LDS     R16,Enb_DTR0
   \   00000034   950A                       DEC     R16
   \   00000036   F421                       BRNE    ??UART0_RX_0
    697                      {
    698                      case 1:
    699                      PORT_FLOW_D = PORT_FLOW_D | ( 1<< DTR0 ); // Pin port output
   \   00000038   9A8C                       SBI     0x11,0x04
    700                        if ( Bit_DTR0 & 0x01 == 0)
   \   0000003A   9100....                   LDS     R16,Bit_DTR0
    701                        {
    702                        ClrBit( PORT_FLOW_O, DTR0); // pin output set low 0
    703                        }
    704                        else
    705                        {
    706                        SetBit( PORT_FLOW_O, DTR0); // pin output set high 1
   \   0000003E   9A94                       SBI     0x12,0x04
    707                        };
    708                      break;
    709                      default:
    710                      break;
    711                      };
    712                  break;
    713                 };
    714          
    715                switch (ContrStream_UART0)
   \                     ??UART0_RX_0:
   \   00000040   9100....                   LDS     R16,ContrStream_UART0
   \   00000044   5000                       SUBI    R16,0
   \   00000046   F0C9                       BREQ    ??UART0_RX_1
    716                 {
    717                  case 0:
    718                  break;
    719                  default:
    720                    switch (Enb_DSR0)
   \   00000048   9100....                   LDS     R16,Enb_DSR0
   \   0000004C   950A                       DEC     R16
   \   0000004E   F449                       BRNE    ??UART0_RX_2
    721                      {
    722                      case 1:
    723                      PORT_FLOW_D = PORT_FLOW_D & ~( 1<< DSR0 ); // Pin port input
   \   00000050   988E                       CBI     0x11,0x06
    724                      Bit_DSR0 = ( (PORT_FLOW_I & ( 1<<DSR0)) >> DSR0 ); // Calculate bit
   \   00000052   B300                       IN      R16,0x10
   \   00000054   7400                       ANDI    R16,0x40
   \   00000056   0F00                       LSL     R16
   \   00000058   FB07                       BST     R16,7
   \   0000005A   0B00                       SBC     R16,R16
   \   0000005C   F900                       BLD     R16,0
   \   0000005E   9300....                   STS     Bit_DSR0,R16
    725                      break;
    726                      default:
    727                      break;
    728                      };
    729                    switch (Enb_CTS0)
   \                     ??UART0_RX_2:
   \   00000062   9100....                   LDS     R16,Enb_CTS0
   \   00000066   950A                       DEC     R16
   \   00000068   F441                       BRNE    ??UART0_RX_1
    730                      {
    731                      case 1:
    732                      PORT_FLOW_D = PORT_FLOW_D & ~( 1<< CTS0 ); // Pin port input
   \   0000006A   988B                       CBI     0x11,0x03
    733                      Bit_CTS0 = ( (PORT_FLOW_I & ( 1<<CTS0)) >> CTS0 ); // Calculate bit
   \   0000006C   B300                       IN      R16,0x10
   \   0000006E   7008                       ANDI    R16,0x08
   \   00000070   9505                       ASR     R16
   \   00000072   9505                       ASR     R16
   \   00000074   9505                       ASR     R16
   \   00000076   9300....                   STS     Bit_CTS0,R16
    734                      break;
    735                      default:
    736                      break;
    737                      };
    738                  break;
    739                 };
    740          
    741              FlgErr = 0;  //  if FlgErr=0 then  NO Errors Rx
   \                     ??UART0_RX_1:
   \   0000007A   E000                       LDI     R16,0
   \   0000007C   8308                       ST      Y,R16
    742          
    743              //cTmp = UCSR0A & 0x10;  // Test bit FE0=?
    744              if ( (UCSR0A & 0x10) != 0 )
   \   0000007E   9B5C                       SBIS    0x0B,0x04
   \   00000080   C005                       RJMP    ??UART0_RX_3
    745                {
    746                FlgErr = 1;         // '1' - Rx byte yes Error
   \   00000082   E001                       LDI     R16,1
   \   00000084   8308                       ST      Y,R16
    747                IncErrArr_UART0(1); // increment Rx_Tx_Err_UART0[1]
   \   00000086   E001                       LDI     R16,1
   \   00000088   E010                       LDI     R17,0
   \   0000008A   ....                       RCALL   IncErrArr_UART0
    748                };
    749          
    750               cByte = UDR0;                  // Read Byte Rx from UDR0
   \                     ??UART0_RX_3:
   \   0000008C   B1AC                       IN      R26,0x0C
    751          
    752              //cTmp = UCSR0A & 0x08; // Test bit OE0=?
    753               if ( (UCSR0A & 0x08 != 0) )
   \   0000008E   9B58                       SBIS    0x0B,0x00
   \   00000090   C005                       RJMP    ??UART0_RX_4
    754                {
    755                FlgErr = 1;
   \   00000092   E001                       LDI     R16,1
   \   00000094   8308                       ST      Y,R16
    756                IncErrArr_UART0(2); // increment Rx_Tx_Err_UART0[2]
   \   00000096   E002                       LDI     R16,2
   \   00000098   E010                       LDI     R17,0
   \   0000009A   ....                       RCALL   IncErrArr_UART0
    757                    };
    758          
    759              /* Calcul Parity for cByte and comperate Bit Parity   */
    760              switch ( SizeBit_UART0)
   \                     ??UART0_RX_4:
   \   0000009C   9100....                   LDS     R16,SizeBit_UART0
   \   000000A0   5000                       SUBI    R16,0
   \   000000A2   F019                       BREQ    ??UART0_RX_5
   \   000000A4   950A                       DEC     R16
   \   000000A6   F061                       BREQ    ??UART0_RX_6
   \   000000A8   C012                       RJMP    ??UART0_RX_7
    761               {
    762               case 0:    // Size 7 bits
    763               cTmp = CheckParity7( cByte) ;
   \                     ??UART0_RX_5:
   \   000000AA   2F0A                       MOV     R16,R26
   \   000000AC   ........                   CALL    CheckParity7
   \   000000B0   2F90                       MOV     R25,R16
    764               cPERx = cByte & (1<<7);  // Read 8 Bit cByte Rx
   \   000000B2   2F8A                       MOV     R24,R26
   \   000000B4   7880                       ANDI    R24,0x80
    765               cPERx = (cPERx>>7);      // cPERx = 0 or 1
   \   000000B6   2F08                       MOV     R16,R24
   \   000000B8   0F00                       LSL     R16
   \   000000BA   E080                       LDI     R24,0
   \   000000BC   1F88                       ROL     R24
   \   000000BE   C007                       RJMP    ??UART0_RX_7
    766               break;
    767               case 1:
    768               cTmp = CheckParity8( cByte) ;
   \                     ??UART0_RX_6:
   \   000000C0   2F0A                       MOV     R16,R26
   \   000000C2   ........                   CALL    CheckParity8
   \   000000C6   2F90                       MOV     R25,R16
    769               cPERx = (UCSR0B & 0x02) >> 1;  // Read 9 Bit Rx cPEx =0 or 1
   \   000000C8   B18A                       IN      R24,0x0A
   \   000000CA   7082                       ANDI    R24,0x02
   \   000000CC   9585                       ASR     R24
    770               break;
    771               default:
    772               break;
    773               };
    774                /* return
    775                   if cTmp = 0   then parity cByte
    776                   if cTmp = 255 then no parity
    777                cPEx =0 or 1
    778                */
    779          
    780                 switch (CheckParity_UART0)
   \                     ??UART0_RX_7:
   \   000000CE   9100....                   LDS     R16,CheckParity_UART0
   \   000000D2   950A                       DEC     R16
   \   000000D4   F039                       BREQ    ??UART0_RX_8
   \   000000D6   950A                       DEC     R16
   \   000000D8   F071                       BREQ    ??UART0_RX_9
   \   000000DA   950A                       DEC     R16
   \   000000DC   F0B1                       BREQ    ??UART0_RX_10
   \   000000DE   950A                       DEC     R16
   \   000000E0   F0E1                       BREQ    ??UART0_RX_11
   \   000000E2   C022                       RJMP    ??UART0_RX_12
    781               {
    782               case 0:
    783               break;
    784               case 1:  // Parity E
    785               cTmp = cTmp & 0x01;
   \                     ??UART0_RX_8:
   \   000000E4   7091                       ANDI    R25,0x01
    786               if (cPERx != cTmp)
   \   000000E6   1789                       CP      R24,R25
   \   000000E8   F0F9                       BREQ    ??UART0_RX_12
    787               {
    788               FlgErr =1;
   \   000000EA   E001                       LDI     R16,1
   \   000000EC   8308                       ST      Y,R16
    789               IncErrArr_UART0(3);   // increment Rx_Tx_Err_UART0[3]
   \   000000EE   E003                       LDI     R16,3
   \   000000F0   E010                       LDI     R17,0
   \   000000F2   ....                       RCALL   IncErrArr_UART0
   \   000000F4   C019                       RJMP    ??UART0_RX_12
    790               };
    791               break;
    792               case 2:  // Parity O
    793                cTmp = ~cTmp & 0x01;
   \                     ??UART0_RX_9:
   \   000000F6   9590                       COM     R25
   \   000000F8   7091                       ANDI    R25,0x01
    794                 if (cPERx != cTmp)
   \   000000FA   1789                       CP      R24,R25
   \   000000FC   F0A9                       BREQ    ??UART0_RX_12
    795                    {
    796                    FlgErr =1;
   \   000000FE   E001                       LDI     R16,1
   \   00000100   8308                       ST      Y,R16
    797                    IncErrArr_UART0(3);   // increment Rx_Tx_Err_UART0[3]
   \   00000102   E003                       LDI     R16,3
   \   00000104   E010                       LDI     R17,0
   \   00000106   ....                       RCALL   IncErrArr_UART0
   \   00000108   C00F                       RJMP    ??UART0_RX_12
    798                    };
    799               break;
    800               case 3:
    801               if (cPERx != 1)  // Control Mark
   \                     ??UART0_RX_10:
   \   0000010A   3081                       CPI     R24,1
   \   0000010C   F069                       BREQ    ??UART0_RX_12
    802               {
    803               FlgErr =1;
   \   0000010E   E001                       LDI     R16,1
   \   00000110   8308                       ST      Y,R16
    804               IncErrArr_UART0(3);   // increment Rx_Tx_Err_UART0[3]
   \   00000112   E003                       LDI     R16,3
   \   00000114   E010                       LDI     R17,0
   \   00000116   ....                       RCALL   IncErrArr_UART0
   \   00000118   C007                       RJMP    ??UART0_RX_12
    805               };
    806               break;
    807               case 4:
    808               if (cPERx != 0)  // Control Space
   \                     ??UART0_RX_11:
   \   0000011A   2388                       TST     R24
   \   0000011C   F029                       BREQ    ??UART0_RX_12
    809               {
    810               FlgErr =1;
   \   0000011E   E001                       LDI     R16,1
   \   00000120   8308                       ST      Y,R16
    811               IncErrArr_UART0(3);   // increment Rx_Tx_Err_UART0[3]
   \   00000122   E003                       LDI     R16,3
   \   00000124   E010                       LDI     R17,0
   \   00000126   ....                       RCALL   IncErrArr_UART0
    812               };
    813               break;
    814               default:
    815               break;
    816               };
    817          
    818              /* Check buffer Rx */
    819               if ( FlgErr == 0 )  // No Errors for Rx
   \                     ??UART0_RX_12:
   \   00000128   8108                       LD      R16,Y
   \   0000012A   2300                       TST     R16
   \   0000012C   F009                       BREQ    ??UART0_RX_13
   \   0000012E   C09B                       RJMP    ??UART0_RX_14
    820                  {
    821                  /* calculate buffer index */
    822                  tmphead = ( RxHead_UART0 + 1 ) & RX_BUFFER_MASK_UART0;
   \                     ??UART0_RX_13:
   \   00000130   9180....                   LDS     R24,RxHead_UART0
   \   00000134   9583                       INC     R24
   \   00000136   718F                       ANDI    R24,0x1F
    823          
    824                  if ( tmphead == RxTail_UART0 )
   \   00000138   9100....                   LDS     R16,RxTail_UART0
   \   0000013C   1780                       CP      R24,R16
   \   0000013E   F421                       BRNE    ??UART0_RX_15
    825                          {
    826                          IncErrArr_UART0(4); // increment Rx_Tx_Err_UART0[4]
   \   00000140   E004                       LDI     R16,4
   \   00000142   E010                       LDI     R17,0
   \   00000144   ....                       RCALL   IncErrArr_UART0
   \   00000146   C002                       RJMP    ??UART0_RX_16
    827                          }
    828                  else
    829                  RxHead_UART0 = tmphead; /* store new index */
   \                     ??UART0_RX_15:
   \   00000148   9380....                   STS     RxHead_UART0,R24
    830                  {
    831                     switch (ContrStream_UART0) // Begin Switch ContrStream_UART0
   \                     ??UART0_RX_16:
   \   0000014C   9100....                   LDS     R16,ContrStream_UART0
   \   00000150   950A                       DEC     R16
   \   00000152   F009                       BREQ    ??UART0_RX_17
   \   00000154   C051                       RJMP    ??UART0_RX_18
    832                          {
    833                           case 0:
    834                           break;
    835                           case 1:  // Yes control stream
    836                                if ( RxHead_UART0 > (RX_BUFFER_SIZE_UART0-4) )
   \                     ??UART0_RX_17:
   \   00000156   9100....                   LDS     R16,RxHead_UART0
   \   0000015A   310D                       CPI     R16,29
   \   0000015C   F050                       BRCS    ??UART0_RX_19
    837                                  {
    838                                            /* Signal DTR0 = 0 Stop Tx from PC IBM */
    839                                            /* if enable flow control stream */
    840                                            switch (Enb_RTS0)
   \   0000015E   9100....                   LDS     R16,Enb_RTS0
   \   00000162   950A                       DEC     R16
   \   00000164   F479                       BRNE    ??UART0_RX_20
    841                                            {
    842                                            case 1:
    843                                            PORT_FLOW_D = PORT_FLOW_D  | ( 1<< RTS0 ); // Pin port output
   \   00000166   9A8D                       SBI     0x11,0x05
    844                                            SetBit( PORT_FLOW_O, RTS0); // pin output set hing 1
   \   00000168   9A95                       SBI     0x12,0x05
    845                                            Bit_RTS0 = 1;
   \   0000016A   E001                       LDI     R16,1
   \   0000016C   9300....                   STS     Bit_RTS0,R16
   \   00000170   C009                       RJMP    ??UART0_RX_20
    846                                            break;
    847                                            default:
    848                                            break;
    849                                            };
    850                                   }
    851                                 else
    852                                 {
    853                                          /* Signal DTR0 = 0 Stop Tx from PC IBM */
    854                                          /* if enable flow control stream */
    855                                          switch (Enb_RTS0)
   \                     ??UART0_RX_19:
   \   00000172   9100....                   LDS     R16,Enb_RTS0
   \   00000176   950A                       DEC     R16
   \   00000178   F429                       BRNE    ??UART0_RX_20
    856                                           {
    857                                          case 1:
    858                                          PORT_FLOW_D = PORT_FLOW_D | ( 1<< RTS0 ); // Pin port output
   \   0000017A   9A8D                       SBI     0x11,0x05
    859                                          ClrBit( PORT_FLOW_O, RTS0); // pin output set high 1
   \   0000017C   9895                       CBI     0x12,0x05
    860                                          Bit_RTS0 = 0;
   \   0000017E   E000                       LDI     R16,0
   \   00000180   9300....                   STS     Bit_RTS0,R16
    861                                          break;
    862                                          default:
    863                                          break;
    864                                           };
    865          
    866                                 };  // End if
    867          
    868                                switch(Enb_XON_XOFF_Rx_UART0) // Begin Switch Enb_XON_XOFF_Rx_UART0
   \                     ??UART0_RX_20:
   \   00000184   9100....                   LDS     R16,Enb_XON_XOFF_Rx_UART0
   \   00000188   950A                       DEC     R16
   \   0000018A   F5B1                       BRNE    ??UART0_RX_18
    869                                  {
    870                                  case 0:
    871                                  break;
    872                                  case 1:
    873                                        if ( RxHead_UART0 > (RX_BUFFER_SIZE_UART0-4) )
   \   0000018C   9100....                   LDS     R16,RxHead_UART0
   \   00000190   310D                       CPI     R16,29
   \   00000192   F140                       BRCS    ??UART0_RX_21
    874                                        {
    875                                            switch( Count_XOFF_Rx_UART0)
   \   00000194   9100....                   LDS     R16,Count_XOFF_Rx_UART0
   \   00000198   5000                       SUBI    R16,0
   \   0000019A   F039                       BREQ    ??UART0_RX_22
   \   0000019C   5001                       SUBI    R16,1
   \   0000019E   F0D8                       BRCS    ??UART0_RX_23
   \   000001A0   5004                       SUBI    R16,4
   \   000001A2   F060                       BRCS    ??UART0_RX_24
   \   000001A4   5000                       SUBI    R16,0
   \   000001A6   F081                       BREQ    ??UART0_RX_25
   \   000001A8   C016                       RJMP    ??UART0_RX_23
    876                                            {
    877                                            case 0:
    878                                            TransmitByte_UART0(Sym_XOFF);
   \                     ??UART0_RX_22:
   \   000001AA   9100....                   LDS     R16,Sym_XOFF
   \   000001AE   ....                       RCALL   TransmitByte_UART0
    879                                            Count_XOFF_Rx_UART0++;
   \   000001B0   ....                       LDI     R30,LOW(Count_XOFF_Rx_UART0)
   \   000001B2   ....                       LDI     R31,(Count_XOFF_Rx_UART0) >> 8
   \   000001B4   8100                       LD      R16,Z
   \   000001B6   9503                       INC     R16
   \   000001B8   8300                       ST      Z,R16
   \   000001BA   C01E                       RJMP    ??UART0_RX_18
    880                                            break;
    881                                            case 1:
    882                                            case 2:
    883                                            case 3:
    884                                            case 4:
    885                                            Count_XOFF_Rx_UART0++;  //increment counter
   \                     ??UART0_RX_24:
   \   000001BC   ....                       LDI     R30,LOW(Count_XOFF_Rx_UART0)
   \   000001BE   ....                       LDI     R31,(Count_XOFF_Rx_UART0) >> 8
   \   000001C0   8100                       LD      R16,Z
   \   000001C2   9503                       INC     R16
   \   000001C4   8300                       ST      Z,R16
   \   000001C6   C018                       RJMP    ??UART0_RX_18
    886                                            break;
    887                                            case 5:
    888                                            TransmitByte_UART0(Sym_XOFF);
   \                     ??UART0_RX_25:
   \   000001C8   9100....                   LDS     R16,Sym_XOFF
   \   000001CC   ....                       RCALL   TransmitByte_UART0
    889                                            Count_XOFF_Rx_UART0 = 1;
   \   000001CE   E001                       LDI     R16,1
   \   000001D0   9300....                   STS     Count_XOFF_Rx_UART0,R16
   \   000001D4   C011                       RJMP    ??UART0_RX_18
    890                                            break;
    891                                            default:
    892                                            TransmitByte_UART0(Sym_XOFF);
   \                     ??UART0_RX_23:
   \   000001D6   9100....                   LDS     R16,Sym_XOFF
   \   000001DA   ....                       RCALL   TransmitByte_UART0
    893                                            Count_XOFF_Rx_UART0 = 1;
   \   000001DC   E001                       LDI     R16,1
   \   000001DE   9300....                   STS     Count_XOFF_Rx_UART0,R16
   \   000001E2   C00A                       RJMP    ??UART0_RX_18
    894                                            break;
    895                                            };
    896                                        }
    897                                        else
    898                                        {
    899                                          switch( Count_XOFF_Rx_UART0)
   \                     ??UART0_RX_21:
   \   000001E4   9100....                   LDS     R16,Count_XOFF_Rx_UART0
   \   000001E8   5000                       SUBI    R16,0
   \   000001EA   F031                       BREQ    ??UART0_RX_18
    900                                          {
    901                                          case 0:
    902                                          break;
    903                                          default:
    904                                          TransmitByte_UART0(Sym_XON);
   \   000001EC   9100....                   LDS     R16,Sym_XON
   \   000001F0   ....                       RCALL   TransmitByte_UART0
    905                                          Count_XOFF_Rx_UART0 = 0;
   \   000001F2   E000                       LDI     R16,0
   \   000001F4   9300....                   STS     Count_XOFF_Rx_UART0,R16
    906                                          break;
    907                                          };
    908                                        };
    909                                  break;
    910                                  default:
    911                                  break;
    912                                  };  //// End Switch ( Enb_XON_XOFF_Rx_UART0 )
    913          
    914                           break;
    915                           default:
    916                           break;
    917                           };  // End Switch ( ContrStream_UART0 )
    918                  };
    919                  if ( FlgErr == 0)
   \                     ??UART0_RX_18:
   \   000001F8   8108                       LD      R16,Y
   \   000001FA   2300                       TST     R16
   \   000001FC   F4D9                       BRNE    ??UART0_RX_26
    920                  {
    921                  RxBuf_UART0[tmphead] = cByte; /* store received data in buffer */
   \   000001FE   E090                       LDI     R25,0
   \   00000200   01FC                       MOVW    R31 : R30,R25 : R24
   \   00000202   ....                       SUBI    R30,LOW((-(RxBuf_UART0) & 0xFFFF))
   \   00000204   ....                       SBCI    R31,(-(RxBuf_UART0) & 0xFFFF) >> 8
   \   00000206   83A0                       ST      Z,R26
    922          
    923                    switch (ContrStream_UART0)
   \   00000208   9100....                   LDS     R16,ContrStream_UART0
   \   0000020C   950A                       DEC     R16
   \   0000020E   F491                       BRNE    ??UART0_RX_26
    924                     {
    925                     case 1:
    926                       switch (Enb_XON_XOFF_Tx_UART0)
   \   00000210   9100....                   LDS     R16,Enb_XON_XOFF_Tx_UART0
   \   00000214   950A                       DEC     R16
   \   00000216   F471                       BRNE    ??UART0_RX_26
    927                        {
    928                        case 0:
    929                        break;
    930                        case 1:
    931                          if ( cByte == Sym_XOFF)
   \   00000218   9100....                   LDS     R16,Sym_XOFF
   \   0000021C   17A0                       CP      R26,R16
   \   0000021E   F419                       BRNE    ??UART0_RX_27
    932                          {
    933                          Count_XOFF_Tx_UART0 = 1;  // Disable Transmit
   \   00000220   E001                       LDI     R16,1
   \   00000222   9300....                   STS     Count_XOFF_Tx_UART0,R16
    934                          };
    935                          if ( cByte == Sym_XON)
   \                     ??UART0_RX_27:
   \   00000226   9100....                   LDS     R16,Sym_XON
   \   0000022A   17A0                       CP      R26,R16
   \   0000022C   F419                       BRNE    ??UART0_RX_26
    936                          {
    937                          Count_XOFF_Tx_UART0 = 0;  // Enable Transmit
   \   0000022E   E000                       LDI     R16,0
   \   00000230   9300....                   STS     Count_XOFF_Tx_UART0,R16
    938                          };
    939                        break;
    940                        default:
    941                        break;
    942                        };
    943                     break;
    944                     default:
    945                     break;
    946                     };
    947                  };
    948          
    949                  /* if Mode Echo then Tx Byte*/
    950                   if ( Enb_Echo_UART0 == 1)
   \                     ??UART0_RX_26:
   \   00000234   9100....                   LDS     R16,Enb_Echo_UART0
   \   00000238   3001                       CPI     R16,1
   \   0000023A   F411                       BRNE    ??UART0_RX_28
    951                   {
    952                   TransmitByte_UART0(cByte);
   \   0000023C   2F0A                       MOV     R16,R26
   \   0000023E   ....                       RCALL   TransmitByte_UART0
    953                   };
    954          
    955                  if ( Enb_Err_UART0 == 1 )
   \                     ??UART0_RX_28:
   \   00000240   9100....                   LDS     R16,Enb_Err_UART0
   \   00000244   3001                       CPI     R16,1
   \   00000246   F509                       BRNE    ??UART0_RX_29
    956                    {
    957                    Count_Rx_UART0++;
   \   00000248   ....                       LDI     R30,LOW(Count_Rx_UART0)
   \   0000024A   ....                       LDI     R31,(Count_Rx_UART0) >> 8
   \   0000024C   8100                       LD      R16,Z
   \   0000024E   8111                       LDD     R17,Z+1
   \   00000250   8122                       LDD     R18,Z+2
   \   00000252   8133                       LDD     R19,Z+3
   \   00000254   5F0F                       SUBI    R16,255
   \   00000256   4F1F                       SBCI    R17,255
   \   00000258   4F2F                       SBCI    R18,255
   \   0000025A   4F3F                       SBCI    R19,255
   \   0000025C   8300                       ST      Z,R16
   \   0000025E   8311                       STD     Z+1,R17
   \   00000260   8322                       STD     Z+2,R18
   \   00000262   8333                       STD     Z+3,R19
   \   00000264   C012                       RJMP    ??UART0_RX_29
    958                    };
    959                  }
    960                  else        // Yes Errors Rx for UART0
    961                  {
    962                  if ( Enb_Err_UART0 == 1 )
   \                     ??UART0_RX_14:
   \   00000266   9100....                   LDS     R16,Enb_Err_UART0
   \   0000026A   3001                       CPI     R16,1
   \   0000026C   F471                       BRNE    ??UART0_RX_29
    963                    {
    964                    Count_Rx_Err_UART0++;
   \   0000026E   ....                       LDI     R30,LOW(Count_Rx_Err_UART0)
   \   00000270   ....                       LDI     R31,(Count_Rx_Err_UART0) >> 8
   \   00000272   8100                       LD      R16,Z
   \   00000274   8111                       LDD     R17,Z+1
   \   00000276   8122                       LDD     R18,Z+2
   \   00000278   8133                       LDD     R19,Z+3
   \   0000027A   5F0F                       SUBI    R16,255
   \   0000027C   4F1F                       SBCI    R17,255
   \   0000027E   4F2F                       SBCI    R18,255
   \   00000280   4F3F                       SBCI    R19,255
   \   00000282   8300                       ST      Z,R16
   \   00000284   8311                       STD     Z+1,R17
   \   00000286   8322                       STD     Z+2,R18
   \   00000288   8333                       STD     Z+3,R19
    965                    };
    966                  };
    967            }
   \                     ??UART0_RX_29:
   \   0000028A   9623                       ADIW    R29 : R28,3
   \   0000028C   BFBF                       OUT     0x3F,R27
   \   0000028E   9109                       LD      R16,Y+
   \   00000290   9119                       LD      R17,Y+
   \   00000292   9129                       LD      R18,Y+
   \   00000294   9139                       LD      R19,Y+
   \   00000296   9149                       LD      R20,Y+
   \   00000298   9159                       LD      R21,Y+
   \   0000029A   9169                       LD      R22,Y+
   \   0000029C   9179                       LD      R23,Y+
   \   0000029E   9009                       LD      R0,Y+
   \   000002A0   9019                       LD      R1,Y+
   \   000002A2   9029                       LD      R2,Y+
   \   000002A4   9039                       LD      R3,Y+
   \   000002A6   91E9                       LD      R30,Y+
   \   000002A8   91F9                       LD      R31,Y+
   \   000002AA   9189                       LD      R24,Y+
   \   000002AC   9199                       LD      R25,Y+
   \   000002AE   91A9                       LD      R26,Y+
   \   000002B0   91B9                       LD      R27,Y+
   \   000002B2   9518                       RETI
    968          /* End function interrupt UART0_RX(void) */
    969          /*****************************************/
    970          
    971          
    972          /****************************************/
    973          /* This method interrupt event TX Empty */
    974          #pragma vector=UART0_UDRE_vect

   \                                 In segment CODE, align 2, keep-with-next
    975          static __interrupt void UART0_UDRE(void)
                                         ^
Warning[Pe177]: function "UART0_UDRE" was declared but never referenced
    976              {
   \   static __nearfunc __interrupt void UART0_UDRE();
   \                     UART0_UDRE:
   \   00000000   939A                       ST      -Y,R25
   \   00000002   938A                       ST      -Y,R24
   \   00000004   93FA                       ST      -Y,R31
   \   00000006   93EA                       ST      -Y,R30
   \   00000008   923A                       ST      -Y,R3
   \   0000000A   922A                       ST      -Y,R2
   \   0000000C   921A                       ST      -Y,R1
   \   0000000E   920A                       ST      -Y,R0
   \   00000010   937A                       ST      -Y,R23
   \   00000012   936A                       ST      -Y,R22
   \   00000014   935A                       ST      -Y,R21
   \   00000016   934A                       ST      -Y,R20
   \   00000018   933A                       ST      -Y,R19
   \   0000001A   932A                       ST      -Y,R18
   \   0000001C   931A                       ST      -Y,R17
   \   0000001E   930A                       ST      -Y,R16
   \   00000020   B79F                       IN      R25,0x3F
    977              unsigned char tmptail;
    978              unsigned char cTmp;
    979              unsigned char cByte;
    980              unsigned char cPEx;
    981              unsigned char EnbTx;
    982          
    983              EnbTx = 1;  // Yes Enable Tx
   \   00000022   E001                       LDI     R16,1
    984          
    985          /* if enable flow control stream for signal DTR0 */
    986                switch (ContrStream_UART0) // Begin  switch (ContrStream_UART0)
   \   00000024   9110....                   LDS     R17,ContrStream_UART0
   \   00000028   951A                       DEC     R17
   \   0000002A   F441                       BRNE    ??UART0_UDRE_0
    987                 {
    988                  case 1:
    989                    switch (Enb_DTR0)// Begin switch (Enb_DTR0)
   \   0000002C   9110....                   LDS     R17,Enb_DTR0
   \   00000030   951A                       DEC     R17
   \   00000032   F421                       BRNE    ??UART0_UDRE_0
    990                      {
    991                      case 1:
    992                      PORT_FLOW_D = PORT_FLOW_D | ( 1<< DTR0 ); // Pin port output
   \   00000034   9A8C                       SBI     0x11,0x04
    993                        if ( Bit_DTR0 & 0x01 == 0)
   \   00000036   9110....                   LDS     R17,Bit_DTR0
    994                        {
    995                        ClrBit( PORT_FLOW_O, DTR0); // pin output set low 0
    996                         }
    997                        else
    998                        {
    999                        SetBit( PORT_FLOW_O, DTR0); // pin output set high 1
   \   0000003A   9A94                       SBI     0x12,0x04
   1000                        };
   1001                      break;
   1002                      default:
   1003                      break;
   1004                      };// End switch (Enb_DTR0)
   1005                  break;
   1006                  default:
   1007                  break;
   1008                 };// Begin  switch (ContrStream_UART0)
   1009          
   1010          /* if enable flow control stream */
   1011                switch (ContrStream_UART0) // Begin switch (ContrStream_UART0)
   \                     ??UART0_UDRE_0:
   \   0000003C   9110....                   LDS     R17,ContrStream_UART0
   \   00000040   951A                       DEC     R17
   \   00000042   F441                       BRNE    ??UART0_UDRE_1
   1012                 {
   1013                  case 1:
   1014                    switch (Enb_RTS0)
   \   00000044   9110....                   LDS     R17,Enb_RTS0
   \   00000048   951A                       DEC     R17
   \   0000004A   F421                       BRNE    ??UART0_UDRE_1
   1015                      {
   1016                      case 1:
   1017                      PORT_FLOW_D = PORT_FLOW_D | ( 1<< RTS0 ); // Pin port output
   \   0000004C   9A8D                       SBI     0x11,0x05
   1018                        if ( Bit_RTS0 & 0x01 == 0)
   \   0000004E   9110....                   LDS     R17,Bit_RTS0
   1019                        {
   1020                        ClrBit( PORT_FLOW_O, RTS0); // pin output set low 0
   1021                         }
   1022                        else
   1023                        {
   1024                        SetBit( PORT_FLOW_O, RTS0); // pin output set high 1
   \   00000052   9A95                       SBI     0x12,0x05
   1025                        };
   1026                      break;
   1027                      default:
   1028                      break;
   1029                      };
   1030                  break;
   1031                  default:
   1032                  break;
   1033                 }; // End switch switch (ContrStream_UART0)
   1034          
   1035              /* if enable flow control stream */
   1036                switch (ContrStream_UART0)// Begin  switch (ContrStream_UART0)
   \                     ??UART0_UDRE_1:
   \   00000054   9110....                   LDS     R17,ContrStream_UART0
   \   00000058   951A                       DEC     R17
   \   0000005A   F4C9                       BRNE    ??UART0_UDRE_2
   1037                 {
   1038                  case 1:
   1039                    switch (Enb_DSR0)
   \   0000005C   9110....                   LDS     R17,Enb_DSR0
   \   00000060   951A                       DEC     R17
   \   00000062   F449                       BRNE    ??UART0_UDRE_3
   1040                      {
   1041                      case 1:
   1042                      PORT_FLOW_D = PORT_FLOW_D & ~( 1<< DSR0 ); // Pin port input
   \   00000064   988E                       CBI     0x11,0x06
   1043                      Bit_DSR0 = ( (PORT_FLOW_I & ( 1<<DSR0)) >> DSR0 ); // Calculate bit
   \   00000066   B310                       IN      R17,0x10
   \   00000068   7410                       ANDI    R17,0x40
   \   0000006A   0F11                       LSL     R17
   \   0000006C   FB17                       BST     R17,7
   \   0000006E   0B11                       SBC     R17,R17
   \   00000070   F910                       BLD     R17,0
   \   00000072   9310....                   STS     Bit_DSR0,R17
   1044                      break;
   1045                      default:
   1046                      break;
   1047                      };
   1048                    switch (Enb_CTS0)
   \                     ??UART0_UDRE_3:
   \   00000076   9110....                   LDS     R17,Enb_CTS0
   \   0000007A   951A                       DEC     R17
   \   0000007C   F441                       BRNE    ??UART0_UDRE_2
   1049                      {
   1050                      case 1:
   1051                      PORT_FLOW_D = PORT_FLOW_D & ~( 1<< CTS0 ); // Pin port input
   \   0000007E   988B                       CBI     0x11,0x03
   1052                      Bit_CTS0 = ( (PORT_FLOW_I & ( 1<<CTS0)) >> CTS0 ); // Calculate bit
   \   00000080   B310                       IN      R17,0x10
   \   00000082   7018                       ANDI    R17,0x08
   \   00000084   9515                       ASR     R17
   \   00000086   9515                       ASR     R17
   \   00000088   9515                       ASR     R17
   \   0000008A   9310....                   STS     Bit_CTS0,R17
   1053                      break;
   1054                      default:
   1055                      break;
   1056                      };
   1057                  break;
   1058                  default:
   1059                  break;
   1060                 };// End  switch (ContrStream_UART0)
   1061          
   1062              /* ?? Test Controls stream UART0 */
   1063          
   1064              switch ( ContrStream_UART0 )
   \                     ??UART0_UDRE_2:
   \   0000008E   9110....                   LDS     R17,ContrStream_UART0
   \   00000092   951A                       DEC     R17
   \   00000094   F569                       BRNE    ??UART0_UDRE_4
   1065                {
   1066                case 1:
   1067                  if (Enb_XON_XOFF_Tx_UART0 == 1)
   \   00000096   9110....                   LDS     R17,Enb_XON_XOFF_Tx_UART0
   \   0000009A   3011                       CPI     R17,1
   \   0000009C   F429                       BRNE    ??UART0_UDRE_5
   1068                  {
   1069                    switch (Count_XOFF_Tx_UART0)
   \   0000009E   9110....                   LDS     R17,Count_XOFF_Tx_UART0
   \   000000A2   5010                       SUBI    R17,0
   \   000000A4   F009                       BREQ    ??UART0_UDRE_5
   1070                      {
   1071                      case 0:
   1072                      break;
   1073                      default:
   1074                      EnbTx = 0;  // Disable Tx software flow
   \   000000A6   E000                       LDI     R16,0
   1075                      break;
   1076                      };
   1077                  };
   1078                  if ( Enb_CTS0 == 1)
   \                     ??UART0_UDRE_5:
   \   000000A8   9110....                   LDS     R17,Enb_CTS0
   \   000000AC   3011                       CPI     R17,1
   \   000000AE   F429                       BRNE    ??UART0_UDRE_6
   1079                  {
   1080                    switch (Bit_CTS0)
   \   000000B0   9110....                   LDS     R17,Bit_CTS0
   \   000000B4   951A                       DEC     R17
   \   000000B6   F409                       BRNE    ??UART0_UDRE_6
   1081                      {
   1082                      case 1:
   1083                      EnbTx = 0;  // Disable Tx hardware flow
   \   000000B8   E000                       LDI     R16,0
   1084                      break;
   1085                      default:
   1086                      break;
   1087                      };
   1088                   };
   1089                   if (Enb_DSR0 == 1)
   \                     ??UART0_UDRE_6:
   \   000000BA   9110....                   LDS     R17,Enb_DSR0
   \   000000BE   3011                       CPI     R17,1
   \   000000C0   F429                       BRNE    ??UART0_UDRE_7
   1090                   {
   1091                    switch (Bit_DSR0)
   \   000000C2   9110....                   LDS     R17,Bit_DSR0
   \   000000C6   951A                       DEC     R17
   \   000000C8   F409                       BRNE    ??UART0_UDRE_7
   1092                      {
   1093                      case 1:
   1094                      EnbTx = 0;  // Disable Tx hardware flow
   \   000000CA   E000                       LDI     R16,0
   1095                      break;
   1096                      default:
   1097                      break;
   1098                      };
   1099                    };
   1100                   if (Enb_RTS0 == 1)
   \                     ??UART0_UDRE_7:
   \   000000CC   9110....                   LDS     R17,Enb_RTS0
   \   000000D0   3011                       CPI     R17,1
   \   000000D2   F429                       BRNE    ??UART0_UDRE_8
   1101                   {
   1102                    switch (Bit_RTS0)
   \   000000D4   9110....                   LDS     R17,Bit_RTS0
   \   000000D8   951A                       DEC     R17
   \   000000DA   F409                       BRNE    ??UART0_UDRE_8
   1103                      {
   1104                      case 1:
   1105                      EnbTx = 0;  // Disable Tx hardware flow
   \   000000DC   E000                       LDI     R16,0
   1106                      break;
   1107                      default:
   1108                      break;
   1109                      };
   1110                    };
   1111                    if (Enb_DTR0 == 1)
   \                     ??UART0_UDRE_8:
   \   000000DE   9110....                   LDS     R17,Enb_DTR0
   \   000000E2   3011                       CPI     R17,1
   \   000000E4   F429                       BRNE    ??UART0_UDRE_4
   1112                    {
   1113                    switch (Bit_DTR0)
   \   000000E6   9110....                   LDS     R17,Bit_DTR0
   \   000000EA   951A                       DEC     R17
   \   000000EC   F409                       BRNE    ??UART0_UDRE_4
   1114                      {
   1115                      case 1:
   1116                      EnbTx = 0;  // Disable Tx hardware flow
   \   000000EE   E000                       LDI     R16,0
   1117                      break;
   1118                      default:
   1119                      break;
   1120                      };
   1121                    };
   1122                break;
   1123                default:
   1124                break;
   1125                };
   1126          
   1127               /* Enable Yes then  Transmit Byte */
   1128               if ( EnbTx == 1 )
   \                     ??UART0_UDRE_4:
   \   000000F0   3001                       CPI     R16,1
   \   000000F2   F009                       BREQ    ??UART0_UDRE_9
   \   000000F4   C05B                       RJMP    ??UART0_UDRE_10
   1129               {
   1130                  /* check if all data is transmitted */
   1131                  if ( TxHead_UART0 != TxTail_UART0 )
   \                     ??UART0_UDRE_9:
   \   000000F6   9100....                   LDS     R16,TxHead_UART0
   \   000000FA   9110....                   LDS     R17,TxTail_UART0
   \   000000FE   1701                       CP      R16,R17
   \   00000100   F409                       BRNE    ??UART0_UDRE_11
   \   00000102   C052                       RJMP    ??UART0_UDRE_12
   1132                     {
   1133                     /* calculate buffer index */
   1134                     tmptail = ( TxTail_UART0 + 1 ) & TX_BUFFER_MASK_UART0;
   \                     ??UART0_UDRE_11:
   \   00000104   9100....                   LDS     R16,TxTail_UART0
   \   00000108   9503                       INC     R16
   \   0000010A   710F                       ANDI    R16,0x1F
   1135                     TxTail_UART0 = tmptail; /* store new index */
   \   0000010C   9300....                   STS     TxTail_UART0,R16
   1136                     cByte = TxBuf_UART0[tmptail];    // Byte for Tx UART0
   \   00000110   E010                       LDI     R17,0
   \   00000112   01F8                       MOVW    R31 : R30,R17 : R16
   \   00000114   ....                       SUBI    R30,LOW((-(TxBuf_UART0) & 0xFFFF))
   \   00000116   ....                       SBCI    R31,(-(TxBuf_UART0) & 0xFFFF) >> 8
   \   00000118   8180                       LD      R24,Z
   1137          
   1138                     /* Calculate Parity for mode SizeBit */
   1139                    switch ( SizeBit_UART0)
   \   0000011A   9100....                   LDS     R16,SizeBit_UART0
   \   0000011E   5000                       SUBI    R16,0
   \   00000120   F019                       BREQ    ??UART0_UDRE_13
   \   00000122   950A                       DEC     R16
   \   00000124   F029                       BREQ    ??UART0_UDRE_14
   \   00000126   C008                       RJMP    ??UART0_UDRE_15
   1140                        {
   1141                        case 0:
   1142                        cTmp = CheckParity7( cByte) ;
   \                     ??UART0_UDRE_13:
   \   00000128   2F08                       MOV     R16,R24
   \   0000012A   ........                   CALL    CheckParity7
   \   0000012E   C007                       RJMP    ??UART0_UDRE_16
   1143                        break;
   1144                        case 1:
   1145                        cTmp = CheckParity8( cByte) ;
   \                     ??UART0_UDRE_14:
   \   00000130   2F08                       MOV     R16,R24
   \   00000132   ........                   CALL    CheckParity8
   \   00000136   C003                       RJMP    ??UART0_UDRE_16
   1146                        break;
   1147                        default:
   1148                        cTmp = CheckParity8( cByte) ;
   \                     ??UART0_UDRE_15:
   \   00000138   2F08                       MOV     R16,R24
   \   0000013A   ........                   CALL    CheckParity8
   1149                        break;
   1150                        };
   1151          
   1152                     /* For Modes CheckParity_UART0 */
   1153                        switch (CheckParity_UART0)
   \                     ??UART0_UDRE_16:
   \   0000013E   9110....                   LDS     R17,CheckParity_UART0
   \   00000142   5010                       SUBI    R17,0
   \   00000144   F0D1                       BREQ    ??UART0_UDRE_17
   \   00000146   951A                       DEC     R17
   \   00000148   F039                       BREQ    ??UART0_UDRE_18
   \   0000014A   951A                       DEC     R17
   \   0000014C   F059                       BREQ    ??UART0_UDRE_19
   \   0000014E   951A                       DEC     R17
   \   00000150   F079                       BREQ    ??UART0_UDRE_20
   \   00000152   951A                       DEC     R17
   \   00000154   F079                       BREQ    ??UART0_UDRE_21
   \   00000156   C010                       RJMP    ??UART0_UDRE_22
   1154                        {
   1155                        case 0:
   1156                        break;
   1157                        case 1:
   1158                          if ( cTmp == 0) // cByte parity
   \                     ??UART0_UDRE_18:
   \   00000158   2300                       TST     R16
   \   0000015A   F411                       BRNE    ??UART0_UDRE_23
   1159                          {
   1160                           UCSR0B = UCSR0B & ~(1<<TXB80);  // TXB80 = 0
   \   0000015C   9850                       CBI     0x0A,0x00
   \   0000015E   C00D                       RJMP    ??UART0_UDRE_17
   1161                          }
   1162                          else
   1163                          {
   1164                          UCSR0B = UCSR0B | (1<<TXB80);   // TXB80 = 1
   \                     ??UART0_UDRE_23:
   \   00000160   9A50                       SBI     0x0A,0x00
   \   00000162   C00B                       RJMP    ??UART0_UDRE_17
   1165                          };
   1166                        break;
   1167                        case 2:
   1168          
   1169                          if ( cTmp == 0) // cByte parity
   \                     ??UART0_UDRE_19:
   \   00000164   2300                       TST     R16
   \   00000166   F411                       BRNE    ??UART0_UDRE_24
   1170                          {
   1171                           UCSR0B = UCSR0B | (1<<TXB80);   // TXB80 = 1
   \   00000168   9A50                       SBI     0x0A,0x00
   \   0000016A   C007                       RJMP    ??UART0_UDRE_17
   1172                          }
   1173                          else
   1174                          {
   1175                           UCSR0B = UCSR0B & ~(1<<TXB80);  // TXB80 = 0
   \                     ??UART0_UDRE_24:
   \   0000016C   9850                       CBI     0x0A,0x00
   \   0000016E   C005                       RJMP    ??UART0_UDRE_17
   1176                          };
   1177                        break;
   1178                        case 3: // Mark
   1179                        UCSR0B = UCSR0B | (1<<TXB80);   // TXB80 = 1
   \                     ??UART0_UDRE_20:
   \   00000170   9A50                       SBI     0x0A,0x00
   \   00000172   C003                       RJMP    ??UART0_UDRE_17
   1180                        break;
   1181                        case 4: // Space
   1182                        UCSR0B = UCSR0B & ~(1<<TXB80);  // TXB80 = 0
   \                     ??UART0_UDRE_21:
   \   00000174   9850                       CBI     0x0A,0x00
   \   00000176   C001                       RJMP    ??UART0_UDRE_17
   1183                        break;
   1184                        default:
   1185                        UCSR0B = UCSR0B | (1<<TXB80);   // TXB80 = 1
   \                     ??UART0_UDRE_22:
   \   00000178   9A50                       SBI     0x0A,0x00
   1186                        break;
   1187                        };
   1188                    /* Set bits for mode SizeBit */
   1189                        cPEx = UCSR0B & 0x01;    // Calculate bit TXB80
   \                     ??UART0_UDRE_17:
   \   0000017A   E010                       LDI     R17,0
   \   0000017C   9950                       SBIC    0x0A,0x00
   \   0000017E   9513                       INC     R17
   1190                                                 // cPEx = 0 or 1
   1191                    switch ( SizeBit_UART0)
   \   00000180   9120....                   LDS     R18,SizeBit_UART0
   \   00000184   5020                       SUBI    R18,0
   \   00000186   F019                       BREQ    ??UART0_UDRE_26
   \   00000188   952A                       DEC     R18
   \   0000018A   F059                       BREQ    ??UART0_UDRE_27
   \   0000018C   C00B                       RJMP    ??UART0_UDRE_28
   1192                        {
   1193                        case 0: // Mode data size 7 bits
   1194                        cTmp = cByte | (0x80);     // b7=1
   \                     ??UART0_UDRE_26:
   \   0000018E   2F08                       MOV     R16,R24
   \   00000190   6800                       ORI     R16,0x80
   1195                          if ( cPEx == 0)
   \   00000192   2311                       TST     R17
   \   00000194   F419                       BRNE    ??UART0_UDRE_29
   1196                          {
   1197                           ClrBit(cTmp,7);
   \   00000196   770F                       ANDI    R16,0x7F
   \   00000198   E010                       LDI     R17,0
   \   0000019A   C004                       RJMP    ??UART0_UDRE_28
   1198                          }
   1199                          else
   1200                          {
   1201                           SetBit(cTmp,7);
   \                     ??UART0_UDRE_29:
   \   0000019C   6800                       ORI     R16,0x80
   \   0000019E   E011                       LDI     R17,1
   \   000001A0   C001                       RJMP    ??UART0_UDRE_28
   1202                           };
   1203                        break;
   1204                        case 1: // Mode data size 7 bits
   1205                        cTmp = cByte;
   \                     ??UART0_UDRE_27:
   \   000001A2   2F08                       MOV     R16,R24
   1206                        break;
   1207                        default:
   1208                        break;
   1209                        };
   1210                      UDR0 = cTmp; /* start transmition */
   \                     ??UART0_UDRE_28:
   \   000001A4   B90C                       OUT     0x0C,R16
   \   000001A6   C003                       RJMP    ??UART0_UDRE_30
   1211                      }
   1212                  else
   1213                      {
   1214                      UCSR0B &= ~(1<<UDRIE0); /* disable UDRE interrupt */
   \                     ??UART0_UDRE_12:
   \   000001A8   9855                       CBI     0x0A,0x05
   \   000001AA   C001                       RJMP    ??UART0_UDRE_30
   1215                      };
   1216                }
   1217                else
   1218                {
   1219                UCSR0B &= ~(1<<UDRIE0); /* disable UDRE interrupt */
   \                     ??UART0_UDRE_10:
   \   000001AC   9855                       CBI     0x0A,0x05
   1220                };
   1221           }
   \                     ??UART0_UDRE_30:
   \   000001AE   BF9F                       OUT     0x3F,R25
   \   000001B0   9109                       LD      R16,Y+
   \   000001B2   9119                       LD      R17,Y+
   \   000001B4   9129                       LD      R18,Y+
   \   000001B6   9139                       LD      R19,Y+
   \   000001B8   9149                       LD      R20,Y+
   \   000001BA   9159                       LD      R21,Y+
   \   000001BC   9169                       LD      R22,Y+
   \   000001BE   9179                       LD      R23,Y+
   \   000001C0   9009                       LD      R0,Y+
   \   000001C2   9019                       LD      R1,Y+
   \   000001C4   9029                       LD      R2,Y+
   \   000001C6   9039                       LD      R3,Y+
   \   000001C8   91E9                       LD      R30,Y+
   \   000001CA   91F9                       LD      R31,Y+
   \   000001CC   9189                       LD      R24,Y+
   \   000001CE   9199                       LD      R25,Y+
   \   000001D0   9518                       RETI

   \                                 In segment INTVEC, offset 0x34, root
   \   00000000   ........                   JMP     UART0_RX

   \                                 In segment INTVEC, offset 0x3c, root
   \   00000000   ........                   JMP     UART0_UDRE

   \                                 In segment NEAR_I, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_I>`
   \   char __near <Constant "%ld">[4];
   \                     `?<Constant "%ld">`:
   \   00000000                              DS 4
   \   00000004                              REQUIRE `?<Initializer for <Constant "%ld">>`

   \                                 In segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "%ld">>`:
   \   00000000   6C250064                   DB "%ld"

   \                                 In segment NEAR_I, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_I>`
   \   char __near <Constant "Table Counters  Rx:">[20];
   \                     `?<Constant "Table Counters  Rx:">`:
   \   00000000                              DS 20
   \   00000014                              REQUIRE `?<Initializer for <Constant "Table Counters  R`

   \                                 In segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "Table Counters  R`:
   \   00000000   61546C622065               DB "Table Counters  Rx:"
   \            6F436E756574
   \            737220207852
   \            003A        

   \                                 In segment NEAR_I, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_I>`
   \   char __near <Constant "%d">[3];
   \                     `?<Constant "%d">`:
   \   00000000                              DS 3
   \   00000003                              REQUIRE `?<Initializer for <Constant "%d">>`

   \                                 In segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "%d">>`:
   \   00000000   642500                     DB "%d"

   \                                 In segment NEAR_I, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_I>`
   \   char __near <Constant "  ">[3];
   \                     `?<Constant "  ">`:
   \   00000000                              DS 3
   \   00000003                              REQUIRE `?<Initializer for <Constant "  ">>`

   \                                 In segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "  ">>`:
   \   00000000   202000                     DB "  "

   \                                 In segment NEAR_I, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_I>`
   \   char __near <Constant "Table Errors Rx/Tx:">[20];
   \                     `?<Constant "Table Errors Rx/Tx:">`:
   \   00000000                              DS 20
   \   00000014                              REQUIRE `?<Initializer for <Constant "Table Errors Rx/T`

   \                                 In segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "Table Errors Rx/T`:
   \   00000000   61546C622065               DB "Table Errors Rx/Tx:"
   \            72456F727372
   \            52202F787854
   \            003A        

   \                                 In segment NEAR_I, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_I>`
   \   char __near <Constant " \n\r">[4];
   \                     `?<Constant " \\n\\r">`:
   \   00000000                              DS 4
   \   00000004                              REQUIRE `?<Initializer for <Constant " \\n\\r">>`

   \                                 In segment NEAR_I, align 1, keep-with-next
   \   00000000                              REQUIRE `?<Segment init: NEAR_I>`
   \   static unsigned char volatile __near A2x_y;
   \                     A2x_y:
   \   00000000                              DS 1
   \   00000001                              REQUIRE `?<Initializer for A2x_y>`

   \                                 In segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant " \\n\\r">>`:
   \   00000000   0A20000D                   DB " \012\015"

   \                                 In segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for A2x_y>`:
   \   00000000   02                         DB 2
   1222          /* This method interrupt event TX Empty */
   1223          /****************************************/
   1224          
   1225          #ifdef TEST_UART0
   1226          /* main - a simple test program*/
   1227          void main( void )
   1228                  {
   1229                  volatile long int l_i;
   1230                  volatile unsigned char cByte;
   1231                  volatile int iByte;
   1232                  volatile int iRet;
   1233                  unsigned int i;
   1234                /*
   1235                  int x;
   1236                  char y;
   1237                  float z;
   1238                */
   1239                  Reset_UART0();
   1240                  Init_S_UART0(57600); // 9600 default
   1241                  Init_2S_UART0(0);
   1242                  Init_B_UART0(1);  // Size Bits '8'
   1243                  Init_P_UART0(0);   // Parity    'N'
   1244                                    // Stop Bit  '1'
   1245                  Echo_OFF_UART0(); // Echo OFF
   1246                  ControlStream_OFF_UART0();      // Flow Control ON
   1247                  XON_XOFF_OFF_CONTR_Rx_UART0(); // Software Control OFF
   1248                  XON_XOFF_OFF_CONTR_Tx_UART0(); // Enable Tx Control
   1249                  /* Enable control hardware flow all signals */
   1250                   DSR_OFF_CONTR_UART0();  // Hardware Flow Control DSR
   1251                   DTR_OFF_CONTR_UART0();  // Hardware Flow Control DTR
   1252                   CTS_OFF_CONTR_UART0();  // Hardware Flow Control CTS
   1253                   RTS_OFF_CONTR_UART0();  // Hardware Flow Control RTS
   1254                   RTS_CLR_UART0();       // RTS0=0 Request to send
   1255                   DTR_CLR_UART0();       // DTR0=0 Data Terminal Ready
   1256                   CTS_CLR_UART0();
   1257                   DSR_CLR_UART0();
   1258                  /***********/
   1259          
   1260                  Enable_Err_Count_UART0();
   1261                  i = 0;
   1262          
   1263                  _SEI(); /* enable interrupts => enable UART interrupts */
   1264                  iRet = printf("Test ver 0.02 for file 'A1x.c' UART0 \n\r");
   1265                  if (Enb_XON_XOFF_Rx_UART0 !=  0)
   1266                  {
   1267                  iRet = printf("%c",Sym_XON);
   1268                  Count_XOFF_Rx_UART0 = 0;
   1269                  };                            // Enable Tx for Computer
   1270          
   1271                          /* test print */ 
   1272                     /*
   1273                          x=1;
   1274                          y='t';
   1275                          z=1230.09876;
   1276                          iRet = printf("%d",x); // yes                
   1277                          iRet = printf("%c",y); // yes                
   1278                          iRet = printf("%f",z); // no type "f" 
   1279                     */
   1280                          /* end print */
   1281          
   1282          
   1283                  while ( 1 ) /* forever */
   1284                         {
   1285          
   1286                          /* test new function getchar() and prints stdin */
   1287                          do 
   1288                          { 
   1289                            iByte = getchar_K();     // new size buffer 40 yes
   1290                            iRet = printf("%c",toupper( (unsigned char) iByte));
   1291                            if (iByte == 0x0A)  // ^J LF  
   1292                            {
   1293                            iRet = printf("\r");                  
   1294                            };
   1295                          }
   1296                          while ( iByte != 0x0A); 
   1297                           
   1298                         
   1299                                          
   1300                        /* test function gets( array) */
   1301                        /* Error test
   1302                          iRet =  (int) gets(test); 
   1303                          if  ( iRet != 0 )
   1304                          {
   1305                          iRet = printf("%s",test);                
   1306                          };
   1307                        */               
   1308                         
   1309                          /* test counters errors */
   1310                          
   1311                          if (DataInReceiveBuffer()!=0)
   1312                          {
   1313                          //cByte = ReceiveByte_UART0();
   1314                          //iRet = printf("%c",cByte); // yes
   1315                            if ( i > 50)  // if 20 symbols Rx and Tx
   1316                            {
   1317                            //iRet = Read_Tx_Rx_Err_UART0();
   1318                            i = 1;
   1319                            };
   1320                          i++;
   1321                          };
   1322          
   1323                          //iByte = (int) cByte;
   1324                          //putchar((int)cByte); // yes
   1325                          //TransmitByte(cByte); /* echo the received character */
   1326                          //putchar((int)cByte); // yes
   1327                          //iRet = sprintf(p,"%ld",Count_Rx_UART0); // yes
   1328                          //iRet = puts(p); // yes
   1329                          //iRet = printf("\n\r Test main i="); // yes
   1330                          //iRet = printf("%d", i); // yes
   1331                          //iRet = printf("%ld",Count_Rx_UART0); // yes
   1332                      };
   1333                  }
   1334          #endif

   Maximum stack usage in bytes:

     Function                     CSTACK  RSTACK
     --------                     ------  ------
     Break_UART0                      0       0 
     CTS_CLR_UART0                    0       0 
     CTS_OFF_CONTR_UART0              0       0 
     CTS_ON_CONTR_UART0               0       0 
     CTS_SET_UART0                    0       0 
     ControlStream_OFF_UART0          0       0 
     ControlStream_ON_UART0           0       0 
     CopySetsEEPROM_UART0             0       0 
     CopySetsROM_UART0                0       0 
     DSR_CLR_UART0                    0       0 
     DSR_OFF_CONTR_UART0              0       0 
     DSR_ON_CONTR_UART0               0       0 
     DSR_SET_UART0                    0       0 
     DTR_CLR_UART0                    0       0 
     DTR_OFF_CONTR_UART0              0       0 
     DTR_ON_CONTR_UART0               0       0 
     DTR_SET_UART0                    0       0 
     DataInReceiveBuffer              0       0 
     Dis_Rx_UART0                     0       0 
     Dis_Tx_UART0                     0       0 
     Dis_UART0                        0       0 
     Disable_Err_Count_UART0          0       0 
     Echo_OFF_UART0                   0       0 
     Echo_ON_UART0                    0       0 
     Enable_Err_Count_UART0           4       2 
       -> Dis_UART0                   4       2 
       -> Enb_UART0                   4       2 
     Enb_Rx_UART0                     0       0 
     Enb_Tx_UART0                     0       0 
     Enb_UART0                        0       0 
     IncErrArr_UART0                  0       2 
     Init_2S_UART0                    1       2 
       -> Dis_UART0                   1       2 
       -> Init_S_UART0                1       2 
       -> Init_S_UART0                1       2 
       -> Enb_UART0                   1       2 
     Init_B_UART0                     1       2 
       -> Dis_UART0                   1       2 
       -> Enb_UART0                   1       2 
     Init_CHR9_UART0                  0       0 
     Init_MPCM_UART0                  1       2 
       -> Dis_UART0                   1       2 
       -> Enb_UART0                   1       2 
     Init_P_UART0                     1       2 
       -> Dis_UART0                   1       2 
       -> Init_CHR9_UART0             1       2 
       -> Init_CHR9_UART0             1       2 
       -> Init_CHR9_UART0             1       2 
       -> Init_CHR9_UART0             1       2 
       -> Init_CHR9_UART0             1       2 
       -> Enb_UART0                   1       2 
     Init_S_UART0                     9       2 
       -> Dis_UART0                   9       2 
       -> Enb_UART0                   9       2 
     RTS_CLR_UART0                    0       0 
     RTS_OFF_CONTR_UART0              0       0 
     RTS_ON_CONTR_UART0               0       0 
     RTS_SET_UART0                    0       0 
     Read_Tx_Rx_Err_UART0            10       2 
       -> printf                      6       2 
       -> printf                      6       2 
       -> printf                      6       2 
       -> printf                      8       2 
       -> printf                      6       2 
       -> printf                      8       2 
       -> printf                      6       2 
       -> printf                      8       2 
       -> printf                      6       2 
       -> printf                      8       2 
       -> printf                      6       2 
       -> printf                      6       2 
       -> printf                      6       2 
       -> printf                     10       2 
       -> printf                      6       2 
       -> printf                     10       2 
       -> printf                      6       2 
     ReceiveByte_UART0                0       0 
     Reset_UART0                      5       2 
       -> CopySetsEEPROM_UART0        5       2 
       -> CopySetsROM_UART0           5       2 
       -> Init_S_UART0                5       2 
     TransmitByte_UART0               0       0 
     UART0_RX                        21       2 
       -> IncErrArr_UART0            21       2 
       -> IncErrArr_UART0            21       2 
       -> CheckParity7               21       2 
       -> CheckParity8               21       2 
       -> IncErrArr_UART0            21       2 
       -> IncErrArr_UART0            21       2 
       -> IncErrArr_UART0            21       2 
       -> IncErrArr_UART0            21       2 
       -> IncErrArr_UART0            21       2 
       -> TransmitByte_UART0         21       2 
       -> TransmitByte_UART0         21       2 
       -> TransmitByte_UART0         21       2 
       -> TransmitByte_UART0         21       2 
       -> TransmitByte_UART0         21       2 
     UART0_UDRE                      16       2 
       -> CheckParity7               16       2 
       -> CheckParity8               16       2 
       -> CheckParity8               16       2 
     XON_XOFF_OFF_CONTR_Rx_UART0      0       0 
     XON_XOFF_OFF_CONTR_Tx_UART0      0       0 
     XON_XOFF_ON_CONTR_Rx_UART0       0       0 
     XON_XOFF_ON_CONTR_Tx_UART0       0       0 

 
     10 bytes in segment ABSOLUTE
   3316 bytes in segment CODE
      1 byte  in segment EEPROM_I
     12 bytes in segment INITTAB
      8 bytes in segment INTVEC
     24 bytes in segment NEAR_F
     55 bytes in segment NEAR_I
     55 bytes in segment NEAR_ID
    138 bytes in segment NEAR_Z
 
   3403 bytes of CODE memory (+ 12 bytes shared)
    193 bytes of DATA memory (+ 10 bytes shared)
      1 byte  of XDATA memory

Errors: none
Warnings: 2
